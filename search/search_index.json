{
    "docs": [
        {
            "location": "/", 
            "text": "MFEM is a \nfree\n, \nlightweight\n, \nscalable\n C++ library for finite element methods.\n\n\nFeatures\n\n\n\n\nArbitrary high-order finite element \nmeshes\n\nand \nspaces\n.\n\n\nWide variety\n of finite element discretization approaches.\n\n\nConforming and nonconforming \nadaptive mesh refinement\n.\n\n\nScalable to \nhundreds of thousands\n of cores.\n\n\n... and \nmany more\n.\n\n\n\n\nMFEM is used in many projects, including\n\nBLAST\n,\n\nXBraid\n, \nVisIt\n, the \nxSDK\n,\nthe \nFASTMath\n institute in SciDAC, and the co-design \nCenter for Efficient Exascale Discretizations (CEED)\n in the \nExascale Computing Project\n.\n\n\nSee\nalso\nour\nGallery\n, related \npublications\n and\nproject \nnews updates\n.\n\n\n\n\n\n\nNews\n\n\n\n\n\n\n\n\nDate\n\n\nMessage\n\n\n\n\n\n\n\n\n\n\nNov 20, 2019\n\n\nMFEM overview \npaper\n available on arXiv.\n\n\n\n\n\n\nMay 24, 2019\n\n\nVersion 4.0 \nreleased\n with initial GPU support.\n\n\n\n\n\n\nMay 10, 2019\n\n\nAMR\n and \nTMOP\n papers available on arXiv.\n\n\n\n\n\n\nNov 9, 2018\n\n\nMFEM part of the \nE4S\n project.\n\n\n\n\n\n\n\n\nLatest Release\n\n\nNew features\n\n\u250a \nExamples\n\n\u250a \nCode documentation\n\n\u250a \nSources\n\n\n\n\nDownload mfem-4.0.tgz\n\n\n\n\nFor older releases see the \ndownload\n section.\n\n\nDocumentation\n\n\nBuilding MFEM\n\n\u250a \nSerial Tutorial\n\n\u250a \nParallel Tutorial\n\n\u250a \nCode Overview\n\n\nFinite Element Method\n\n\u250a \nElectromagnetics\n\n\u250a \nMeshing\n\n\nNew users should start by examining the \nexample codes\n.\n\n\nWe also recommend using \nGLVis\n for visualization.\n\n\nContact\n\n\nUse the GitHub \nissue tracker\n\nto report \nbugs\n\nor post \nquestions\n\nor \ncomments\n.\nSee\nthe \nAbout\n page for citation information.", 
            "title": "Home"
        }, 
        {
            "location": "/#features", 
            "text": "Arbitrary high-order finite element  meshes \nand  spaces .  Wide variety  of finite element discretization approaches.  Conforming and nonconforming  adaptive mesh refinement .  Scalable to  hundreds of thousands  of cores.  ... and  many more .   MFEM is used in many projects, including BLAST , XBraid ,  VisIt , the  xSDK ,\nthe  FASTMath  institute in SciDAC, and the co-design  Center for Efficient Exascale Discretizations (CEED)  in the  Exascale Computing Project .  See also our Gallery , related  publications  and\nproject  news updates .", 
            "title": "Features"
        }, 
        {
            "location": "/#news", 
            "text": "Date  Message      Nov 20, 2019  MFEM overview  paper  available on arXiv.    May 24, 2019  Version 4.0  released  with initial GPU support.    May 10, 2019  AMR  and  TMOP  papers available on arXiv.    Nov 9, 2018  MFEM part of the  E4S  project.", 
            "title": "News"
        }, 
        {
            "location": "/#latest-release", 
            "text": "New features \n\u250a  Examples \n\u250a  Code documentation \n\u250a  Sources   Download mfem-4.0.tgz   For older releases see the  download  section.", 
            "title": "Latest Release"
        }, 
        {
            "location": "/#documentation", 
            "text": "Building MFEM \n\u250a  Serial Tutorial \n\u250a  Parallel Tutorial \n\u250a  Code Overview  Finite Element Method \n\u250a  Electromagnetics \n\u250a  Meshing  New users should start by examining the  example codes .  We also recommend using  GLVis  for visualization.", 
            "title": "Documentation"
        }, 
        {
            "location": "/#contact", 
            "text": "Use the GitHub  issue tracker \nto report  bugs \nor post  questions \nor  comments .\nSee the  About  page for citation information.", 
            "title": "Contact"
        }, 
        {
            "location": "/features/", 
            "text": "Features\n\n\nThe goal of MFEM is to enable research and development of scalable finite element discretization and solver algorithms through general finite element abstractions, accurate and flexible visualization, and tight integration with the \nhypre\n library.\n\n\nConceptually, MFEM can be viewed as a finite element toolbox that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods.\n\n\nHigher-order Finite Element Spaces\n\n\n\n\nMFEM supports a wide variety of \nfinite element\n \nspaces\n in 2D and 3D, including arbitrary high-order:\n\n\n\n\nH\n1\n-conforming, \nH(div)\n-conforming, \nH(curl)\n-conforming spaces,\n\n\ndiscontinuous \nL\n2\n spaces,\n\n\nnumerical trace (\ninterfacial\n) spaces,\n\n\nNURBS\n spaces for isogeometric analysis.\n\n\n\n\nMany \nbilinear\n and \nlinear\n forms defined on these spaces, as well as linear operators such as gradient, curl and embedding between these spaces, are available in the code.\n\n\nFlexible Discretization\n\n\nIn addition to classical Galerkin methods, MFEM enables the quick prototyping of\n\n\n\n\nmixed\n finite elements,\n\n\nDiscontinuous Galerkin (\nDG\n) methods,\n\n\nisogeometric\n analysis methods,\n\n\nDiscontinuous Petrov-Galerkin (\nDPG\n) approaches,\n\n\nHybridization\n and \nstatic condensation\n for high-order problems.\n\n\n\n\n\n\nWide Range of Mesh Types\n\n\nMFEM supports arbitrary element \ntransformations\n and includes classes for dealing with:\n\n\n\n\ntriangular, quadrilateral, tetrahedral, wedge, and hexahedral \nelements\n,\n\n\nuniform refinement (all element types),\n\n\nconforming local mesh refinement (triangular/tetrahedral meshes),\n\n\nnon-conforming mesh refinement (quadrilateral/hexahedral meshes), including anisotropic refinement,\n\n\nmesh optimization\n based on the Target-Matrix Optimization Paradigm (TMOP),\n\n\nhigher-order elements with \ncurved\n boundaries,\n\n\nsurface\n meshes embedded in 3D, topologically \nperiodic\n meshes, 1D meshes.\n\n\n\n\nAdditional support for automated adaptive analysis and parallel unstructured modifications on simplex meshes is provided via integration with the \nPUMI\n distributed mesh management system.\n\n\nParallel, Scalable and GPU-ready\n\n\nMFEM supports MPI-based parallelism throughout the library, and can readily be used as a scalable unstructured finite element problem generator.\n\n\n\n\nMFEM-based \napplications\n have been \nscaled\n to \nhundreds of thousands\n of parallel cores.\n\n\nThe library supports \nefficient operator assembly/evaluation\n for tensor-product high-order elements.\n\n\nSupport for hardware devices, such as GPUs, and programming models, such as CUDA, \nOCCA\n, \nRAJA\n and OpenMP is also included.\n\n\n\n\nA serial MFEM application typically requires \nminimal\n \nchanges\n to transition to a scalable parallel version of the code, where it can take advantage of the integrated scalable linear solvers from the \nhypre\n library. Both of these versions can be further transitioned to \nhigh-performing\n \ntemplated variants\n, where operator assembly/evaluation is fully inlined for particular runtime parameters. As of version 4.0, GPU acceleration of several \nexamples\n and many \nlinear algebra\n and \nfinite element\n operations is available.\n\n\nBuilt-in Solvers\n\n\nMFEM is commonly used as a \"finite element to linear algebra translator\", since it can take a problem described in terms of finite element-type objects, and produce the corresponding linear algebra \nvectors\n and \nsparse matrices\n.\n\n\nSeveral matrix storage formats are available including dense, compressed sparse row (\nCSR\n) and parallel compressed sparse row (\nParCSR\n). Block vectors, operators and \nmatrices\n are also supported.\n\n\nA variety of solvers are available for the resulting linear algebra systems (or semi-discrete time-integration problems):\n\n\n\n\npoint-wise and polynomial \nserial\n and \nparallel\n smoothers,\n\n\n\nKrylov solvers\n, such as PCG, MINRES and GMRES applicable to general \noperators\n in serial and in parallel,\n\n\nparallel \neigensolvers\n: LOBPCG and AME,\n\n\nhigh-performance preconditioners from the \nhypre\n library including the \nBoomerAMG\n, \nAMS\n and \nADS\n solvers,\n\n\nmany linear and nonlinear solvers, preconditioners and time integrators from the \nPETSc\n suite,\n\n\ntime integrators and non-linear solvers from the CVODE, ARKODE and KINSOL libraries of the \nSUNDIALS\n suite,\n\n\ndiscretization-specific solvers for electromagnetic, elasticity, hybridization and DPG methods,\n\n\nparallel\n and \nsequential\n sparse direct solvers based on \nSuperLU\n, \nSTRUMPACK\n and the \nSuiteSparse\n library,\n\n\nexplicit and implicit high-order Runge-Kutta \ntime integrators\n,\n\n\nsolvers for nonlinear problems (Newton, \nHiOp\n) and for single linearly constrained \nquadratic minimization\n problems.\n\n\n\n\nExtensive Examples\n\n\nMFEM includes a number of well-documented \nexample codes\n that can be used as tutorials, as well as simple starting points for user applications. Some of the included example codes are:\n\n\n\n\nExample 1\n: nodal H1 FEM for the Laplace problem,\n\n\nExample 2\n: vector FEM for linear elasticity,\n\n\nExample 3\n: Nedelec H(curl) FEM for the definite Maxwell problem,\n\n\nExample 4\n: Raviart-Thomas H(div) FEM for the grad-div problem,\n\n\nExample 5\n: mixed pressure-velocity FEM for the Darcy problem,\n\n\nExample 6\n: non-conforming adaptive mesh refinement (AMR) for the Laplace problem,\n\n\nExample 7\n: Laplace problem on a surface (the unit sphere),\n\n\nExample 8\n: Discontinuous Petrov-Galerkin (DPG) for the Laplace problem,\n\n\nExample 9\n: Discontinuous Galerkin (DG) time-dependent advection,\n\n\nExample 10\n: time-dependent implicit nonlinear elasticity,\n\n\nExample 11\n: parallel Laplace eigensolver,\n\n\nExample 12\n: parallel linear elasticity eigensolver,\n\n\nExample 13\n: parallel Maxwell eigensolver,\n\n\nExample 14\n: Discontinuous Galerkin (DG) for the Laplace problem,\n\n\nExample 15\n: dynamic AMR for Laplace with prescribed time-dependent source,\n\n\nExample 16\n: time-dependent nonlinear heat equation,\n\n\nExample 17\n: Discontinuous Galerkin (DG) for linear elasticity,\n\n\nExample 18\n: Discontinuous Galerkin (DG) for the Euler equations,\n\n\nExample 19\n: incompressible nonlinear elasticity,\n\n\nExample 20\n: symplectic ODE integration,\n\n\nExample 21\n: adaptive mesh refinement for linear elasticity,\n\n\nExample 22\n: complex-valued linear systems.\n\n\n\n\nMost of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two.\n\n\nMany of the examples also have modifications that take advantage of optional third-party libraries such as \nPETSc\n, \nSUNDIALS\n, \nPUMI\n and \nHiOp\n.\n\n\nBeyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are:\n\n\n\n\nVolta\n: simple electrostatics simulation code,\n\n\nTesla\n: simple magnetostatics simulation code,\n\n\nMaxwell\n: transient electromagnetics simulation code,\n\n\nJoule\n: transient magnetics and Joule heating miniapp,\n\n\nMesh Explorer\n: visualize and manipulate meshes,\n\n\nMesh Optimizer\n: optimize high-order meshes,\n\n\nLOR Transfer\n: map functions between high-order and low-order-refined spaces.\n\n\n\n\nIn addition, the sources for several external benchmark/proxy-apps build on top of MFEM are available:\n\n\n\n\nLaghos\n: high-order Lagrangian hydrodynamics miniapp,\n\n\nMulard\n: multigroup thermal radiation diffusion mini application.\n\n\n\n\nAccurate and Flexible Visualization\n\n\nThe general (high-order) meshes and finite element functions in MFEM can be visualized accurately using the companion OpenGL visualization tool \nGLVis\n, which is built on top of MFEM.\n\n\nThe \nVisIt\n visualization and analysis tool also natively supports MFEM formats.\n\n\nLightweight, Portable and Easily Extendable\n\n\nThe MFEM code base is \nrelatively small\n and is written in highly portable C++ (e.g. with very limited use of templates and the STL).\n\n\n\n\nThe serial version of MFEM has no external dependencies and is \nstraightforward to build\n on Linux, Mac and Windows machines.\n\n\nThe MPI-parallel version uses two third-party libraries (\nhypre\n and METIS), and is also easy to build with an MPI compiler.\n\n\nOn most machines, both versions can be built in under a minute by typing: \"\nmake serial -j\n\" and \"\nmake parallel -j\n\" respectively.\n\n\n\n\nThe object-oriented design of MFEM \nseparates\n the mesh, finite element and linear algebra abstractions, making it easy to extend the library and adapt it to a variety of \napplications\n.\n\n\nOpen Source\n\n\nMFEM is an open-source software, and can be freely used under the terms of the \nLGPL 2.1\n license.", 
            "title": "Features"
        }, 
        {
            "location": "/features/#features", 
            "text": "The goal of MFEM is to enable research and development of scalable finite element discretization and solver algorithms through general finite element abstractions, accurate and flexible visualization, and tight integration with the  hypre  library.  Conceptually, MFEM can be viewed as a finite element toolbox that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods.", 
            "title": "Features"
        }, 
        {
            "location": "/features/#higher-order-finite-element-spaces", 
            "text": "MFEM supports a wide variety of  finite element   spaces  in 2D and 3D, including arbitrary high-order:   H 1 -conforming,  H(div) -conforming,  H(curl) -conforming spaces,  discontinuous  L 2  spaces,  numerical trace ( interfacial ) spaces,  NURBS  spaces for isogeometric analysis.   Many  bilinear  and  linear  forms defined on these spaces, as well as linear operators such as gradient, curl and embedding between these spaces, are available in the code.", 
            "title": "Higher-order Finite Element Spaces"
        }, 
        {
            "location": "/features/#flexible-discretization", 
            "text": "In addition to classical Galerkin methods, MFEM enables the quick prototyping of   mixed  finite elements,  Discontinuous Galerkin ( DG ) methods,  isogeometric  analysis methods,  Discontinuous Petrov-Galerkin ( DPG ) approaches,  Hybridization  and  static condensation  for high-order problems.", 
            "title": "Flexible Discretization"
        }, 
        {
            "location": "/features/#wide-range-of-mesh-types", 
            "text": "MFEM supports arbitrary element  transformations  and includes classes for dealing with:   triangular, quadrilateral, tetrahedral, wedge, and hexahedral  elements ,  uniform refinement (all element types),  conforming local mesh refinement (triangular/tetrahedral meshes),  non-conforming mesh refinement (quadrilateral/hexahedral meshes), including anisotropic refinement,  mesh optimization  based on the Target-Matrix Optimization Paradigm (TMOP),  higher-order elements with  curved  boundaries,  surface  meshes embedded in 3D, topologically  periodic  meshes, 1D meshes.   Additional support for automated adaptive analysis and parallel unstructured modifications on simplex meshes is provided via integration with the  PUMI  distributed mesh management system.", 
            "title": "Wide Range of Mesh Types"
        }, 
        {
            "location": "/features/#parallel-scalable-and-gpu-ready", 
            "text": "MFEM supports MPI-based parallelism throughout the library, and can readily be used as a scalable unstructured finite element problem generator.   MFEM-based  applications  have been  scaled  to  hundreds of thousands  of parallel cores.  The library supports  efficient operator assembly/evaluation  for tensor-product high-order elements.  Support for hardware devices, such as GPUs, and programming models, such as CUDA,  OCCA ,  RAJA  and OpenMP is also included.   A serial MFEM application typically requires  minimal   changes  to transition to a scalable parallel version of the code, where it can take advantage of the integrated scalable linear solvers from the  hypre  library. Both of these versions can be further transitioned to  high-performing   templated variants , where operator assembly/evaluation is fully inlined for particular runtime parameters. As of version 4.0, GPU acceleration of several  examples  and many  linear algebra  and  finite element  operations is available.", 
            "title": "Parallel, Scalable and GPU-ready"
        }, 
        {
            "location": "/features/#built-in-solvers", 
            "text": "MFEM is commonly used as a \"finite element to linear algebra translator\", since it can take a problem described in terms of finite element-type objects, and produce the corresponding linear algebra  vectors  and  sparse matrices .  Several matrix storage formats are available including dense, compressed sparse row ( CSR ) and parallel compressed sparse row ( ParCSR ). Block vectors, operators and  matrices  are also supported.  A variety of solvers are available for the resulting linear algebra systems (or semi-discrete time-integration problems):   point-wise and polynomial  serial  and  parallel  smoothers,  Krylov solvers , such as PCG, MINRES and GMRES applicable to general  operators  in serial and in parallel,  parallel  eigensolvers : LOBPCG and AME,  high-performance preconditioners from the  hypre  library including the  BoomerAMG ,  AMS  and  ADS  solvers,  many linear and nonlinear solvers, preconditioners and time integrators from the  PETSc  suite,  time integrators and non-linear solvers from the CVODE, ARKODE and KINSOL libraries of the  SUNDIALS  suite,  discretization-specific solvers for electromagnetic, elasticity, hybridization and DPG methods,  parallel  and  sequential  sparse direct solvers based on  SuperLU ,  STRUMPACK  and the  SuiteSparse  library,  explicit and implicit high-order Runge-Kutta  time integrators ,  solvers for nonlinear problems (Newton,  HiOp ) and for single linearly constrained  quadratic minimization  problems.", 
            "title": "Built-in Solvers"
        }, 
        {
            "location": "/features/#extensive-examples", 
            "text": "MFEM includes a number of well-documented  example codes  that can be used as tutorials, as well as simple starting points for user applications. Some of the included example codes are:   Example 1 : nodal H1 FEM for the Laplace problem,  Example 2 : vector FEM for linear elasticity,  Example 3 : Nedelec H(curl) FEM for the definite Maxwell problem,  Example 4 : Raviart-Thomas H(div) FEM for the grad-div problem,  Example 5 : mixed pressure-velocity FEM for the Darcy problem,  Example 6 : non-conforming adaptive mesh refinement (AMR) for the Laplace problem,  Example 7 : Laplace problem on a surface (the unit sphere),  Example 8 : Discontinuous Petrov-Galerkin (DPG) for the Laplace problem,  Example 9 : Discontinuous Galerkin (DG) time-dependent advection,  Example 10 : time-dependent implicit nonlinear elasticity,  Example 11 : parallel Laplace eigensolver,  Example 12 : parallel linear elasticity eigensolver,  Example 13 : parallel Maxwell eigensolver,  Example 14 : Discontinuous Galerkin (DG) for the Laplace problem,  Example 15 : dynamic AMR for Laplace with prescribed time-dependent source,  Example 16 : time-dependent nonlinear heat equation,  Example 17 : Discontinuous Galerkin (DG) for linear elasticity,  Example 18 : Discontinuous Galerkin (DG) for the Euler equations,  Example 19 : incompressible nonlinear elasticity,  Example 20 : symplectic ODE integration,  Example 21 : adaptive mesh refinement for linear elasticity,  Example 22 : complex-valued linear systems.   Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two.  Many of the examples also have modifications that take advantage of optional third-party libraries such as  PETSc ,  SUNDIALS ,  PUMI  and  HiOp .  Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are:   Volta : simple electrostatics simulation code,  Tesla : simple magnetostatics simulation code,  Maxwell : transient electromagnetics simulation code,  Joule : transient magnetics and Joule heating miniapp,  Mesh Explorer : visualize and manipulate meshes,  Mesh Optimizer : optimize high-order meshes,  LOR Transfer : map functions between high-order and low-order-refined spaces.   In addition, the sources for several external benchmark/proxy-apps build on top of MFEM are available:   Laghos : high-order Lagrangian hydrodynamics miniapp,  Mulard : multigroup thermal radiation diffusion mini application.", 
            "title": "Extensive Examples"
        }, 
        {
            "location": "/features/#accurate-and-flexible-visualization", 
            "text": "The general (high-order) meshes and finite element functions in MFEM can be visualized accurately using the companion OpenGL visualization tool  GLVis , which is built on top of MFEM.  The  VisIt  visualization and analysis tool also natively supports MFEM formats.", 
            "title": "Accurate and Flexible Visualization"
        }, 
        {
            "location": "/features/#lightweight-portable-and-easily-extendable", 
            "text": "The MFEM code base is  relatively small  and is written in highly portable C++ (e.g. with very limited use of templates and the STL).   The serial version of MFEM has no external dependencies and is  straightforward to build  on Linux, Mac and Windows machines.  The MPI-parallel version uses two third-party libraries ( hypre  and METIS), and is also easy to build with an MPI compiler.  On most machines, both versions can be built in under a minute by typing: \" make serial -j \" and \" make parallel -j \" respectively.   The object-oriented design of MFEM  separates  the mesh, finite element and linear algebra abstractions, making it easy to extend the library and adapt it to a variety of  applications .", 
            "title": "Lightweight, Portable and Easily Extendable"
        }, 
        {
            "location": "/features/#open-source", 
            "text": "MFEM is an open-source software, and can be freely used under the terms of the  LGPL 2.1  license.", 
            "title": "Open Source"
        }, 
        {
            "location": "/examples/", 
            "text": "MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});\n\n\n\n\n\n\n\n\n\nExample Codes and Miniapps\n\n\nThis page provides a brief overview of MFEM's example codes and miniapps. For\ndetailed documentation of the MFEM sources, including the examples, see the\n\nonline Doxygen documentation\n,\nor the \ndoc\n directory in the distribution.\n\n\nThe goal of the example codes is to provide a step-by-step introduction to MFEM\nin simple model settings. The miniapps are more complex, and are intended to be\nmore representative of the advanced usage of the library in physics/application\ncodes. We recommend that new users start with the example codes before moving to\nthe miniapps.\n\n\nClicking on any of the categories below displays examples and miniapps that contain the\ndescribed feature. \nAll examples support (arbitrarily) high-order meshes and\nfinite element spaces\n.\nThe numerical results from the example codes can be visualized using the\nGLVis visualization tool (based on MFEM). See the\n\nGLVis website\n for more details.\n\n\nUsers are encouraged to submit any example codes and miniapps that they have created and\nwould like to share. \n\n\nContact a member of the MFEM team to report\n\nbugs\n\nor post \nquestions\n or \ncomments\n.\n\n\n\n\n\n   \nApplication (PDE)\n\n   \n All\n\n   \n Laplace\n\n   \n Elasticity\n\n   \n Electromagnetics\n\n   \n grad-div\n\n   \n Darcy\n\n   \n Advection\n\n   \n Conduction\n\n   \n Hydrodynamics\n\n   \n Meshing\n\n   \n High-performance\n\n\n\n\n\n   \nFinite Elements\n\n   \n All\n\n   \n $L_2$ discontinuous elements\n\n   \n $H^1$ nodal elements\n\n   \n $H(curl)$ Nedelec elements\n\n   \n $H(div)$ Raviart-Thomas elements\n\n   \n $H^{-1/2}$ interfacial elements\n\n\n\n\n\n\n\n   \nDiscretization\n\n   \n All\n\n   \n Galerkin FEM\n\n   \n Mixed FEM\n\n   \n Discontinuous Galerkin (DG)\n\n   \n Discont. Petrov-Galerkin (DPG)\n\n   \n Hybridization\n\n   \n Static condensation\n\n   \n Isogeometric analysis (NURBS)\n\n   \n Adaptive mesh refinement (AMR)\n\n\n\n\n\n   \nSolver\n\n   \n All\n\n   \n Jacobi\n \n\n   \n Gauss-Seidel\n \n\n   \n PCG\n \n\n   \n MINRES\n \n\n   \n GMRES\n \n\n   \n Algebraic Multigrid (BoomerAMG)\n \n\n   \n Auxiliary-space Maxwell Solver (AMS)\n \n\n   \n Auxiliary-space Divergence Solver (ADS)\n \n\n   \n SuperLU/STRUMPACK (parallel direct)\n\n   \n UMFPACK (serial direct)\n\n   \n Newton method (nonlinear solver)\n\n   \n Explicit Runge-Kutta (ODE integration)\n\n   \n Implicit Runge-Kutta (ODE integration)\n\n   \n Symplectic Algorithm (ODE Integration)\n\n   \n LOBPCG, AME (eigensolvers)\n\n   \n SUNDIALS solvers\n\n   \n PETSc solvers\n\n   \n HiOp solvers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample 1: Laplace Problem\n\n\n\n\nThis example code demonstrates the use of MFEM to define a\nsimple isoparametric finite element discretization of the\nLaplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Specifically, we discretize with the\nfinite element space coming from the mesh (linear by default, quadratic\nfor quadratic curvilinear mesh, NURBS for NURBS mesh, etc.)\n\n\nThe example highlights the use of mesh refinement, finite\nelement grid functions, as well as linear and bilinear forms\ncorresponding to the left-hand side and right-hand side of the\ndiscrete linear system. We also cover the explicit elimination\nof essential boundary conditions, static condensation, and the optional\nconnection to the \nGLVis\n tool for visualization.\n\n\nThe example has a serial (\nex1.cpp\n),\na parallel (\nex1p.cpp\n),\nand HPC versions: \nperformance/ex1.cpp\n,\n\nperformance/ex1p.cpp\n.\nIt also has a PETSc modification in \nexamples/petsc\n\nand a PUMI modification in \nexamples/pumi\n.\n\n\n\n\n\n\n\n\n\n\nExample 2: Linear Elasticity\n\n\n\n\nThis example code solves a simple linear elasticity problem\ndescribing a multi-material cantilever beam.\nSpecifically, we approximate the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = 0$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being\na constant pull down vector on boundary elements with attribute 2, and zero\notherwise. The geometry of the domain is assumed to be as follows:\n\n\n\n\nThe example demonstrates the use of high-order and NURBS vector\nfinite element spaces with the linear elasticity bilinear form,\nmeshes with curved elements, and the definition of piece-wise\nconstant and vector coefficient objects. Static condensation is\nalso illustrated.\n\n\nThe example has a serial (\nex2.cpp\n)\nand a parallel (\nex2p.cpp\n) version.\nIt also has a PETSc modification in \nexamples/petsc\n\nand a PUMI modification in \nexamples/pumi\n.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 3: Definite Maxwell Problem\n\n\n\n\nThis example code solves a simple 3D electromagnetic diffusion\nproblem corresponding to the second order definite Maxwell\nequation $$\\nabla\\times\\nabla\\times\\, E + E = f$$\nwith boundary condition $ E \\times n $ = \"given tangential field\".\nHere, we use a given exact solution $E$ and compute the corresponding r.h.s.\n$f$. We discretize with Nedelec finite elements in 2D or 3D.\n\n\nThe example demonstrates the use of $H(curl)$ finite element\nspaces with the curl-curl and the (vector finite element) mass\nbilinear form, as well as the computation of discretization\nerror when the exact solution is known. Static condensation is\nalso illustrated.\n\n\nThe example has a serial (\nex3.cpp\n)\nand a parallel (\nex3p.cpp\n) version.\nIt also has a PETSc modification in \nexamples/petsc\n.\nWe recommend viewing examples 1-2 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 4: Grad-div Problem\n\n\n\n\nThis example code solves a simple 2D/3D $H(div)$\ndiffusion problem corresponding to the second order definite equation\n$$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$\nwith boundary condition $F \\cdot n$ = \"given normal field\".\nHere we use a given exact solution $F$ and compute the corresponding\nright hand side $f$.  We discretize with the Raviart-Thomas finite elements.\n\n\nThe example demonstrates the use of $H(div)$\nfinite element spaces with the grad-div and $H(div)$\nvector finite element mass bilinear form, as well as the computation of discretization\nerror when the exact solution is known.\nBilinear form hybridization and static condensation are also illustrated.\n\n\nThe example has a serial (\nex4.cpp\n)\nand a parallel (\nex4p.cpp\n) version.\nIt also has a PETSc modification in \nexamples/petsc\n.\nWe recommend viewing examples 1-3 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 5: Darcy Problem\n\n\n\n\nThis example code solves a simple 2D/3D mixed Darcy problem\ncorresponding to the saddle point system\n$$ \\begin{array}{rcl}\n   k\\,{\\bf u} + {\\rm grad}\\,p \n=\n f \\\\\n   -{\\rm div}\\,{\\bf u} \n=\n g\n\\end{array} $$\nwith natural boundary condition $-p = $ \"given pressure\".\nHere we use a given exact solution $({\\bf u},p)$ and compute the\ncorresponding right hand side $(f, g)$. We discretize with Raviart-Thomas\nfinite elements (velocity $\\bf u$) and piecewise discontinuous\npolynomials (pressure $p$).\n\n\nThe example demonstrates the use of the BlockMatrix and BlockOperator\nclasses, as well as the collective saving of several grid functions in\na \nVisIt\n visualization format.\n\n\nThe example has a serial (\nex5.cpp\n)\nand a parallel (\nex5p.cpp\n) version.\nIt also has a PETSc modification in \nexamples/petsc\n.\nWe recommend viewing examples 1-4 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 6: Laplace Problem with AMR\n\n\n\n\nThis is a version of Example 1 with a simple adaptive mesh\nrefinement loop. The problem being solved is again the Laplace\nequation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary\nconditions. The problem is solved on a sequence of meshes which\nare locally refined in a conforming (triangles, tetrahedrons)\nor non-conforming (quadrilaterals, hexahedra) manner according\nto a simple ZZ error estimator.\n\n\nThe example demonstrates MFEM's capability to work with both\nconforming and nonconforming refinements, in 2D and 3D, on\nlinear, curved and surface meshes. Interpolation of functions\nfrom coarse to fine meshes, as well as persistent \nGLVis\n\nvisualization are also illustrated.\n\n\nThe example has a serial (\nex6.cpp\n)\nand a parallel (\nex6p.cpp\n) version.\nIt also has a PETSc modification in \nexamples/petsc\n\nand a PUMI modification in \nexamples/pumi\n.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 7: Surface Meshes\n\n\n\n\nThis example code demonstrates the use of MFEM to define a\ntriangulation of a unit sphere and a simple isoparametric\nfinite element discretization of the Laplace problem with mass\nterm, $$-\\Delta u + u = f.$$\n\n\nThe example highlights mesh generation, the use of mesh\nrefinement, high-order meshes and finite elements, as well as\nsurface-based linear and bilinear forms corresponding to the\nleft-hand side and right-hand side of the discrete linear\nsystem. Simple local mesh refinement is also demonstrated.\n\n\nThe example has a serial (\nex7.cpp\n)\nand a parallel (\nex7p.cpp\n) version.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 8: DPG for the Laplace Problem\n\n\n\n\nThis example code demonstrates the use of the Discontinuous\nPetrov-Galerkin (DPG) method in its primal 2x2 block form as a\nsimple finite element discretization of the Laplace problem\n$$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We\nuse high-order continuous trial space, a high-order interfacial\n(trace) space, and a high-order discontinuous test space\ndefining a local dual ($H^{-1}$) norm.\nWe use the primal form of DPG, see\n\n\"A primal DPG method without a first-order reformulation\"\n,\nDemkowicz and Gopalakrishnan, CAM 2013.\n\n\nThe example highlights the use of interfacial (trace) finite\nelements and spaces, trace face integrators and the definition\nof block operators and preconditioners.\n\n\nThe example has a serial (\nex8.cpp\n)\nand a parallel (\nex8p.cpp\n) version.\nWe recommend viewing examples 1-5 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 9: DG Advection\n\n\n\n\nThis example code solves the time-dependent advection equation\n$$\\frac{\\partial u}{\\partial t} + v \\cdot \\nabla u = 0,$$ where $v$ is a given fluid\nvelocity, and $u_0(x)=u(0,x)$ is a given initial condition.\n\n\nThe example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms\nin MFEM (face integrators), the use of explicit ODE time integrators, the\ndefinition of periodic boundary conditions through periodic meshes, as well as\nthe use of \nGLVis\n for persistent\nvisualization of a time-evolving solution. The saving of time-dependent data\nfiles for external visualization with \nVisIt\n\nis also illustrated.\n\n\nThe example has a serial (\nex9.cpp\n)\nand a parallel (\nex9p.cpp\n) version.\nIt also has a SUNDIALS modification in \nexamples/sundials\n\n, a PETSc modification in \nexamples/petsc\n,\nand a HiOp modification in \nexamples/hiop\n.\n\n\n\n\n\n\n\n\n\n\nExample 10: Nonlinear Elasticity\n\n\n\n\nThis example solves a time dependent nonlinear elasticity problem of the form\n$$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$\nwhere $H$ is a hyperelastic model and $S$ is a viscosity operator of\nLaplacian type. The geometry of the domain is assumed to be as follows:\n\n\n\n\nThe example demonstrates the use of nonlinear operators, as well as their\nimplicit time integration using a Newton method for solving an associated\nreduced backward-Euler type nonlinear equation. Each Newton step requires the\ninversion of a Jacobian matrix, which is done through a (preconditioned) inner\nsolver.\n\n\nThe example has a serial (\nex10.cpp\n)\nand a parallel (\nex10p.cpp\n) version.\nIt also has a SUNDIALS modification in \nexamples/sundials\n\nand a PETSc modification in \nexamples/petsc\n.\nWe recommend viewing examples 2 and 9 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 11: Laplace Eigenproblem\n\n\n\n\nThis example code demonstrates the use of MFEM to solve the eigenvalue problem\n$$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions.\n\n\nWe compute a number of the lowest eigenmodes by discretizing the Laplacian and\nMass operators using a finite element space of the specified order, or an\nisoparametric/isogeometric space if order \n 1 (quadratic for quadratic\ncurvilinear mesh, NURBS for NURBS mesh, etc.)\n\n\nThe example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU or\nSTRUMPACK parallel direct solvers. Reusing a single \nGLVis\n\nvisualization window for multiple eigenfunctions is also illustrated.\n\n\nThe example has only a parallel\n(\nex11p.cpp\n) version.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 12: Linear Elasticity Eigenproblem\n\n\n\n\nThis example code solves the linear elasticity eigenvalue\nproblem for a multi-material cantilever beam.\nSpecifically, we compute a number of the lowest eigenmodes by approximating the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder.\nThe geometry of the domain is assumed to be as follows:\n\n\n\n\nThe example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE.\nReusing a single \nGLVis\n visualization window for multiple\neigenfunctions is also illustrated.\n\n\nThe example has only a parallel\n(\nex12p.cpp\n) version.\nWe recommend viewing examples 2 and 11 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 13: Maxwell Eigenproblem\n\n\n\n\nThis example code solves the Maxwell (electromagnetic)\neigenvalue problem\n$$\\nabla\\times\\nabla\\times\\, E = \\lambda\\, E $$\nwith  homogeneous Dirichlet boundary conditions $E \\times n = 0$.\n\n\nWe compute a number of the lowest nonzero eigenmodes by\ndiscretizing the curl curl operator using a Nedelec finite element space of\nthe specified order in 2D or 3D.\n\n\nThe example highlights the use of the AME subspace eigenvalue\nsolver from HYPRE, which uses LOBPCG and AMS internally.\nReusing a single \nGLVis\n visualization window for multiple\neigenfunctions is also illustrated.\n\n\nThe example has only a parallel\n(\nex13p.cpp\n) version.\nWe recommend viewing examples 3 and 11 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 14: DG Diffusion\n\n\n\n\nThis example code demonstrates the use of MFEM to define a\ndiscontinuous Galerkin (DG) finite element discretization of\nthe Laplace problem  $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Finite element spaces of any order,\nincluding zero on regular grids, are supported. The example highlights the use\nof discontinuous spaces and DG-specific face integrators.\n\n\nThe example has a serial (\nex14.cpp\n)\nand a parallel (\nex14p.cpp\n) version.\nWe recommend viewing examples 1 and 9 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 15: Dynamic AMR\n\n\n\n\nBuilding on \nExample 6\n, this example demonstrates dynamic adaptive mesh refinement.\nThe mesh is adapted to a time-dependent solution by refinement\nas well as by derefinement. For simplicity, the solution is\nprescribed and no time integration is done. However, the error\nestimation and refinement/derefinement decisions are realistic.\n\n\nAt each outer iteration the right hand side function is changed\nto mimic a time dependent problem.  Within each inner iteration\nthe problem is solved on a sequence of meshes which are locally\nrefined according to a simple ZZ error estimator.  At the end\nof the inner iteration the error estimates are also used to\nidentify any elements which may be over-refined and a single\nderefinement step is performed.  After each refinement or\nderefinement step a rebalance operation is performed to keep\nthe mesh evenly distributed among the available processors.\n\n\nThe example demonstrates MFEM's capability to refine, derefine\nand load balance nonconforming meshes, in 2D and 3D, and on\nlinear, curved and surface meshes. Interpolation of functions\nbetween coarse and fine meshes, persistent \nGLVis\n visualization,\nand saving of time-dependent fields for external visualization\nwith \nVisIt\n are also illustrated.\n\n\nThe example has a serial (\nex15.cpp\n)\nand a parallel (\nex15p.cpp\n) version.\nWe recommend viewing examples 1, 6 and 9 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 16: Time Dependent Heat Conduction\n\n\n\n\nThis example code solves a simple 2D/3D time dependent nonlinear heat conduction problem\n$$\\frac{du}{dt} = \\nabla \\cdot \\left( \\kappa + \\alpha u \\right) \\nabla u$$\nwith a natural insulating boundary condition $\\frac{du}{dn} = 0$.\nWe linearize the problem by using the temperature field $u$ from the previous time\nstep to compute the conductivity coefficient.\n\n\nThis example demonstrates both implicit and explicit time integration as well as a single\nPicard step method for linearization. The saving of time dependent data files for external\nvisualization with \nVisIt\n is also illustrated.\n\n\nThe example has a serial (\nex16.cpp\n)\nand a parallel (\nex16p.cpp\n) version.\nWe recommend viewing examples 2, 9, and 10 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 17: DG Linear Elasticity\n\n\n\n\nThis example code solves a simple linear elasticity problem\ndescribing a multi-material cantilever beam using symmetric or\nnon-symmetric discontinuous Galerkin (DG) formulation.\n\n\nSpecifically, we approximate the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = 0$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\nDirichlet, $\\bf{u}=\\bf{u_D}$, on the fixed part of the boundary, namely\nboundary attributes 1 and 2; on the rest of the boundary we use\n${\\sigma}({\\bf u})\\cdot n = {\\bf 0}$. The geometry of the domain is assumed to be\nas follows:\n\n\n\n\nThe example demonstrates the use of high-order DG vector finite\nelement spaces with the linear DG elasticity bilinear form,\nmeshes with curved elements, and the definition of piece-wise\nconstant and function vector-coefficient objects. The use of\nnon-homogeneous Dirichlet b.c. imposed weakly, is also\nillustrated.\n\n\nThe example has a serial (\nex17.cpp\n)\nand a parallel (\nex17p.cpp\n) version.\nWe recommend viewing examples 2 and 14 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 18: DG Euler Equations\n\n\n\n\nThis example code solves the compressible Euler system of equations, a model\nnonlinear hyperbolic PDE, with a discontinuous Galerkin (DG) formulation. The\nprimary purpose is to show how a transient system of nonlinear equations can be\nformulated in MFEM. The equations are solved in conservative form\n\n\n$$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot {\\bf F}(u) = 0$$\n\n\nwith a state vector $u = [ \\rho, \\rho v_0, \\rho v_1, \\rho E ]$, where $\\rho$ is\nthe density, $v_i$ is the velocity in the $i^{\\rm th}$ direction, $E$ is the\ntotal specific energy, and $H = E + p / \\rho$ is the total specific enthalpy.\nThe pressure, $p$ is computed through a simple equation of state (EOS) call.\nThe conservative hydrodynamic flux ${\\bf F}$ in each direction $i$ is\n\n\n$${\\bf F_{\\it i}} = [ \\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_i + p \\delta_{i,1}, \\rho v_i H ]$$\n\n\nSpecifically, the example solves for an exact solution of the equations whereby\na vortex is transported by a uniform flow. Since all boundaries are periodic\nhere, the method's accuracy can be assessed by measuring the difference between\nthe solution and the initial condition at a later time when the vortex returns\nto its initial location.\n\n\nNote that as the order of the spatial discretization increases, the timestep\nmust become smaller. This example currently uses a simple estimate derived by\n\nCockburn and Shu\n\nfor the 1D RKDG method. An additional factor can be tuned by passing the \n--cfl\n\n(or \n-c\n shorter) flag.\n\n\nThe example demonstrates user-defined bilinear and nonlinear form integrators\nfor systems of equations that are defined with block vectors, and how these are\nused with an operator for explicit time integrators. In this case the system\nalso involves an external approximate Riemann solver for the DG interface flux.\nIt also demonstrates how to use GLVis for in-situ visualization of vector grid\nfunctions.\n\n\nThe example has a serial (\nex18.cpp\n)\nand a parallel (\nex18p.cpp\n) version.\nWe recommend viewing examples 9, 14 and 17 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 19: Incompressible Nonlinear Elasticity\n\n\n\n\nThis example code solves the quasi-static incompressible nonlinear\nhyperelasticity equations. Specifically, it solves the nonlinear equation\n$$\n\\nabla \\cdot \\sigma(F) = 0\n$$\nsubject to the constraint\n$$\n\\text{det } F = 1\n$$\nwhere $\\sigma$ is the Cauchy stress and $F_{ij} = \\delta_{ij} + u_{i,j}$ is the deformation\ngradient. To handle the incompressibility constraint, pressure is included as\nan independent unknown $p$ and the stress response is modeled as an \nincompressible\nneo-Hookean hyperelastic solid\n.\nThe geometry of the domain is assumed to be as follows:\n\n\n\n\nThis formulation requires solving the saddle point system\n$$ \\left[ \\begin{array}{cc}\n   K \nB^T \\\\\n   B \n 0\n\\end{array} \\right]\n\\left[\\begin{array}{c} \\Delta u \\\\ \\Delta p \\end{array} \\right] =\n\\left[\\begin{array}{c} R_u \\\\ R_p \\end{array} \\right]\n$$\nat each Newton step. To solve this linear system, we implement a specialized block\npreconditioner of the form\n$$\nP^{-1} =\n\\left[\\begin{array}{cc} I \n -\\tilde{K}^{-1}B^T \\\\ 0 \n I \\end{array} \\right]\n\\left[\\begin{array}{cc} \\tilde{K}^{-1} \n 0 \\\\ 0 \n -\\gamma \\tilde{S}^{-1} \\end{array} \\right]\n$$\nwhere $\\tilde{K}^{-1}$ is an approximation of the inverse of the stiffness matrix $K$ and\n$\\tilde{S}^{-1}$ is an approximation of the inverse of the Schur complement $S = BK^{-1}B^T$.\nTo approximate the Schur complement, we use the mass matrix for the pressure variable $p$.\n\n\nThe example demonstrates how to solve nonlinear systems of equations that are defined with\nblock vectors as well as how to implement specialized block preconditioners for use in\niterative solvers.\n\n\nThe example has a serial (\nex19.cpp\n)\nand a parallel (\nex19p.cpp\n) version.\nWe recommend viewing examples 2, 5 and 10 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 20: Symplectic Integration of Hamiltonian Systems\n\n\n\n\nThis example demonstrates the use of the variable order, symplectic time\nintegration algorithm. Symplectic integration algorithms are designed to\nconserve energy when integrating systems of ODEs which are derived from\nHamiltonian systems.\n\n\nHamiltonian systems define the energy of a system as a function of\ntime (t), a set of generalized coordinates (q), and their corresponding\ngeneralized momenta (p).\n$$\nH(q,p,t) = T(p) + V(q,t)\n$$\nHamilton's equations then specify how q and p evolve in time:\n$$\n\\frac{dq}{dt} =  \\frac{dH}{dp}\\,,\\qquad\n\\frac{dp}{dt} = -\\frac{dH}{dq}\n$$\n\n\nTo use the symplectic integration classes we need to define an \nmfem::Operator\n\n${\\bf P}$ which evaluates the action of dH/dp, and an\n\nmfem::TimeDependentOperator\n ${\\bf F}$ which computes -dH/dq.\n\n\nThis example visualizes its results as an evolution in phase space by defining\nthe axes to be $q$, $p$, and $t$ rather than $x$, $y$, and $z$.  In this space\nwe build a ribbon-like mesh with nodes at $(0,0,t)$ and $(q,p,t)$. Finally we\nplot the energy as a function of time as a scalar field on this ribbon-like\nmesh.  This scheme highlights any variations in the energy of the system.\n\n\nThis example offers five simple 1D Hamiltonians:\n\n\n\n\nSimple Harmonic Oscillator (mass on a spring)\n  $$H = \\frac{1}{2}\\left( \\frac{p^2}{m} + \\frac{q^2}{k} \\right)$$\n\n\nPendulum\n  $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} - k \\left( 1 - cos(q) \\right) \\right]$$\n\n\nGaussian Potential Well\n  $$H = \\frac{p^2}{2m} - k e^{-q^2 / 2}$$\n\n\nQuartic Potential\n  $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 + q^2 \\right) q^2 \\right]$$\n\n\nNegative Quartic Potential\n  $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 - \\frac{q^2}{8} \\right) q^2 \\right]$$\n\n\n\n\nIn all cases these Hamiltonians are shifted by constant values so that the\nenergy will remain positive. The mean and standard deviation of the computed\nenergies at each time step are displayed upon completion.\n\n\nWhen run in parallel, each processor integrates the same Hamiltonian\nsystem but starting from different initial conditions.\n\n\nThe example has a serial (\nex20.cpp\n)\nand a parallel (\nex20p.cpp\n) version.\nSee the \nMaxwell\n miniapp for another\napplication of symplectic integration.\n\n\n\n\n\n\n\n\n\n\nExample 21: Adaptive mesh refinement for linear elasticity\n\n\n\n\nThis is a version of Example 2 with a simple adaptive mesh\nrefinement loop. The problem being solved is again linear\nelasticity describing a multi-material cantilever beam.\nThe problem is solved on a sequence of meshes which\nare locally refined in a conforming (triangles, tetrahedrons)\nor non-conforming (quadrilaterals, hexahedra) manner according\nto a simple ZZ error estimator.\n\n\nThe example demonstrates MFEM's capability to work with both\nconforming and nonconforming refinements, in 2D and 3D, on\nlinear and curved meshes. Interpolation of functions from\ncoarse to fine meshes, as well as persistent GLVis\nvisualization are also illustrated.\n\n\nThe example has a serial (\nex21.cpp\n)\nand a parallel (\nex21p.cpp\n) version.\nWe recommend viewing Examples 2 and 6 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nExample 22: Complex Linear Systems\n\n\n\n\nThis example code demonstrates the use of MFEM to define and\nsolve a complex-valued linear system. It implements three variants\nof a damped harmonic oscillator:\n\n\n\n\n\n\nA scalar $H^1$ field:\n  $$-\\nabla\\cdot\\left(a \\nabla u\\right) - \\omega^2 b\\,u + i\\,\\omega\\,c\\,u = 0$$\n\n\n\n\n\n\nA vector $H(Curl)$ field:\n  $$\\nabla\\times\\left(a\\nabla\\times\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$\n\n\n\n\n\n\nA vector $H(Div)$ field:\n  $$-\\nabla\\left(a \\nabla\\cdot\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$\n\n\n\n\n\n\nIn each case the field is driven by a forced oscillation, with\nangular frequency $\\omega$, imposed at the boundary or a portion\nof the boundary.\n\n\nThe example also demonstrates how to display a time-varying solution as\na sequence of fields sent to a single GLVis socket.\n\n\nThe example has a serial (\nex22.cpp\n)\nand a parallel (\nex22p.cpp\n) version.\nWe recommend viewing examples 1, 3, and 4 before viewing this example.\n\n\n\n\n\n\n\n\n\n\nVolta Miniapp: Electrostatics\n\n\n\n\nThis miniapp demonstrates the use of MFEM to solve realistic problems\nin the field of linear electrostatics.  Its features include:\n\n\n\n\ndielectric materials\n\n\ncharge densities\n\n\nsurface charge densities\n\n\nprescribed voltages\n\n\napplied polarizations\n\n\nhigh order meshes\n\n\nhigh order basis functions\n\n\nadaptive mesh refinement\n\n\nadvanced visualization\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/electromagnetics\n directory.\n\n\nThe miniapp has only a parallel\n(\nvolta.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nTesla Miniapp: Magnetostatics\n\n\n\n\nThis miniapp showcases many of MFEM's features while solving a variety\nof realistic magnetostatics problems.  Its features include:\n\n\n\n\ndiamagnetic and/or paramagnetic materials\n\n\nferromagnetic materials\n\n\nvolumetric current densities\n\n\nsurface current densities\n\n\nexternal fields\n\n\nhigh order meshes\n\n\nhigh order basis functions\n\n\nadaptive mesh refinement\n\n\nadvanced visualization\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/electromagnetics\n directory.\n\n\nThe miniapp has only a parallel\n(\ntesla.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nMaxwell Miniapp: Transient Full-Wave Electromagnetics\n\n\n\n\nThis miniapp solves the equations of transient full-wave electromagnetics.\n\n\nIts features include:\n\n\n\n\nmixed formulation of the coupled first-order Maxwell equations\n\n\n$H(\\mathrm{curl})$ discretization of the electric field\n\n\n$H(\\mathrm{div})$ discretization of the magnetic flux\n\n\nenergy conserving, variable order, implicit time integration\n\n\ndielectric materials\n\n\ndiamagnetic and/or paramagnetic materials\n\n\nconductive materials\n\n\nvolumetric current densities\n\n\nSommerfeld absorbing boundary conditions\n\n\nhigh order meshes\n\n\nhigh order basis functions\n\n\nadvanced visualization\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/electromagnetics\n directory.\n\n\nThe miniapp has only a parallel\n(\nmaxwell.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nJoule Miniapp: Transient Magnetics and Joule Heating\n\n\n\n\nThis miniapp solves the equations of transient low-frequency (a.k.a. eddy current)\nelectromagnetics, and simultaneously computes transient heat transfer with the heat source given\nby the electromagnetic Joule heating.\n\n\nIts features include:\n\n\n\n\n$H^1$ discretization of the electrostatic potential\n\n\n$H(\\mathrm{curl})$ discretization of the electric field\n\n\n$H(\\mathrm{div})$ discretization of the magnetic field\n\n\n$H(\\mathrm{div})$ discretization of the heat flux\n\n\n$L^2$ discretization of the temperature\n\n\nimplicit transient time integration\n\n\nhigh order meshes\n\n\nhigh order basis functions\n\n\nadaptive mesh refinement\n\n\nadvanced visualization\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/electromagnetics\n directory.\n\n\nThe miniapp has only a parallel\n(\njoule.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nMobius Strip Miniapp\n\n\n\n\nThis miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.\n\n\nManipulating the mesh topology and performing mesh transformation are demonstrated.\n\n\nThe \nmobius-strip\n mesh in the \ndata\n directory was generated with this miniapp.\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has only a serial\n(\nmobius-strip.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nKlein Bottle Miniapp\n\n\n\n\nThis miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.\n\n\nManipulating the mesh topology and performing mesh transformation are demonstrated.\n\n\nThe \nklein-bottle\n and \nklein-donut\n meshes in the \ndata\n directory were generated with this miniapp.\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has only a serial\n(\nklein-bottle.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nToroid Miniapp\n\n\n\n\nThis miniapp generates two types of toroidal volume meshes; one with\ntriangular cross sections and one with square cross sections.  It\nworks by defining a stack of individual elements and bending them so\nthat the bottom and top of the stack can be joined to form a torus. It\nsupports various options including:\n\n\n\n\nThe element type: 0 - Wedge, 1 - Hexahedron\n\n\nThe geometric order of the elements\n\n\nThe major and minor radii\n\n\nThe number of elements in the azimuthal direction\n\n\nThe number of nodes to offset by before rejoining the stack\n\n\nThe initial angle of the cross sectional shape\n\n\nThe number of uniform refinement steps to apply\n\n\n\n\nAlong with producing some visually interesting meshes, this miniapp\ndemonstrates how simple 3D meshes can be constructed and transformed\nin MFEM.  It also produces a family of meshes with simple but\nnon-trivial topology for testing various features in MFEM.\n\n\nThis miniapp has only a serial\n(\ntoroid.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nExtruder Miniapp\n\n\n\n\nThis miniapp creates higher dimensional meshes from lower dimensional meshes\nby extrusion.  Simple coordinate transformations can also be applied if desired.\n\n\n\n\nThe initial mesh can be 1D or 2D\n\n\n1D meshes can be extruded in both the y and z directions\n\n\n2D meshes can be triangular, quadrilateral, or contain both element types\n\n\nMeshes with high order geometry are supported\n\n\nUser can specify the number of elements and the distance to extrude\n\n\nGeometric order of the transformed mesh can be user selected or automatic\n\n\n\n\nThis miniapp provides another demonstration of how simple meshes can be\nconstructed and transformed in MFEM.\n\n\nThis miniapp has only a serial\n(\nextruder.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nShaper Miniapp\n\n\n\n\nThis miniapp performs multiple levels of adaptive mesh refinement to resolve the\ninterfaces between different \"materials\" in the mesh, as specified by a given\nmaterial function.\n\n\nIt can be used as a simple initial mesh generator, for example in the case when\nthe interface is too complex to describe without local refinement. Both\nconforming and non-conforming refinements are supported.\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has only a serial\n(\nshaper.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nMesh Explorer Miniapp\n\n\n\n\nThis miniapp is a handy tool to examine, visualize and manipulate a given\nmesh. Some of its features are:\n\n\n\n\nvisualizing of mesh materials and individual mesh elements\n\n\nmesh scaling, randomization, and general transformation\n\n\nmanipulation of the mesh curvature\n\n\nthe ability to simulate parallel partitioning\n\n\nquantitative and visual reports of mesh quality\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has only a serial\n(\nmesh-explorer.cpp\n) version.\n\nWe recommend that new users start with the example codes before moving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nMesh Optimizer Miniapp\n\n\n\n\nThis miniapp performs mesh optimization using the Target-Matrix Optimization\nParadigm (TMOP) by P.Knupp et al., and a global variational minimization\napproach. It minimizes the quantity\n\n\n$$\\sum_T \\int_T \\mu(J(x)),$$\n\n\nwhere $T$ are the target (ideal) elements, $J$ is the Jacobian of the\ntransformation from the target to the physical element, and $\\mu$ is the mesh\nquality metric.\n\n\nThis metric can measure shape, size or alignment of the region around each\nquadrature point. The combination of targets and quality metrics is used to\noptimize the physical node positions, i.e., they must be as close as possible to\nthe shape / size / alignment of their targets.\n\n\nThis code also demonstrates a possible use of nonlinear operators, as well as\ntheir coupling to Newton methods for solving minimization problems. Note that\nthe utilized Newton methods are oriented towards avoiding invalid meshes with\nnegative Jacobian determinants. Each Newton step requires the inversion of a\nJacobian matrix, which is done through an inner linear solver.\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has a serial\n(\nmesh-optimizer.cpp\n) and a\nparallel (\npmesh-optimizer.cpp\n)\nversion.\n\nWe recommend that new users start with the example codes before moving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nLow-Order Refined Transfer Miniapp\n\n\n\n\nThe \nlor-transfer\n miniapp, found under \nminiapps/tools\n demonstrates the\ncapability to generate a \nlow-order refined\n mesh from a high-order mesh, and to\ntransfer solutions between these meshes.\n\n\nGrid functions can be transferred between the coarse, high-order mesh and the\nlow-order refined mesh using either $L^2$ projection or pointwise evaluation.\nThese transfer operators can be designed to discretely conserve mass and to\nrecover the original high-order solution when transferring a low-order grid\nfunction that was obtained by restricting a high-order grid function to the\nlow-order refined space.\n\n\nThe miniapp has only a serial\n(\nlor-transfer.cpp\n) version.\n\nWe recommend that new users start with the example codes before moving to the miniapps.\n\n\n\n\n\n\n\n\n\n\nLaghos Miniapp\n\n\n\n\nLaghos\n (LAGrangian High-Order Solver) is a miniapp that solves the\ntime-dependent Euler equations of compressible gas dynamics in a moving\nLagrangian frame using unstructured high-order finite element spatial\ndiscretization and explicit high-order time-stepping.\n\n\nThe computational motives captured in Laghos include:\n\n\n\n\nSupport for unstructured meshes, in 2D and 3D, with quadrilateral and\n  hexahedral elements (triangular and tetrahedral elements can also be used, but\n  with the less efficient full assembly option). Serial and parallel mesh\n  refinement options can be set via a command-line flag.\n\n\nExplicit time-stepping loop with a variety of time integrator options. Laghos\n  supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6.\n\n\nContinuous and discontinuous high-order finite element discretization spaces\n  of runtime-specified order.\n\n\nMoving (high-order) meshes.\n\n\nSeparation between the assembly and the quadrature point-based computations.\n\n\nPoint-wise definition of mesh size, time-step estimate and artificial\n  viscosity coefficient.\n\n\nConstant-in-time velocity mass operator that is inverted iteratively on\n  each time step. This is an example of an operator that is prepared once (fully\n  or partially assembled), but is applied many times. The application cost is\n  dominant for this operator.\n\n\nTime-dependent force matrix that is prepared every time step (fully or\n  partially assembled) and is applied just twice per \"assembly\". Both the\n  preparation and the application costs are important for this operator.\n\n\nDomain-decomposed MPI parallelism.\n\n\nOptional in-situ visualization with \nGLVis\n and data output\n  for visualization / data analysis with \nVisIt\n.\n\n\n\n\nThe Laghos miniapp is part of the \nCEED software suite\n,\na collection of software benchmarks, miniapps, libraries and APIs for\nefficient exascale discretizations based on high-order finite element\nand spectral element methods. See http://github.com/ceed for more\ninformation and source code availability.\n\n\nThis is an external miniapp, available at \nhttps://github.com/CEED/Laghos\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo examples or miniapps match your criteria.\n\n\n\n\n\n\n\n\n\n\n\n\n\n<!--\nfunction isChecked(id)\n{\n    return document.getElementById(id).checked;\n}\n\nfunction setChecked(id, value)\n{\n    document.getElementById(id).checked = value;\n}\n\nfunction showElement(id, show)\n{\n    //document.getElementById(id).style.display = show ? \"block\" : \"none\";\n\n    // workaround because Doxygen splits and duplicates the divs for some reason\n    var divs = document.getElementsByTagName(\"div\");\n    for (i = 0; i < divs.length; i++)\n        if (divs.item(i).id == id)\n            divs.item(i).style.display = show ? \"block\" : \"none\";\n}\n\nfunction updateGroup(names, id)\n{\n   // make only one box checked in the group\n   if (names.indexOf(id) != -1)\n      for (i = 0; i < names.length; ++i)\n         setChecked(names[i], id == names[i]);\n\n   // generate boolean variables from the group names\n   for (i = 0; i < names.length; ++i)\n      this[names[i]] = isChecked(names[i]) || isChecked(names[0]);\n}\n\nfunction elementVisible(id)\n{\n   var elem = document.getElementById(id);\n   return elem != null && elem.style.display != \"none\";\n}\n\nfunction exampleVisible(num)\n{\n   return elementVisible(\"ex\"+num);// || elementVisible(\"ex\"+num+\"p\");\n}\n\nfunction update(id)\n{\n   var group1 = [\"all1\", \"laplace\", \"elasticity\", \"maxwell\", \"graddiv\", \"darcy\", \"advection\", \"conduction\", \"hydro\", \"meshing\", \"hpc\"];\n   var group2 = [\"all2\", \"l2\", \"h1\", \"hcurl\", \"hdiv\", \"h12\"];\n   var group3 = [\"all3\", \"galerkin\", \"mixed\", \"dg\", \"dpg\", \"hybr\", \"staticcond\", \"nurbs\", \"amr\" ];\n   var group4 = [\"all4\", \"jacobi\", \"gs\", \"pcg\", \"minres\", \"gmres\", \"amg\", \"ams\", \"ads\", \"superlu\", \"umfpack\", \"newton\", \"rk\", \"sdirk\", \"symplectic\", \"lobpcg\", \"sundials\", \"petsc\", \"hiop\"];\n\n   updateGroup(group1, id);\n   updateGroup(group2, id);\n   updateGroup(group3, id);\n   updateGroup(group4, id);\n\n   // Example codes\n   var numExamples = 22; // update when adding examples!\n   showElement(\"ex1\",  (laplace  || hpc) && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex2\",  elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex3\",  maxwell && hcurl && (galerkin || staticcond) && (gs || pcg || umfpack || ams || petsc));\n   showElement(\"ex4\",  graddiv && (hdiv || h12) && (galerkin || hybr || staticcond) && (gs || pcg || umfpack || amg || ads || ams || petsc));\n   showElement(\"ex5\",  darcy && (l2 || hdiv) && mixed && (gs || jacobi || minres || umfpack || amg  || petsc));\n   showElement(\"ex6\",  laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex7\",  (laplace || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex8\",  laplace && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams));\n   showElement(\"ex9\",  advection && l2 && dg && (pcg || rk || sundials || petsc || hiop));\n   showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc));\n   showElement(\"ex11\", laplace && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu));\n   showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg));\n   showElement(\"ex13\", maxwell && hcurl && galerkin && (lobpcg || ams));\n   showElement(\"ex14\", laplace && l2 && dg && (gs || pcg || gmres || umfpack || amg));\n   showElement(\"ex15\", laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex16\", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk || sundials));\n   showElement(\"ex17\", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg));\n   showElement(\"ex18\", hydro && l2 && dg && (rk));\n   showElement(\"ex19\", elasticity && h1 && mixed && (gs || gmres || newton || amg));\n   showElement(\"ex20\", (elasticity || maxwell || conduction || hydro) && symplectic);\n   showElement(\"ex21\", elasticity && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex22\", (laplace || maxwell || graddiv) && (h1 || hcurl || hdiv) && galerkin && (gmres || amg || ams || ads));\n\n   // Electromagnetic miniapps\n   numExamples += 4; // update when adding miniapps!\n   showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg));\n   showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams));\n   showElement(\"maxwell\", (maxwell || conduction) && (hdiv || hcurl) && (galerkin || staticcond || mixed) && (pcg || symplectic));\n   showElement(\"joule\", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk));\n\n   // Meshing miniapps\n   numExamples += 8; // update when adding miniapps!\n   showElement(\"mobius-strip\", meshing && all2 && all3 && all4);\n   showElement(\"klein-bottle\", meshing && all2 && all3 && all4);\n   showElement(\"toroid\", meshing && all2 && all3 && all4);\n   showElement(\"extruder\", meshing && all2 && all3 && all4);\n   showElement(\"shaper\", meshing && all2 && all3 && all4);\n   showElement(\"mesh-explorer\", meshing && all2 && all3 && all4);\n   showElement(\"mesh-optimizer\", meshing && all2 && all3 && all4);\n   showElement(\"lor-transfer\", meshing && (l2 || h1) && all3 && all4);\n\n   // External miniapps\n   numExamples += 1; // update when adding miniapps!\n   showElement(\"laghos\", (hydro || hpc) && all2 && all3 && all4);\n\n   var allHidden = true;\n   for (i = 1; i <= numExamples; i++) {  // FIXME this no longer works with the miniapps!\n      if (exampleVisible(i)) {\n         allHidden = false;\n         break;\n      }\n   }\n   showElement(\"nomatch\", allHidden);\n}\n\nfunction initButtons()\n{\n   var query = location.search.substr(1);\n   query.split(\"&\").forEach(function(id)\n   {\n      setChecked(id, true);\n      update(id);\n   });\n}\n\n// make sure \"no match\" div is not visible after page is loaded\nwindow.onload = update;\n\n// force vertical scrollbar\ndocument.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\"\n\n// parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs\ninitButtons();\n\n//-->", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#example-codes-and-miniapps", 
            "text": "This page provides a brief overview of MFEM's example codes and miniapps. For\ndetailed documentation of the MFEM sources, including the examples, see the online Doxygen documentation ,\nor the  doc  directory in the distribution.  The goal of the example codes is to provide a step-by-step introduction to MFEM\nin simple model settings. The miniapps are more complex, and are intended to be\nmore representative of the advanced usage of the library in physics/application\ncodes. We recommend that new users start with the example codes before moving to\nthe miniapps.  Clicking on any of the categories below displays examples and miniapps that contain the\ndescribed feature.  All examples support (arbitrarily) high-order meshes and\nfinite element spaces .\nThe numerical results from the example codes can be visualized using the\nGLVis visualization tool (based on MFEM). See the GLVis website  for more details.  Users are encouraged to submit any example codes and miniapps that they have created and\nwould like to share.   Contact a member of the MFEM team to report bugs \nor post  questions  or  comments .", 
            "title": "Example Codes and Miniapps"
        }, 
        {
            "location": "/examples/#example-1-laplace-problem", 
            "text": "This example code demonstrates the use of MFEM to define a\nsimple isoparametric finite element discretization of the\nLaplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Specifically, we discretize with the\nfinite element space coming from the mesh (linear by default, quadratic\nfor quadratic curvilinear mesh, NURBS for NURBS mesh, etc.)  The example highlights the use of mesh refinement, finite\nelement grid functions, as well as linear and bilinear forms\ncorresponding to the left-hand side and right-hand side of the\ndiscrete linear system. We also cover the explicit elimination\nof essential boundary conditions, static condensation, and the optional\nconnection to the  GLVis  tool for visualization.  The example has a serial ( ex1.cpp ),\na parallel ( ex1p.cpp ),\nand HPC versions:  performance/ex1.cpp , performance/ex1p.cpp .\nIt also has a PETSc modification in  examples/petsc \nand a PUMI modification in  examples/pumi .", 
            "title": "Example 1: Laplace Problem"
        }, 
        {
            "location": "/examples/#example-2-linear-elasticity", 
            "text": "This example code solves a simple linear elasticity problem\ndescribing a multi-material cantilever beam.\nSpecifically, we approximate the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = 0$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being\na constant pull down vector on boundary elements with attribute 2, and zero\notherwise. The geometry of the domain is assumed to be as follows:   The example demonstrates the use of high-order and NURBS vector\nfinite element spaces with the linear elasticity bilinear form,\nmeshes with curved elements, and the definition of piece-wise\nconstant and vector coefficient objects. Static condensation is\nalso illustrated.  The example has a serial ( ex2.cpp )\nand a parallel ( ex2p.cpp ) version.\nIt also has a PETSc modification in  examples/petsc \nand a PUMI modification in  examples/pumi .\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 2: Linear Elasticity"
        }, 
        {
            "location": "/examples/#example-3-definite-maxwell-problem", 
            "text": "This example code solves a simple 3D electromagnetic diffusion\nproblem corresponding to the second order definite Maxwell\nequation $$\\nabla\\times\\nabla\\times\\, E + E = f$$\nwith boundary condition $ E \\times n $ = \"given tangential field\".\nHere, we use a given exact solution $E$ and compute the corresponding r.h.s.\n$f$. We discretize with Nedelec finite elements in 2D or 3D.  The example demonstrates the use of $H(curl)$ finite element\nspaces with the curl-curl and the (vector finite element) mass\nbilinear form, as well as the computation of discretization\nerror when the exact solution is known. Static condensation is\nalso illustrated.  The example has a serial ( ex3.cpp )\nand a parallel ( ex3p.cpp ) version.\nIt also has a PETSc modification in  examples/petsc .\nWe recommend viewing examples 1-2 before viewing this example.", 
            "title": "Example 3: Definite Maxwell Problem"
        }, 
        {
            "location": "/examples/#example-4-grad-div-problem", 
            "text": "This example code solves a simple 2D/3D $H(div)$\ndiffusion problem corresponding to the second order definite equation\n$$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$\nwith boundary condition $F \\cdot n$ = \"given normal field\".\nHere we use a given exact solution $F$ and compute the corresponding\nright hand side $f$.  We discretize with the Raviart-Thomas finite elements.  The example demonstrates the use of $H(div)$\nfinite element spaces with the grad-div and $H(div)$\nvector finite element mass bilinear form, as well as the computation of discretization\nerror when the exact solution is known.\nBilinear form hybridization and static condensation are also illustrated.  The example has a serial ( ex4.cpp )\nand a parallel ( ex4p.cpp ) version.\nIt also has a PETSc modification in  examples/petsc .\nWe recommend viewing examples 1-3 before viewing this example.", 
            "title": "Example 4: Grad-div Problem"
        }, 
        {
            "location": "/examples/#example-5-darcy-problem", 
            "text": "This example code solves a simple 2D/3D mixed Darcy problem\ncorresponding to the saddle point system\n$$ \\begin{array}{rcl}\n   k\\,{\\bf u} + {\\rm grad}\\,p  =  f \\\\\n   -{\\rm div}\\,{\\bf u}  =  g\n\\end{array} $$\nwith natural boundary condition $-p = $ \"given pressure\".\nHere we use a given exact solution $({\\bf u},p)$ and compute the\ncorresponding right hand side $(f, g)$. We discretize with Raviart-Thomas\nfinite elements (velocity $\\bf u$) and piecewise discontinuous\npolynomials (pressure $p$).  The example demonstrates the use of the BlockMatrix and BlockOperator\nclasses, as well as the collective saving of several grid functions in\na  VisIt  visualization format.  The example has a serial ( ex5.cpp )\nand a parallel ( ex5p.cpp ) version.\nIt also has a PETSc modification in  examples/petsc .\nWe recommend viewing examples 1-4 before viewing this example.", 
            "title": "Example 5: Darcy Problem"
        }, 
        {
            "location": "/examples/#example-6-laplace-problem-with-amr", 
            "text": "This is a version of Example 1 with a simple adaptive mesh\nrefinement loop. The problem being solved is again the Laplace\nequation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary\nconditions. The problem is solved on a sequence of meshes which\nare locally refined in a conforming (triangles, tetrahedrons)\nor non-conforming (quadrilaterals, hexahedra) manner according\nto a simple ZZ error estimator.  The example demonstrates MFEM's capability to work with both\nconforming and nonconforming refinements, in 2D and 3D, on\nlinear, curved and surface meshes. Interpolation of functions\nfrom coarse to fine meshes, as well as persistent  GLVis \nvisualization are also illustrated.  The example has a serial ( ex6.cpp )\nand a parallel ( ex6p.cpp ) version.\nIt also has a PETSc modification in  examples/petsc \nand a PUMI modification in  examples/pumi .\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 6: Laplace Problem with AMR"
        }, 
        {
            "location": "/examples/#example-7-surface-meshes", 
            "text": "This example code demonstrates the use of MFEM to define a\ntriangulation of a unit sphere and a simple isoparametric\nfinite element discretization of the Laplace problem with mass\nterm, $$-\\Delta u + u = f.$$  The example highlights mesh generation, the use of mesh\nrefinement, high-order meshes and finite elements, as well as\nsurface-based linear and bilinear forms corresponding to the\nleft-hand side and right-hand side of the discrete linear\nsystem. Simple local mesh refinement is also demonstrated.  The example has a serial ( ex7.cpp )\nand a parallel ( ex7p.cpp ) version.\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 7: Surface Meshes"
        }, 
        {
            "location": "/examples/#example-8-dpg-for-the-laplace-problem", 
            "text": "This example code demonstrates the use of the Discontinuous\nPetrov-Galerkin (DPG) method in its primal 2x2 block form as a\nsimple finite element discretization of the Laplace problem\n$$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We\nuse high-order continuous trial space, a high-order interfacial\n(trace) space, and a high-order discontinuous test space\ndefining a local dual ($H^{-1}$) norm.\nWe use the primal form of DPG, see \"A primal DPG method without a first-order reformulation\" ,\nDemkowicz and Gopalakrishnan, CAM 2013.  The example highlights the use of interfacial (trace) finite\nelements and spaces, trace face integrators and the definition\nof block operators and preconditioners.  The example has a serial ( ex8.cpp )\nand a parallel ( ex8p.cpp ) version.\nWe recommend viewing examples 1-5 before viewing this example.", 
            "title": "Example 8: DPG for the Laplace Problem"
        }, 
        {
            "location": "/examples/#example-9-dg-advection", 
            "text": "This example code solves the time-dependent advection equation\n$$\\frac{\\partial u}{\\partial t} + v \\cdot \\nabla u = 0,$$ where $v$ is a given fluid\nvelocity, and $u_0(x)=u(0,x)$ is a given initial condition.  The example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms\nin MFEM (face integrators), the use of explicit ODE time integrators, the\ndefinition of periodic boundary conditions through periodic meshes, as well as\nthe use of  GLVis  for persistent\nvisualization of a time-evolving solution. The saving of time-dependent data\nfiles for external visualization with  VisIt \nis also illustrated.  The example has a serial ( ex9.cpp )\nand a parallel ( ex9p.cpp ) version.\nIt also has a SUNDIALS modification in  examples/sundials \n, a PETSc modification in  examples/petsc ,\nand a HiOp modification in  examples/hiop .", 
            "title": "Example 9: DG Advection"
        }, 
        {
            "location": "/examples/#example-10-nonlinear-elasticity", 
            "text": "This example solves a time dependent nonlinear elasticity problem of the form\n$$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$\nwhere $H$ is a hyperelastic model and $S$ is a viscosity operator of\nLaplacian type. The geometry of the domain is assumed to be as follows:   The example demonstrates the use of nonlinear operators, as well as their\nimplicit time integration using a Newton method for solving an associated\nreduced backward-Euler type nonlinear equation. Each Newton step requires the\ninversion of a Jacobian matrix, which is done through a (preconditioned) inner\nsolver.  The example has a serial ( ex10.cpp )\nand a parallel ( ex10p.cpp ) version.\nIt also has a SUNDIALS modification in  examples/sundials \nand a PETSc modification in  examples/petsc .\nWe recommend viewing examples 2 and 9 before viewing this example.", 
            "title": "Example 10: Nonlinear Elasticity"
        }, 
        {
            "location": "/examples/#example-11-laplace-eigenproblem", 
            "text": "This example code demonstrates the use of MFEM to solve the eigenvalue problem\n$$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions.  We compute a number of the lowest eigenmodes by discretizing the Laplacian and\nMass operators using a finite element space of the specified order, or an\nisoparametric/isogeometric space if order   1 (quadratic for quadratic\ncurvilinear mesh, NURBS for NURBS mesh, etc.)  The example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU or\nSTRUMPACK parallel direct solvers. Reusing a single  GLVis \nvisualization window for multiple eigenfunctions is also illustrated.  The example has only a parallel\n( ex11p.cpp ) version.\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 11: Laplace Eigenproblem"
        }, 
        {
            "location": "/examples/#example-12-linear-elasticity-eigenproblem", 
            "text": "This example code solves the linear elasticity eigenvalue\nproblem for a multi-material cantilever beam.\nSpecifically, we compute a number of the lowest eigenmodes by approximating the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder.\nThe geometry of the domain is assumed to be as follows:   The example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE.\nReusing a single  GLVis  visualization window for multiple\neigenfunctions is also illustrated.  The example has only a parallel\n( ex12p.cpp ) version.\nWe recommend viewing examples 2 and 11 before viewing this example.", 
            "title": "Example 12: Linear Elasticity Eigenproblem"
        }, 
        {
            "location": "/examples/#example-13-maxwell-eigenproblem", 
            "text": "This example code solves the Maxwell (electromagnetic)\neigenvalue problem\n$$\\nabla\\times\\nabla\\times\\, E = \\lambda\\, E $$\nwith  homogeneous Dirichlet boundary conditions $E \\times n = 0$.  We compute a number of the lowest nonzero eigenmodes by\ndiscretizing the curl curl operator using a Nedelec finite element space of\nthe specified order in 2D or 3D.  The example highlights the use of the AME subspace eigenvalue\nsolver from HYPRE, which uses LOBPCG and AMS internally.\nReusing a single  GLVis  visualization window for multiple\neigenfunctions is also illustrated.  The example has only a parallel\n( ex13p.cpp ) version.\nWe recommend viewing examples 3 and 11 before viewing this example.", 
            "title": "Example 13: Maxwell Eigenproblem"
        }, 
        {
            "location": "/examples/#example-14-dg-diffusion", 
            "text": "This example code demonstrates the use of MFEM to define a\ndiscontinuous Galerkin (DG) finite element discretization of\nthe Laplace problem  $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Finite element spaces of any order,\nincluding zero on regular grids, are supported. The example highlights the use\nof discontinuous spaces and DG-specific face integrators.  The example has a serial ( ex14.cpp )\nand a parallel ( ex14p.cpp ) version.\nWe recommend viewing examples 1 and 9 before viewing this example.", 
            "title": "Example 14: DG Diffusion"
        }, 
        {
            "location": "/examples/#example-15-dynamic-amr", 
            "text": "Building on  Example 6 , this example demonstrates dynamic adaptive mesh refinement.\nThe mesh is adapted to a time-dependent solution by refinement\nas well as by derefinement. For simplicity, the solution is\nprescribed and no time integration is done. However, the error\nestimation and refinement/derefinement decisions are realistic.  At each outer iteration the right hand side function is changed\nto mimic a time dependent problem.  Within each inner iteration\nthe problem is solved on a sequence of meshes which are locally\nrefined according to a simple ZZ error estimator.  At the end\nof the inner iteration the error estimates are also used to\nidentify any elements which may be over-refined and a single\nderefinement step is performed.  After each refinement or\nderefinement step a rebalance operation is performed to keep\nthe mesh evenly distributed among the available processors.  The example demonstrates MFEM's capability to refine, derefine\nand load balance nonconforming meshes, in 2D and 3D, and on\nlinear, curved and surface meshes. Interpolation of functions\nbetween coarse and fine meshes, persistent  GLVis  visualization,\nand saving of time-dependent fields for external visualization\nwith  VisIt  are also illustrated.  The example has a serial ( ex15.cpp )\nand a parallel ( ex15p.cpp ) version.\nWe recommend viewing examples 1, 6 and 9 before viewing this example.", 
            "title": "Example 15: Dynamic AMR"
        }, 
        {
            "location": "/examples/#example-16-time-dependent-heat-conduction", 
            "text": "This example code solves a simple 2D/3D time dependent nonlinear heat conduction problem\n$$\\frac{du}{dt} = \\nabla \\cdot \\left( \\kappa + \\alpha u \\right) \\nabla u$$\nwith a natural insulating boundary condition $\\frac{du}{dn} = 0$.\nWe linearize the problem by using the temperature field $u$ from the previous time\nstep to compute the conductivity coefficient.  This example demonstrates both implicit and explicit time integration as well as a single\nPicard step method for linearization. The saving of time dependent data files for external\nvisualization with  VisIt  is also illustrated.  The example has a serial ( ex16.cpp )\nand a parallel ( ex16p.cpp ) version.\nWe recommend viewing examples 2, 9, and 10 before viewing this example.", 
            "title": "Example 16: Time Dependent Heat Conduction"
        }, 
        {
            "location": "/examples/#example-17-dg-linear-elasticity", 
            "text": "This example code solves a simple linear elasticity problem\ndescribing a multi-material cantilever beam using symmetric or\nnon-symmetric discontinuous Galerkin (DG) formulation.  Specifically, we approximate the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = 0$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\nDirichlet, $\\bf{u}=\\bf{u_D}$, on the fixed part of the boundary, namely\nboundary attributes 1 and 2; on the rest of the boundary we use\n${\\sigma}({\\bf u})\\cdot n = {\\bf 0}$. The geometry of the domain is assumed to be\nas follows:   The example demonstrates the use of high-order DG vector finite\nelement spaces with the linear DG elasticity bilinear form,\nmeshes with curved elements, and the definition of piece-wise\nconstant and function vector-coefficient objects. The use of\nnon-homogeneous Dirichlet b.c. imposed weakly, is also\nillustrated.  The example has a serial ( ex17.cpp )\nand a parallel ( ex17p.cpp ) version.\nWe recommend viewing examples 2 and 14 before viewing this example.", 
            "title": "Example 17: DG Linear Elasticity"
        }, 
        {
            "location": "/examples/#example-18-dg-euler-equations", 
            "text": "This example code solves the compressible Euler system of equations, a model\nnonlinear hyperbolic PDE, with a discontinuous Galerkin (DG) formulation. The\nprimary purpose is to show how a transient system of nonlinear equations can be\nformulated in MFEM. The equations are solved in conservative form  $$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot {\\bf F}(u) = 0$$  with a state vector $u = [ \\rho, \\rho v_0, \\rho v_1, \\rho E ]$, where $\\rho$ is\nthe density, $v_i$ is the velocity in the $i^{\\rm th}$ direction, $E$ is the\ntotal specific energy, and $H = E + p / \\rho$ is the total specific enthalpy.\nThe pressure, $p$ is computed through a simple equation of state (EOS) call.\nThe conservative hydrodynamic flux ${\\bf F}$ in each direction $i$ is  $${\\bf F_{\\it i}} = [ \\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_i + p \\delta_{i,1}, \\rho v_i H ]$$  Specifically, the example solves for an exact solution of the equations whereby\na vortex is transported by a uniform flow. Since all boundaries are periodic\nhere, the method's accuracy can be assessed by measuring the difference between\nthe solution and the initial condition at a later time when the vortex returns\nto its initial location.  Note that as the order of the spatial discretization increases, the timestep\nmust become smaller. This example currently uses a simple estimate derived by Cockburn and Shu \nfor the 1D RKDG method. An additional factor can be tuned by passing the  --cfl \n(or  -c  shorter) flag.  The example demonstrates user-defined bilinear and nonlinear form integrators\nfor systems of equations that are defined with block vectors, and how these are\nused with an operator for explicit time integrators. In this case the system\nalso involves an external approximate Riemann solver for the DG interface flux.\nIt also demonstrates how to use GLVis for in-situ visualization of vector grid\nfunctions.  The example has a serial ( ex18.cpp )\nand a parallel ( ex18p.cpp ) version.\nWe recommend viewing examples 9, 14 and 17 before viewing this example.", 
            "title": "Example 18: DG Euler Equations"
        }, 
        {
            "location": "/examples/#example-19-incompressible-nonlinear-elasticity", 
            "text": "This example code solves the quasi-static incompressible nonlinear\nhyperelasticity equations. Specifically, it solves the nonlinear equation\n$$\n\\nabla \\cdot \\sigma(F) = 0\n$$\nsubject to the constraint\n$$\n\\text{det } F = 1\n$$\nwhere $\\sigma$ is the Cauchy stress and $F_{ij} = \\delta_{ij} + u_{i,j}$ is the deformation\ngradient. To handle the incompressibility constraint, pressure is included as\nan independent unknown $p$ and the stress response is modeled as an  incompressible\nneo-Hookean hyperelastic solid .\nThe geometry of the domain is assumed to be as follows:   This formulation requires solving the saddle point system\n$$ \\left[ \\begin{array}{cc}\n   K  B^T \\\\\n   B   0\n\\end{array} \\right]\n\\left[\\begin{array}{c} \\Delta u \\\\ \\Delta p \\end{array} \\right] =\n\\left[\\begin{array}{c} R_u \\\\ R_p \\end{array} \\right]\n$$\nat each Newton step. To solve this linear system, we implement a specialized block\npreconditioner of the form\n$$\nP^{-1} =\n\\left[\\begin{array}{cc} I   -\\tilde{K}^{-1}B^T \\\\ 0   I \\end{array} \\right]\n\\left[\\begin{array}{cc} \\tilde{K}^{-1}   0 \\\\ 0   -\\gamma \\tilde{S}^{-1} \\end{array} \\right]\n$$\nwhere $\\tilde{K}^{-1}$ is an approximation of the inverse of the stiffness matrix $K$ and\n$\\tilde{S}^{-1}$ is an approximation of the inverse of the Schur complement $S = BK^{-1}B^T$.\nTo approximate the Schur complement, we use the mass matrix for the pressure variable $p$.  The example demonstrates how to solve nonlinear systems of equations that are defined with\nblock vectors as well as how to implement specialized block preconditioners for use in\niterative solvers.  The example has a serial ( ex19.cpp )\nand a parallel ( ex19p.cpp ) version.\nWe recommend viewing examples 2, 5 and 10 before viewing this example.", 
            "title": "Example 19: Incompressible Nonlinear Elasticity"
        }, 
        {
            "location": "/examples/#example-20-symplectic-integration-of-hamiltonian-systems", 
            "text": "This example demonstrates the use of the variable order, symplectic time\nintegration algorithm. Symplectic integration algorithms are designed to\nconserve energy when integrating systems of ODEs which are derived from\nHamiltonian systems.  Hamiltonian systems define the energy of a system as a function of\ntime (t), a set of generalized coordinates (q), and their corresponding\ngeneralized momenta (p).\n$$\nH(q,p,t) = T(p) + V(q,t)\n$$\nHamilton's equations then specify how q and p evolve in time:\n$$\n\\frac{dq}{dt} =  \\frac{dH}{dp}\\,,\\qquad\n\\frac{dp}{dt} = -\\frac{dH}{dq}\n$$  To use the symplectic integration classes we need to define an  mfem::Operator \n${\\bf P}$ which evaluates the action of dH/dp, and an mfem::TimeDependentOperator  ${\\bf F}$ which computes -dH/dq.  This example visualizes its results as an evolution in phase space by defining\nthe axes to be $q$, $p$, and $t$ rather than $x$, $y$, and $z$.  In this space\nwe build a ribbon-like mesh with nodes at $(0,0,t)$ and $(q,p,t)$. Finally we\nplot the energy as a function of time as a scalar field on this ribbon-like\nmesh.  This scheme highlights any variations in the energy of the system.  This example offers five simple 1D Hamiltonians:   Simple Harmonic Oscillator (mass on a spring)\n  $$H = \\frac{1}{2}\\left( \\frac{p^2}{m} + \\frac{q^2}{k} \\right)$$  Pendulum\n  $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} - k \\left( 1 - cos(q) \\right) \\right]$$  Gaussian Potential Well\n  $$H = \\frac{p^2}{2m} - k e^{-q^2 / 2}$$  Quartic Potential\n  $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 + q^2 \\right) q^2 \\right]$$  Negative Quartic Potential\n  $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 - \\frac{q^2}{8} \\right) q^2 \\right]$$   In all cases these Hamiltonians are shifted by constant values so that the\nenergy will remain positive. The mean and standard deviation of the computed\nenergies at each time step are displayed upon completion.  When run in parallel, each processor integrates the same Hamiltonian\nsystem but starting from different initial conditions.  The example has a serial ( ex20.cpp )\nand a parallel ( ex20p.cpp ) version.\nSee the  Maxwell  miniapp for another\napplication of symplectic integration.", 
            "title": "Example 20: Symplectic Integration of Hamiltonian Systems"
        }, 
        {
            "location": "/examples/#example-21-adaptive-mesh-refinement-for-linear-elasticity", 
            "text": "This is a version of Example 2 with a simple adaptive mesh\nrefinement loop. The problem being solved is again linear\nelasticity describing a multi-material cantilever beam.\nThe problem is solved on a sequence of meshes which\nare locally refined in a conforming (triangles, tetrahedrons)\nor non-conforming (quadrilaterals, hexahedra) manner according\nto a simple ZZ error estimator.  The example demonstrates MFEM's capability to work with both\nconforming and nonconforming refinements, in 2D and 3D, on\nlinear and curved meshes. Interpolation of functions from\ncoarse to fine meshes, as well as persistent GLVis\nvisualization are also illustrated.  The example has a serial ( ex21.cpp )\nand a parallel ( ex21p.cpp ) version.\nWe recommend viewing Examples 2 and 6 before viewing this example.", 
            "title": "Example 21: Adaptive mesh refinement for linear elasticity"
        }, 
        {
            "location": "/examples/#example-22-complex-linear-systems", 
            "text": "This example code demonstrates the use of MFEM to define and\nsolve a complex-valued linear system. It implements three variants\nof a damped harmonic oscillator:    A scalar $H^1$ field:\n  $$-\\nabla\\cdot\\left(a \\nabla u\\right) - \\omega^2 b\\,u + i\\,\\omega\\,c\\,u = 0$$    A vector $H(Curl)$ field:\n  $$\\nabla\\times\\left(a\\nabla\\times\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$    A vector $H(Div)$ field:\n  $$-\\nabla\\left(a \\nabla\\cdot\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$    In each case the field is driven by a forced oscillation, with\nangular frequency $\\omega$, imposed at the boundary or a portion\nof the boundary.  The example also demonstrates how to display a time-varying solution as\na sequence of fields sent to a single GLVis socket.  The example has a serial ( ex22.cpp )\nand a parallel ( ex22p.cpp ) version.\nWe recommend viewing examples 1, 3, and 4 before viewing this example.", 
            "title": "Example 22: Complex Linear Systems"
        }, 
        {
            "location": "/examples/#volta-miniapp-electrostatics", 
            "text": "This miniapp demonstrates the use of MFEM to solve realistic problems\nin the field of linear electrostatics.  Its features include:   dielectric materials  charge densities  surface charge densities  prescribed voltages  applied polarizations  high order meshes  high order basis functions  adaptive mesh refinement  advanced visualization   For more details, please see the  documentation  in the miniapps/electromagnetics  directory.  The miniapp has only a parallel\n( volta.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Volta Miniapp: Electrostatics"
        }, 
        {
            "location": "/examples/#tesla-miniapp-magnetostatics", 
            "text": "This miniapp showcases many of MFEM's features while solving a variety\nof realistic magnetostatics problems.  Its features include:   diamagnetic and/or paramagnetic materials  ferromagnetic materials  volumetric current densities  surface current densities  external fields  high order meshes  high order basis functions  adaptive mesh refinement  advanced visualization   For more details, please see the  documentation  in the miniapps/electromagnetics  directory.  The miniapp has only a parallel\n( tesla.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Tesla Miniapp: Magnetostatics"
        }, 
        {
            "location": "/examples/#maxwell-miniapp-transient-full-wave-electromagnetics", 
            "text": "This miniapp solves the equations of transient full-wave electromagnetics.  Its features include:   mixed formulation of the coupled first-order Maxwell equations  $H(\\mathrm{curl})$ discretization of the electric field  $H(\\mathrm{div})$ discretization of the magnetic flux  energy conserving, variable order, implicit time integration  dielectric materials  diamagnetic and/or paramagnetic materials  conductive materials  volumetric current densities  Sommerfeld absorbing boundary conditions  high order meshes  high order basis functions  advanced visualization   For more details, please see the  documentation  in the miniapps/electromagnetics  directory.  The miniapp has only a parallel\n( maxwell.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Maxwell Miniapp: Transient Full-Wave Electromagnetics"
        }, 
        {
            "location": "/examples/#joule-miniapp-transient-magnetics-and-joule-heating", 
            "text": "This miniapp solves the equations of transient low-frequency (a.k.a. eddy current)\nelectromagnetics, and simultaneously computes transient heat transfer with the heat source given\nby the electromagnetic Joule heating.  Its features include:   $H^1$ discretization of the electrostatic potential  $H(\\mathrm{curl})$ discretization of the electric field  $H(\\mathrm{div})$ discretization of the magnetic field  $H(\\mathrm{div})$ discretization of the heat flux  $L^2$ discretization of the temperature  implicit transient time integration  high order meshes  high order basis functions  adaptive mesh refinement  advanced visualization   For more details, please see the  documentation  in the miniapps/electromagnetics  directory.  The miniapp has only a parallel\n( joule.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Joule Miniapp: Transient Magnetics and Joule Heating"
        }, 
        {
            "location": "/examples/#mobius-strip-miniapp", 
            "text": "This miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.  Manipulating the mesh topology and performing mesh transformation are demonstrated.  The  mobius-strip  mesh in the  data  directory was generated with this miniapp.  For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has only a serial\n( mobius-strip.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Mobius Strip Miniapp"
        }, 
        {
            "location": "/examples/#klein-bottle-miniapp", 
            "text": "This miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.  Manipulating the mesh topology and performing mesh transformation are demonstrated.  The  klein-bottle  and  klein-donut  meshes in the  data  directory were generated with this miniapp.  For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has only a serial\n( klein-bottle.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Klein Bottle Miniapp"
        }, 
        {
            "location": "/examples/#toroid-miniapp", 
            "text": "This miniapp generates two types of toroidal volume meshes; one with\ntriangular cross sections and one with square cross sections.  It\nworks by defining a stack of individual elements and bending them so\nthat the bottom and top of the stack can be joined to form a torus. It\nsupports various options including:   The element type: 0 - Wedge, 1 - Hexahedron  The geometric order of the elements  The major and minor radii  The number of elements in the azimuthal direction  The number of nodes to offset by before rejoining the stack  The initial angle of the cross sectional shape  The number of uniform refinement steps to apply   Along with producing some visually interesting meshes, this miniapp\ndemonstrates how simple 3D meshes can be constructed and transformed\nin MFEM.  It also produces a family of meshes with simple but\nnon-trivial topology for testing various features in MFEM.  This miniapp has only a serial\n( toroid.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Toroid Miniapp"
        }, 
        {
            "location": "/examples/#extruder-miniapp", 
            "text": "This miniapp creates higher dimensional meshes from lower dimensional meshes\nby extrusion.  Simple coordinate transformations can also be applied if desired.   The initial mesh can be 1D or 2D  1D meshes can be extruded in both the y and z directions  2D meshes can be triangular, quadrilateral, or contain both element types  Meshes with high order geometry are supported  User can specify the number of elements and the distance to extrude  Geometric order of the transformed mesh can be user selected or automatic   This miniapp provides another demonstration of how simple meshes can be\nconstructed and transformed in MFEM.  This miniapp has only a serial\n( extruder.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Extruder Miniapp"
        }, 
        {
            "location": "/examples/#shaper-miniapp", 
            "text": "This miniapp performs multiple levels of adaptive mesh refinement to resolve the\ninterfaces between different \"materials\" in the mesh, as specified by a given\nmaterial function.  It can be used as a simple initial mesh generator, for example in the case when\nthe interface is too complex to describe without local refinement. Both\nconforming and non-conforming refinements are supported.  For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has only a serial\n( shaper.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Shaper Miniapp"
        }, 
        {
            "location": "/examples/#mesh-explorer-miniapp", 
            "text": "This miniapp is a handy tool to examine, visualize and manipulate a given\nmesh. Some of its features are:   visualizing of mesh materials and individual mesh elements  mesh scaling, randomization, and general transformation  manipulation of the mesh curvature  the ability to simulate parallel partitioning  quantitative and visual reports of mesh quality   For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has only a serial\n( mesh-explorer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.", 
            "title": "Mesh Explorer Miniapp"
        }, 
        {
            "location": "/examples/#mesh-optimizer-miniapp", 
            "text": "This miniapp performs mesh optimization using the Target-Matrix Optimization\nParadigm (TMOP) by P.Knupp et al., and a global variational minimization\napproach. It minimizes the quantity  $$\\sum_T \\int_T \\mu(J(x)),$$  where $T$ are the target (ideal) elements, $J$ is the Jacobian of the\ntransformation from the target to the physical element, and $\\mu$ is the mesh\nquality metric.  This metric can measure shape, size or alignment of the region around each\nquadrature point. The combination of targets and quality metrics is used to\noptimize the physical node positions, i.e., they must be as close as possible to\nthe shape / size / alignment of their targets.  This code also demonstrates a possible use of nonlinear operators, as well as\ntheir coupling to Newton methods for solving minimization problems. Note that\nthe utilized Newton methods are oriented towards avoiding invalid meshes with\nnegative Jacobian determinants. Each Newton step requires the inversion of a\nJacobian matrix, which is done through an inner linear solver.  For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has a serial\n( mesh-optimizer.cpp ) and a\nparallel ( pmesh-optimizer.cpp )\nversion. We recommend that new users start with the example codes before moving to the miniapps.", 
            "title": "Mesh Optimizer Miniapp"
        }, 
        {
            "location": "/examples/#low-order-refined-transfer-miniapp", 
            "text": "The  lor-transfer  miniapp, found under  miniapps/tools  demonstrates the\ncapability to generate a  low-order refined  mesh from a high-order mesh, and to\ntransfer solutions between these meshes.  Grid functions can be transferred between the coarse, high-order mesh and the\nlow-order refined mesh using either $L^2$ projection or pointwise evaluation.\nThese transfer operators can be designed to discretely conserve mass and to\nrecover the original high-order solution when transferring a low-order grid\nfunction that was obtained by restricting a high-order grid function to the\nlow-order refined space.  The miniapp has only a serial\n( lor-transfer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.", 
            "title": "Low-Order Refined Transfer Miniapp"
        }, 
        {
            "location": "/examples/#laghos-miniapp", 
            "text": "Laghos  (LAGrangian High-Order Solver) is a miniapp that solves the\ntime-dependent Euler equations of compressible gas dynamics in a moving\nLagrangian frame using unstructured high-order finite element spatial\ndiscretization and explicit high-order time-stepping.  The computational motives captured in Laghos include:   Support for unstructured meshes, in 2D and 3D, with quadrilateral and\n  hexahedral elements (triangular and tetrahedral elements can also be used, but\n  with the less efficient full assembly option). Serial and parallel mesh\n  refinement options can be set via a command-line flag.  Explicit time-stepping loop with a variety of time integrator options. Laghos\n  supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6.  Continuous and discontinuous high-order finite element discretization spaces\n  of runtime-specified order.  Moving (high-order) meshes.  Separation between the assembly and the quadrature point-based computations.  Point-wise definition of mesh size, time-step estimate and artificial\n  viscosity coefficient.  Constant-in-time velocity mass operator that is inverted iteratively on\n  each time step. This is an example of an operator that is prepared once (fully\n  or partially assembled), but is applied many times. The application cost is\n  dominant for this operator.  Time-dependent force matrix that is prepared every time step (fully or\n  partially assembled) and is applied just twice per \"assembly\". Both the\n  preparation and the application costs are important for this operator.  Domain-decomposed MPI parallelism.  Optional in-situ visualization with  GLVis  and data output\n  for visualization / data analysis with  VisIt .   The Laghos miniapp is part of the  CEED software suite ,\na collection of software benchmarks, miniapps, libraries and APIs for\nefficient exascale discretizations based on high-order finite element\nand spectral element methods. See http://github.com/ceed for more\ninformation and source code availability.  This is an external miniapp, available at  https://github.com/CEED/Laghos .        \nNo examples or miniapps match your criteria.      <!--\nfunction isChecked(id)\n{\n    return document.getElementById(id).checked;\n}\n\nfunction setChecked(id, value)\n{\n    document.getElementById(id).checked = value;\n}\n\nfunction showElement(id, show)\n{\n    //document.getElementById(id).style.display = show ? \"block\" : \"none\";\n\n    // workaround because Doxygen splits and duplicates the divs for some reason\n    var divs = document.getElementsByTagName(\"div\");\n    for (i = 0; i < divs.length; i++)\n        if (divs.item(i).id == id)\n            divs.item(i).style.display = show ? \"block\" : \"none\";\n}\n\nfunction updateGroup(names, id)\n{\n   // make only one box checked in the group\n   if (names.indexOf(id) != -1)\n      for (i = 0; i < names.length; ++i)\n         setChecked(names[i], id == names[i]);\n\n   // generate boolean variables from the group names\n   for (i = 0; i < names.length; ++i)\n      this[names[i]] = isChecked(names[i]) || isChecked(names[0]);\n}\n\nfunction elementVisible(id)\n{\n   var elem = document.getElementById(id);\n   return elem != null && elem.style.display != \"none\";\n}\n\nfunction exampleVisible(num)\n{\n   return elementVisible(\"ex\"+num);// || elementVisible(\"ex\"+num+\"p\");\n}\n\nfunction update(id)\n{\n   var group1 = [\"all1\", \"laplace\", \"elasticity\", \"maxwell\", \"graddiv\", \"darcy\", \"advection\", \"conduction\", \"hydro\", \"meshing\", \"hpc\"];\n   var group2 = [\"all2\", \"l2\", \"h1\", \"hcurl\", \"hdiv\", \"h12\"];\n   var group3 = [\"all3\", \"galerkin\", \"mixed\", \"dg\", \"dpg\", \"hybr\", \"staticcond\", \"nurbs\", \"amr\" ];\n   var group4 = [\"all4\", \"jacobi\", \"gs\", \"pcg\", \"minres\", \"gmres\", \"amg\", \"ams\", \"ads\", \"superlu\", \"umfpack\", \"newton\", \"rk\", \"sdirk\", \"symplectic\", \"lobpcg\", \"sundials\", \"petsc\", \"hiop\"];\n\n   updateGroup(group1, id);\n   updateGroup(group2, id);\n   updateGroup(group3, id);\n   updateGroup(group4, id);\n\n   // Example codes\n   var numExamples = 22; // update when adding examples!\n   showElement(\"ex1\",  (laplace  || hpc) && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex2\",  elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex3\",  maxwell && hcurl && (galerkin || staticcond) && (gs || pcg || umfpack || ams || petsc));\n   showElement(\"ex4\",  graddiv && (hdiv || h12) && (galerkin || hybr || staticcond) && (gs || pcg || umfpack || amg || ads || ams || petsc));\n   showElement(\"ex5\",  darcy && (l2 || hdiv) && mixed && (gs || jacobi || minres || umfpack || amg  || petsc));\n   showElement(\"ex6\",  laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex7\",  (laplace || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex8\",  laplace && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams));\n   showElement(\"ex9\",  advection && l2 && dg && (pcg || rk || sundials || petsc || hiop));\n   showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc));\n   showElement(\"ex11\", laplace && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu));\n   showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg));\n   showElement(\"ex13\", maxwell && hcurl && galerkin && (lobpcg || ams));\n   showElement(\"ex14\", laplace && l2 && dg && (gs || pcg || gmres || umfpack || amg));\n   showElement(\"ex15\", laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex16\", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk || sundials));\n   showElement(\"ex17\", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg));\n   showElement(\"ex18\", hydro && l2 && dg && (rk));\n   showElement(\"ex19\", elasticity && h1 && mixed && (gs || gmres || newton || amg));\n   showElement(\"ex20\", (elasticity || maxwell || conduction || hydro) && symplectic);\n   showElement(\"ex21\", elasticity && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex22\", (laplace || maxwell || graddiv) && (h1 || hcurl || hdiv) && galerkin && (gmres || amg || ams || ads));\n\n   // Electromagnetic miniapps\n   numExamples += 4; // update when adding miniapps!\n   showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg));\n   showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams));\n   showElement(\"maxwell\", (maxwell || conduction) && (hdiv || hcurl) && (galerkin || staticcond || mixed) && (pcg || symplectic));\n   showElement(\"joule\", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk));\n\n   // Meshing miniapps\n   numExamples += 8; // update when adding miniapps!\n   showElement(\"mobius-strip\", meshing && all2 && all3 && all4);\n   showElement(\"klein-bottle\", meshing && all2 && all3 && all4);\n   showElement(\"toroid\", meshing && all2 && all3 && all4);\n   showElement(\"extruder\", meshing && all2 && all3 && all4);\n   showElement(\"shaper\", meshing && all2 && all3 && all4);\n   showElement(\"mesh-explorer\", meshing && all2 && all3 && all4);\n   showElement(\"mesh-optimizer\", meshing && all2 && all3 && all4);\n   showElement(\"lor-transfer\", meshing && (l2 || h1) && all3 && all4);\n\n   // External miniapps\n   numExamples += 1; // update when adding miniapps!\n   showElement(\"laghos\", (hydro || hpc) && all2 && all3 && all4);\n\n   var allHidden = true;\n   for (i = 1; i <= numExamples; i++) {  // FIXME this no longer works with the miniapps!\n      if (exampleVisible(i)) {\n         allHidden = false;\n         break;\n      }\n   }\n   showElement(\"nomatch\", allHidden);\n}\n\nfunction initButtons()\n{\n   var query = location.search.substr(1);\n   query.split(\"&\").forEach(function(id)\n   {\n      setChecked(id, true);\n      update(id);\n   });\n}\n\n// make sure \"no match\" div is not visible after page is loaded\nwindow.onload = update;\n\n// force vertical scrollbar\ndocument.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\"\n\n// parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs\ninitButtons();\n\n//-->", 
            "title": "Laghos Miniapp"
        }, 
        {
            "location": "/news/", 
            "text": "All News Updates\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMay 24, 2019\n\n\nVersion 4.0 \nreleased\n with initial GPU support.\n\n\n\n\n\n\nMar 30, 2019\n\n\nCEED v2.0 and libCEED v0.4 \nreleased\n with MFEM support.\n\n\n\n\n\n\nMar 22, 2019\n\n\nA version of the Laghos miniapp \nreleased\n for use in the second edition of the \nCommodity Technology Systems\n procurement process.\n\n\n\n\n\n\nMay 10, 2019\n\n\nAMR\n and \nTMOP\n papers available on arXiv.\n\n\n\n\n\n\nNov 19, 2018\n\n\nLaghos v2.0 \nreleased\n with CUDA, RAJA, OCCA and AMR versions.\n\n\n\n\n\n\nNov 9, 2018\n\n\nMFEM part of the first release of the \nExtreme-Scale Scientific Software Stack\n (E4S) by the Software Technologies focus area of the ECP.\n\n\n\n\n\n\nAug 6, 2018\n\n\nUnstructured technologies \npresentation\n at \nATPESC18\n.\n\n\n\n\n\n\nMay 29, 2018\n\n\nVersion 3.4 \nreleased\n.\n\n\n\n\n\n\nApr 2, 2018\n\n\nMFEM part of \nOpenHPC\n, a Linux Foundation project for software components required to deploy and manage HPC Linux clusters.\n\n\n\n\n\n\nMar 30, 2018\n\n\nCEED v1.0 and libCEED v0.2 \nreleased\n with MFEM support.\n\n\n\n\n\n\nMar 1, 2018\n\n\nMFEM highlighted in LLNL's \nScience \n Technology Review\n magazine, including on the \ncover\n.\n\n\n\n\n\n\nDec 30, 2017\n\n\nInitial version of \nlibCEED\n, the low-level CEED API, released.\n\n\n\n\n\n\nNov 10, 2017\n\n\nVersion 3.3.2 \nreleased\n.\n\n\n\n\n\n\nNov 7, 2017\n\n\nECP article: \nCo-Design Center Develops Next-Generation Simulation Tools\n, also in \nHPCwire\n.\n\n\n\n\n\n\nOct 30, 2017\n\n\nLaghos part of the \nECP Proxy App Suite 1.0\n, \nCORAL-2 Benchmarks\n and \nASC co-design miniapps\n.\n\n\n\n\n\n\nOct 16, 2017\n\n\nPostdoc position \navailable\n for electromagnetic simulations with MFEM.\n\n\n\n\n\n\nSep 22, 2017\n\n\nLLNL Newsline: \nLLNL gears up for next generation of computer-aided design and engineering\n.\n\n\n\n\n\n\nJun 15, 2017\n\n\nLaghos\n miniapp and \nCEED benchmarks\n released.\n\n\n\n\n\n\nMay 8, 2017\n\n\nNews highlight: \nAccelerating Simulation Software with Graphics Processing Units\n.\n\n\n\n\n\n\nFeb 16, 2017\n\n\nMoved main development to GitHub.\n\n\n\n\n\n\nJan 28, 2017\n\n\nVersion 3.3 \nreleased\n.\n\n\n\n\n\n\nDec 15, 2016\n\n\nPostdoc position\n for \nexascale computing\n with MFEM.\n\n\n\n\n\n\nNov 11, 2016\n\n\nMFEM part of the new \nECP\n co-design \nCenter for Efficient Exascale Discretizations (CEED)\n.\n\n\n\n\n\n\nNov 11, 2016\n\n\nLLNL Newsline: \nLawrence Livermore tapped to lead \u2018co-design\u2019 center for exascale computing ecosystem\n.\n\n\n\n\n\n\nOct 6, 2016\n\n\nScience \n Technology Review\n article: \nLaying the Groundwork for Extreme-Scale Computing\n, see also the \nYouTube preview\n.\n\n\n\n\n\n\nSep 19, 2016\n\n\nPyMFEM\n - a Python wrapper for MFEM by \nSyun'ichi Shiraiwa\n from MIT's Plasma Science and Fusion Center released.\n\n\n\n\n\n\nJun 30, 2016\n\n\nVersion 3.2 \nreleased\n.\n\n\n\n\n\n\nMay 6, 2016\n\n\nMFEM packages available in \nhomebrew\n and \nspack\n.\n\n\n\n\n\n\nMar 9, 2016\n\n\nVisIt 2.10.1 \nreleased\n with MFEM 3.1 support.\n\n\n\n\n\n\nMar 4, 2016\n\n\nNew LLNL open-source software \nBlog\n and \nTwitter\n.\n\n\n\n\n\n\nFeb 16, 2016\n\n\nVersion 3.1 \nreleased\n.\n\n\n\n\n\n\nFeb 5, 2016\n\n\nMFEM simulation images part of the \nArt of Science\n exhibition at the Livermore public library.\n\n\n\n\n\n\nJan 6, 2016\n\n\nNews highlight: \nHigh-order finite element library provides scientists with access to cutting-edge algorithms\n.\n\n\n\n\n\n\nAug 18, 2015\n\n\nMoved to \nGitHub\n and \nmfem.org\n.\n\n\n\n\n\n\nJan 26, 2015\n\n\nVersion 3.0 \nreleased\n.", 
            "title": "_News"
        }, 
        {
            "location": "/news/#all-news-updates", 
            "text": "May 24, 2019  Version 4.0  released  with initial GPU support.    Mar 30, 2019  CEED v2.0 and libCEED v0.4  released  with MFEM support.    Mar 22, 2019  A version of the Laghos miniapp  released  for use in the second edition of the  Commodity Technology Systems  procurement process.    May 10, 2019  AMR  and  TMOP  papers available on arXiv.    Nov 19, 2018  Laghos v2.0  released  with CUDA, RAJA, OCCA and AMR versions.    Nov 9, 2018  MFEM part of the first release of the  Extreme-Scale Scientific Software Stack  (E4S) by the Software Technologies focus area of the ECP.    Aug 6, 2018  Unstructured technologies  presentation  at  ATPESC18 .    May 29, 2018  Version 3.4  released .    Apr 2, 2018  MFEM part of  OpenHPC , a Linux Foundation project for software components required to deploy and manage HPC Linux clusters.    Mar 30, 2018  CEED v1.0 and libCEED v0.2  released  with MFEM support.    Mar 1, 2018  MFEM highlighted in LLNL's  Science   Technology Review  magazine, including on the  cover .    Dec 30, 2017  Initial version of  libCEED , the low-level CEED API, released.    Nov 10, 2017  Version 3.3.2  released .    Nov 7, 2017  ECP article:  Co-Design Center Develops Next-Generation Simulation Tools , also in  HPCwire .    Oct 30, 2017  Laghos part of the  ECP Proxy App Suite 1.0 ,  CORAL-2 Benchmarks  and  ASC co-design miniapps .    Oct 16, 2017  Postdoc position  available  for electromagnetic simulations with MFEM.    Sep 22, 2017  LLNL Newsline:  LLNL gears up for next generation of computer-aided design and engineering .    Jun 15, 2017  Laghos  miniapp and  CEED benchmarks  released.    May 8, 2017  News highlight:  Accelerating Simulation Software with Graphics Processing Units .    Feb 16, 2017  Moved main development to GitHub.    Jan 28, 2017  Version 3.3  released .    Dec 15, 2016  Postdoc position  for  exascale computing  with MFEM.    Nov 11, 2016  MFEM part of the new  ECP  co-design  Center for Efficient Exascale Discretizations (CEED) .    Nov 11, 2016  LLNL Newsline:  Lawrence Livermore tapped to lead \u2018co-design\u2019 center for exascale computing ecosystem .    Oct 6, 2016  Science   Technology Review  article:  Laying the Groundwork for Extreme-Scale Computing , see also the  YouTube preview .    Sep 19, 2016  PyMFEM  - a Python wrapper for MFEM by  Syun'ichi Shiraiwa  from MIT's Plasma Science and Fusion Center released.    Jun 30, 2016  Version 3.2  released .    May 6, 2016  MFEM packages available in  homebrew  and  spack .    Mar 9, 2016  VisIt 2.10.1  released  with MFEM 3.1 support.    Mar 4, 2016  New LLNL open-source software  Blog  and  Twitter .    Feb 16, 2016  Version 3.1  released .    Feb 5, 2016  MFEM simulation images part of the  Art of Science  exhibition at the Livermore public library.    Jan 6, 2016  News highlight:  High-order finite element library provides scientists with access to cutting-edge algorithms .    Aug 18, 2015  Moved to  GitHub  and  mfem.org .    Jan 26, 2015  Version 3.0  released .", 
            "title": "All News Updates"
        }, 
        {
            "location": "/building/", 
            "text": "Building MFEM\n\n\nA simple tutorial how to build and run the serial and parallel version of MFEM\ntogether with GLVis. For more details, see the\n\nINSTALL\n file and\n\nmake help\n.\n\n\nIn addition to the native build system described below, MFEM packages are\nalso available in the following package managers:\n\n\n\n\nSpack\n\n\nOpenHPC\n\n\nHomebrew/Science\n (deprecated)\n\n\n\n\nMFEM can also be installed as part of\n\n\n\n\nCEED\n\n\nxSDK\n\n\nE4S\n\n\nFASTMath\n\n\nRADIUSS\n\n\n\n\nInstructions\n\n\nDownload MFEM and GLVis\n\n\n\n\nhttp://mfem.org\n\n\nhttp://glvis.org\n\n\n\n\nBelow we assume that we are working with versions 3.4.\n\n\nSerial version of MFEM and GLVis\n\n\nPut everything in the same directory:\n\n\n~\n ls\nglvis-3.4.tgz   mfem-3.4.tgz\n\n\n\n\nBuild the serial version of MFEM:\n\n\n~\n tar -zxvf mfem-3.4.tgz\n~\n cd mfem-3.4\n~/mfem-3.4\n make serial -j\n\n\n\n\nBuild GLVis:\n\n\n~\n tar -zxvf glvis-3.4.tgz\n~\n cd glvis-3.4\n~/glvis-3.4\n make MFEM_DIR=../mfem-3.4 -j\n\n\n\n\nThat's it! The MFEM library can be found in \nmfem-3.4/libmfem.a\n, while the\n\nglvis\n executable will be in the \nglvis-3.4\n directory.\n\n\nTo start a GLVis server, open a \nnew terminal\n and type\n\n\n~\n cd glvis-3.4\n~/glvis-3.4\n ./glvis\n\n\n\n\nThe serial examples can be build with:\n\n\n~\n cd mfem-3.4/examples\n~/mfem-3.4/examples\n make -j\n\n\n\n\nAll serial examples and miniapps can be build with:\n\n\n~\n cd mfem-3.4\n~/mfem-3.4\n make all -j\n\n\n\n\nParallel MPI version of MFEM\n\n\nDownload \nhypre\n and metis from\n\n\n\n\nhttps://github.com/hypre-space/hypre/releases\n\n\nhttps://computation.llnl.gov/casc/hypre/software.html\n\n\nhttp://glaros.dtc.umn.edu/gkhome/metis/metis/download\n\n\n\n\nBelow we assume that we are working with versions 2.16.0 and\n\n4.0.3\n\nrespectively. We also assume that the serial version of MFEM and GLVis have been\nbuilt as described above.\n\n\nPut everything in the same directory:\n\n\n~\n ls\nglvis-3.4/  hypre-2.16.0.tar.gz   metis-4.0.3.tar.gz   mfem-3.4/\n\n\n\n\nBuild hypre:\n\n\n~\n tar -zxvf hypre-2.16.0.tar.gz\n~\n cd hypre-2.16.0/src/\n~/hypre-2.16.0/src\n ./configure --disable-fortran\n~/hypre-2.16.0/src\n make -j\n~/hypre-2.16.0/src\n cd ../..\n~\n ln -s hypre-2.16.0 hypre\n\n\n\n\nBuild metis:\n\n\n~\n tar -zxvf metis-4.0.3.tar.gz\n~\n cd metis-4.0.3\n~/metis-4.0.3\n make\n~/metis-4.0.3\n cd ..\n~\n ln -s metis-4.0.3 metis-4.0\n\n\n\n\n(If you are using METIS 5, see the instructions\n\nbelow\n.)\n\n\nBuild the parallel version of MFEM:\n\n\n~\n cd mfem-3.4\n~/mfem-3.4\n make parallel -j\n\n\n\n\nNote that if hypre or metis are in different locations, or you have different\nversions of these libraries, you will need to update the corresponding paths in\nthe\n\nconfig/defaults.mk\n\nfile, or create you own \nconfig/user.mk\n, as described in the\n\nINSTALL\n file.\n\n\nThe parallel examples can be build with:\n\n\n~\n cd mfem-3.4/examples\n~/mfem-3.4/examples\n make -j\n\n\n\n\nThe serial examples can also be build with the parallel version of the library,\ne.g.\n\n\n~/mfem-3.4/examples\n make ex1 ex2\n\n\n\n\nAll parallel examples and miniapps can be build with:\n\n\n~\n cd mfem-3.4\n~/mfem-3.4\n make all -j\n\n\n\n\nOne can also use the parallel library to optionally (re-)build GLVis:\n\n\n~\n cd glvis-3.4\n~/glvis-3.4\n make clean\n~/glvis-3.4\n make MFEM_DIR=../mfem-3.4 -j\n\n\n\n\nThis, however, is generally \nnot recommended\n, since the additional MPI thread\ncan interfere with the other GLVis threads.\n\n\nParallel build using METIS 5\n\n\nBuild METIS 5:\n\n\n~\n tar zvxf metis-5.1.0.tar.gz\n~\n cd metis-5.1.0\n~/metis-5.1.0\n make config ; make\n~/metis-5.1.0\n mkdir lib\n~/metis-5.1.0\n ln -s ../build/Linux-x86_64/libmetis/libmetis.a lib\n\n\n\n\nBuild the parallel version of MFEM, setting the options \nMFEM_USE_METIS_5\n and\n\nMETIS_DIR\n, e.g.:\n\n\n~\n cd mfem-3.4\n~/mfem-3.4\n make parallel -j MFEM_USE_METIS_5=YES METIS_DIR=@MFEM_DIR@/../metis-5.1.0", 
            "title": "Building MFEM"
        }, 
        {
            "location": "/building/#building-mfem", 
            "text": "A simple tutorial how to build and run the serial and parallel version of MFEM\ntogether with GLVis. For more details, see the INSTALL  file and make help .  In addition to the native build system described below, MFEM packages are\nalso available in the following package managers:   Spack  OpenHPC  Homebrew/Science  (deprecated)   MFEM can also be installed as part of   CEED  xSDK  E4S  FASTMath  RADIUSS", 
            "title": "Building MFEM"
        }, 
        {
            "location": "/building/#instructions", 
            "text": "Download MFEM and GLVis   http://mfem.org  http://glvis.org   Below we assume that we are working with versions 3.4.", 
            "title": "Instructions"
        }, 
        {
            "location": "/building/#serial-version-of-mfem-and-glvis", 
            "text": "Put everything in the same directory:  ~  ls\nglvis-3.4.tgz   mfem-3.4.tgz  Build the serial version of MFEM:  ~  tar -zxvf mfem-3.4.tgz\n~  cd mfem-3.4\n~/mfem-3.4  make serial -j  Build GLVis:  ~  tar -zxvf glvis-3.4.tgz\n~  cd glvis-3.4\n~/glvis-3.4  make MFEM_DIR=../mfem-3.4 -j  That's it! The MFEM library can be found in  mfem-3.4/libmfem.a , while the glvis  executable will be in the  glvis-3.4  directory.  To start a GLVis server, open a  new terminal  and type  ~  cd glvis-3.4\n~/glvis-3.4  ./glvis  The serial examples can be build with:  ~  cd mfem-3.4/examples\n~/mfem-3.4/examples  make -j  All serial examples and miniapps can be build with:  ~  cd mfem-3.4\n~/mfem-3.4  make all -j", 
            "title": "Serial version of MFEM and GLVis"
        }, 
        {
            "location": "/building/#parallel-mpi-version-of-mfem", 
            "text": "Download  hypre  and metis from   https://github.com/hypre-space/hypre/releases  https://computation.llnl.gov/casc/hypre/software.html  http://glaros.dtc.umn.edu/gkhome/metis/metis/download   Below we assume that we are working with versions 2.16.0 and 4.0.3 \nrespectively. We also assume that the serial version of MFEM and GLVis have been\nbuilt as described above.  Put everything in the same directory:  ~  ls\nglvis-3.4/  hypre-2.16.0.tar.gz   metis-4.0.3.tar.gz   mfem-3.4/  Build hypre:  ~  tar -zxvf hypre-2.16.0.tar.gz\n~  cd hypre-2.16.0/src/\n~/hypre-2.16.0/src  ./configure --disable-fortran\n~/hypre-2.16.0/src  make -j\n~/hypre-2.16.0/src  cd ../..\n~  ln -s hypre-2.16.0 hypre  Build metis:  ~  tar -zxvf metis-4.0.3.tar.gz\n~  cd metis-4.0.3\n~/metis-4.0.3  make\n~/metis-4.0.3  cd ..\n~  ln -s metis-4.0.3 metis-4.0  (If you are using METIS 5, see the instructions below .)  Build the parallel version of MFEM:  ~  cd mfem-3.4\n~/mfem-3.4  make parallel -j  Note that if hypre or metis are in different locations, or you have different\nversions of these libraries, you will need to update the corresponding paths in\nthe config/defaults.mk \nfile, or create you own  config/user.mk , as described in the INSTALL  file.  The parallel examples can be build with:  ~  cd mfem-3.4/examples\n~/mfem-3.4/examples  make -j  The serial examples can also be build with the parallel version of the library,\ne.g.  ~/mfem-3.4/examples  make ex1 ex2  All parallel examples and miniapps can be build with:  ~  cd mfem-3.4\n~/mfem-3.4  make all -j  One can also use the parallel library to optionally (re-)build GLVis:  ~  cd glvis-3.4\n~/glvis-3.4  make clean\n~/glvis-3.4  make MFEM_DIR=../mfem-3.4 -j  This, however, is generally  not recommended , since the additional MPI thread\ncan interfere with the other GLVis threads.", 
            "title": "Parallel MPI version of MFEM"
        }, 
        {
            "location": "/building/#parallel-build-using-metis-5", 
            "text": "Build METIS 5:  ~  tar zvxf metis-5.1.0.tar.gz\n~  cd metis-5.1.0\n~/metis-5.1.0  make config ; make\n~/metis-5.1.0  mkdir lib\n~/metis-5.1.0  ln -s ../build/Linux-x86_64/libmetis/libmetis.a lib  Build the parallel version of MFEM, setting the options  MFEM_USE_METIS_5  and METIS_DIR , e.g.:  ~  cd mfem-3.4\n~/mfem-3.4  make parallel -j MFEM_USE_METIS_5=YES METIS_DIR=@MFEM_DIR@/../metis-5.1.0", 
            "title": "Parallel build using METIS 5"
        }, 
        {
            "location": "/serial-tutorial/", 
            "text": "MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});\n\n\n\n\n\n\n\n\n\nSerial Tutorial\n\n\nSummary\n\n\nThis tutorial illustrates the building and sample use of the following MFEM serial example codes:\n\n\n\n\nExample 1\n\n\nExample 2\n\n\nExample 3\n\n\n\n\nAn interactive documentation of all example codes is available \nhere\n.\n\n\nBuilding\n\n\nFollow the \nserial instructions\n to build the MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).\n\n\nTo build the serial example codes, type \nmake\n in MFEM's examples directory:\n\n\n~/mfem/examples\n make\ng++ -O3 -I.. ex1.cpp -o ex1 -L.. -lmfem\ng++ -O3 -I.. ex2.cpp -o ex2 -L.. -lmfem\ng++ -O3 -I.. ex3.cpp -o ex3 -L.. -lmfem\ng++ -O3 -I.. ex4.cpp -o ex4 -L.. -lmfem\ng++ -O3 -I.. ex5.cpp -o ex5 -L.. -lmfem\ng++ -O3 -I.. ex6.cpp -o ex6 -L.. -lmfem\ng++ -O3 -I.. ex7.cpp -o ex7 -L.. -lmfem\ng++ -O3 -I.. ex8.cpp -o ex8 -L.. -lmfem\ng++ -O3 -I.. ex9.cpp -o ex9 -L.. -lmfem\ng++ -O3 -I.. ex10.cpp -o ex10 -L.. -lmfem\n\n\n\n\nExample 1\n\n\nThis example code demonstrates the use of MFEM to define a simple\nlinear finite element discretization of the Laplace problem\n$-\\Delta u = 1$ with homogeneous Dirichlet boundary conditions. To run it, simply specify the input mesh file (which will be refined to a final mesh with no more than 50,000 elements):\n\n\n~/mfem/examples\n ex1 -m ../data/star.mesh\n   Iteration :   0  (B r, r) = 0.00111712\n   Iteration :   1  (B r, r) = 0.00674088\n   Iteration :   2  (B r, r) = 0.0123008\n...\n   Iteration :  88  (B r, r) = 5.28955e-15\n   Iteration :  89  (B r, r) = 1.99155e-15\n   Iteration :  90  (B r, r) = 9.91309e-16\nAverage reduction factor = 0.857127\n\n\n\n\nIf a GLVis server is running, the computed finite element solution will appear in an interactive window:\n\n\n\n\nYou can examine the solution using the mouse and the GLVis \ncommand keystrokes\n.\nPressing \"\nRAfjlmm\n\", for example, will give us a 2D view without light or perspective showing the computed level lines:\n\n\n\n\nThis example saves two files called \nrefined.mesh\n and \nsol.gf\n, which represent the refined mesh and the computed solution as a grid function. These can be visualized with \nglvis -m refined.mesh -g sol.gf\n as discussed \nhere\n.\n\n\nExample 1 can be run on any mesh that is supported by MFEM, including 3D, curvilinear and VTK meshes, e.g.,\n\n\n~/mfem/examples\n ex1 -m ../data/fichera-q2.vtk\n   Iteration :   0  (B r, r) = 0.0235996\n   Iteration :   1  (B r, r) = 0.0476694\n   Iteration :   2  (B r, r) = 0.0200109\n...\n   Iteration :  27  (B r, r) = 7.77888e-14\n   Iteration :  28  (B r, r) = 2.36255e-14\n   Iteration :  29  (B r, r) = 8.56679e-15\nAverage reduction factor = 0.610261\n\n\n\n\n\n\nThe picture above shows the solution with level lines plotted in normal direction of a cutting plane, and was produced by typing \"\nAaafmIMMooo\n\" followed by cutting plane adjustments with \"\nz\n\", \"\ny\n\" and \"\nw\n\".\n\n\nExample 2\n\n\nThis example code solves a simple linear elasticity problem describing a multi-material Cantilever beam. Note that the input mesh should have at least two materials and two boundary attributes as shown below:\n\n\n               +----------+----------+\n  boundary ---\n| material | material |\n--- boundary\n  attribute 1  |    1     |    2     |     attribute 2\n  (fixed)      +----------+----------+     (pull down)\n\n\n\n\nThe example demonstrates the use of (high-order) vector finite element spaces by supporting several different discretization options:\n\n\n~/mfem/examples\n ex2 -m ../data/beam-quad.mesh -o 2\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 1.88755e-06\n   Iteration :   1  (B r, r) = 8.2357e-07\n   Iteration :   2  (B r, r) = 9.9098e-07\n...\n   Iteration : 498  (B r, r) = 2.78279e-11\n   Iteration : 499  (B r, r) = 3.75298e-11\n   Iteration : 500  (B r, r) = 4.95682e-11\nPCG: No convergence!\n(B r_0, r_0) = 1.88755e-06\n(B r_N, r_N) = 4.95682e-11\nNumber of PCG iterations: 500\nAverage reduction factor = 0.989508\n\n\n\n\nThe output shows the (curved) displaced mesh together with the inverse displacement vector field:\n\n\n\n\nThe above plot can be alternatively produced with:\n\n\nglvis -m displaced.mesh -g sol.gf -k \nRfjliiiiimmAbb\n\n\n\n\n\nExample 2 also works in 3D:\n\n\n~/mfem/examples\n ex2 -m ../data/beam-tet.mesh -o 3\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 2.7147e-06\n   Iteration :   1  (B r, r) = 1.95756e-06\n   Iteration :   2  (B r, r) = 2.24159e-06\n...\n   Iteration : 426  (B r, r) = 3.37563e-14\n   Iteration : 427  (B r, r) = 3.06198e-14\n   Iteration : 428  (B r, r) = 2.5706e-14\nAverage reduction factor = 0.978648\n\n\n\n\nOne can visualize the vector field, e.g., by pressing \"\ndbAfmeoooovvaa\n\" followed by scale and position adjustments with the mouse:\n\n\n\n\nExample 3\n\n\nThis example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation ${\\rm curl\\, curl}\\, E + E = f$ discretized with the lowest order Nedelec finite elements. It computes the approximation error with a know exact solution, and requires a 3D input mesh:\n\n\n~/mfem/examples\n ex3 -m ../data/fichera.mesh\n   Iteration :   0  (B r, r) = 121.209\n   Iteration :   1  (B r, r) = 21.1137\n   Iteration :   2  (B r, r) = 12.6503\n...\n   Iteration : 149  (B r, r) = 2.40571e-10\n   Iteration : 150  (B r, r) = 1.39788e-10\n   Iteration : 151  (B r, r) = 9.43635e-11\nAverage reduction factor = 0.911811\n\n|| E_h - E ||_{L^2} = 0.00976655\n\n\n\n\nTo visualize the magnitude of the solution with the proportionally-sized vector field shown only on the boundary of the domain, type \"\nVfooogt\n\" in the GLVis window (or run \nglvis -m refined.mesh -g sol.gf -k \"Vfooogt\"\n):\n\n\n\n\nCurved meshes are also supported:\n\n\n~/mfem/examples\n ex3 -m ../data/fichera-q3.mesh\n   Iteration :   0  (B r, r) = 135.613\n   Iteration :   1  (B r, r) = 22.3785\n   Iteration :   2  (B r, r) = 12.5215\n...\n   Iteration : 168  (B r, r) = 4.95911e-10\n   Iteration : 169  (B r, r) = 2.23499e-10\n   Iteration : 170  (B r, r) = 1.25714e-10\nAverage reduction factor = 0.921741\n\n|| E_h - E ||_{L^2} = 0.0821686\n\n\n\n\n\n\nTo visualize the entire vector field, type \"\nfooogtevv\n\" instead, which will use uniform sized arrows colored according to their magnitude. Here is the corresponding plot from \"\nex3 -m ../data/beam-hex.mesh\n\":\n\n\n\n\nSince entire vector fields in 3D might be difficult to see, a good alternative might be to plot the separate components of the field as scalar functions. For example:\n\n\n~/mfem/examples\n ex3 -m ../data/escher.mesh\n   Iteration :   0  (B r, r) = 348.797\n   Iteration :   1  (B r, r) = 32.0699\n   Iteration :   2  (B r, r) = 14.902\n...\n   Iteration : 159  (B r, r) = 4.16076e-10\n   Iteration : 160  (B r, r) = 3.50907e-10\n   Iteration : 161  (B r, r) = 3.22923e-10\nAverage reduction factor = 0.917548\n\n|| E_h - E ||_{L^2} = 0.36541\n\n~/mfem/examples\n glvis -m refined.mesh -g sol.gf -gc 0 -k \ngooottF\n\n\n\n\n\n\n\nThe discontinuity of the Nedelec functions is clearly seen in the above plot.", 
            "title": "Serial Tutorial"
        }, 
        {
            "location": "/serial-tutorial/#serial-tutorial", 
            "text": "", 
            "title": "Serial Tutorial"
        }, 
        {
            "location": "/serial-tutorial/#summary", 
            "text": "This tutorial illustrates the building and sample use of the following MFEM serial example codes:   Example 1  Example 2  Example 3   An interactive documentation of all example codes is available  here .", 
            "title": "Summary"
        }, 
        {
            "location": "/serial-tutorial/#building", 
            "text": "Follow the  serial instructions  to build the MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).  To build the serial example codes, type  make  in MFEM's examples directory:  ~/mfem/examples  make\ng++ -O3 -I.. ex1.cpp -o ex1 -L.. -lmfem\ng++ -O3 -I.. ex2.cpp -o ex2 -L.. -lmfem\ng++ -O3 -I.. ex3.cpp -o ex3 -L.. -lmfem\ng++ -O3 -I.. ex4.cpp -o ex4 -L.. -lmfem\ng++ -O3 -I.. ex5.cpp -o ex5 -L.. -lmfem\ng++ -O3 -I.. ex6.cpp -o ex6 -L.. -lmfem\ng++ -O3 -I.. ex7.cpp -o ex7 -L.. -lmfem\ng++ -O3 -I.. ex8.cpp -o ex8 -L.. -lmfem\ng++ -O3 -I.. ex9.cpp -o ex9 -L.. -lmfem\ng++ -O3 -I.. ex10.cpp -o ex10 -L.. -lmfem", 
            "title": "Building"
        }, 
        {
            "location": "/serial-tutorial/#example-1", 
            "text": "This example code demonstrates the use of MFEM to define a simple\nlinear finite element discretization of the Laplace problem\n$-\\Delta u = 1$ with homogeneous Dirichlet boundary conditions. To run it, simply specify the input mesh file (which will be refined to a final mesh with no more than 50,000 elements):  ~/mfem/examples  ex1 -m ../data/star.mesh\n   Iteration :   0  (B r, r) = 0.00111712\n   Iteration :   1  (B r, r) = 0.00674088\n   Iteration :   2  (B r, r) = 0.0123008\n...\n   Iteration :  88  (B r, r) = 5.28955e-15\n   Iteration :  89  (B r, r) = 1.99155e-15\n   Iteration :  90  (B r, r) = 9.91309e-16\nAverage reduction factor = 0.857127  If a GLVis server is running, the computed finite element solution will appear in an interactive window:   You can examine the solution using the mouse and the GLVis  command keystrokes .\nPressing \" RAfjlmm \", for example, will give us a 2D view without light or perspective showing the computed level lines:   This example saves two files called  refined.mesh  and  sol.gf , which represent the refined mesh and the computed solution as a grid function. These can be visualized with  glvis -m refined.mesh -g sol.gf  as discussed  here .  Example 1 can be run on any mesh that is supported by MFEM, including 3D, curvilinear and VTK meshes, e.g.,  ~/mfem/examples  ex1 -m ../data/fichera-q2.vtk\n   Iteration :   0  (B r, r) = 0.0235996\n   Iteration :   1  (B r, r) = 0.0476694\n   Iteration :   2  (B r, r) = 0.0200109\n...\n   Iteration :  27  (B r, r) = 7.77888e-14\n   Iteration :  28  (B r, r) = 2.36255e-14\n   Iteration :  29  (B r, r) = 8.56679e-15\nAverage reduction factor = 0.610261   The picture above shows the solution with level lines plotted in normal direction of a cutting plane, and was produced by typing \" AaafmIMMooo \" followed by cutting plane adjustments with \" z \", \" y \" and \" w \".", 
            "title": "Example 1"
        }, 
        {
            "location": "/serial-tutorial/#example-2", 
            "text": "This example code solves a simple linear elasticity problem describing a multi-material Cantilever beam. Note that the input mesh should have at least two materials and two boundary attributes as shown below:                 +----------+----------+\n  boundary --- | material | material | --- boundary\n  attribute 1  |    1     |    2     |     attribute 2\n  (fixed)      +----------+----------+     (pull down)  The example demonstrates the use of (high-order) vector finite element spaces by supporting several different discretization options:  ~/mfem/examples  ex2 -m ../data/beam-quad.mesh -o 2\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 1.88755e-06\n   Iteration :   1  (B r, r) = 8.2357e-07\n   Iteration :   2  (B r, r) = 9.9098e-07\n...\n   Iteration : 498  (B r, r) = 2.78279e-11\n   Iteration : 499  (B r, r) = 3.75298e-11\n   Iteration : 500  (B r, r) = 4.95682e-11\nPCG: No convergence!\n(B r_0, r_0) = 1.88755e-06\n(B r_N, r_N) = 4.95682e-11\nNumber of PCG iterations: 500\nAverage reduction factor = 0.989508  The output shows the (curved) displaced mesh together with the inverse displacement vector field:   The above plot can be alternatively produced with:  glvis -m displaced.mesh -g sol.gf -k  RfjliiiiimmAbb   Example 2 also works in 3D:  ~/mfem/examples  ex2 -m ../data/beam-tet.mesh -o 3\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 2.7147e-06\n   Iteration :   1  (B r, r) = 1.95756e-06\n   Iteration :   2  (B r, r) = 2.24159e-06\n...\n   Iteration : 426  (B r, r) = 3.37563e-14\n   Iteration : 427  (B r, r) = 3.06198e-14\n   Iteration : 428  (B r, r) = 2.5706e-14\nAverage reduction factor = 0.978648  One can visualize the vector field, e.g., by pressing \" dbAfmeoooovvaa \" followed by scale and position adjustments with the mouse:", 
            "title": "Example 2"
        }, 
        {
            "location": "/serial-tutorial/#example-3", 
            "text": "This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation ${\\rm curl\\, curl}\\, E + E = f$ discretized with the lowest order Nedelec finite elements. It computes the approximation error with a know exact solution, and requires a 3D input mesh:  ~/mfem/examples  ex3 -m ../data/fichera.mesh\n   Iteration :   0  (B r, r) = 121.209\n   Iteration :   1  (B r, r) = 21.1137\n   Iteration :   2  (B r, r) = 12.6503\n...\n   Iteration : 149  (B r, r) = 2.40571e-10\n   Iteration : 150  (B r, r) = 1.39788e-10\n   Iteration : 151  (B r, r) = 9.43635e-11\nAverage reduction factor = 0.911811\n\n|| E_h - E ||_{L^2} = 0.00976655  To visualize the magnitude of the solution with the proportionally-sized vector field shown only on the boundary of the domain, type \" Vfooogt \" in the GLVis window (or run  glvis -m refined.mesh -g sol.gf -k \"Vfooogt\" ):   Curved meshes are also supported:  ~/mfem/examples  ex3 -m ../data/fichera-q3.mesh\n   Iteration :   0  (B r, r) = 135.613\n   Iteration :   1  (B r, r) = 22.3785\n   Iteration :   2  (B r, r) = 12.5215\n...\n   Iteration : 168  (B r, r) = 4.95911e-10\n   Iteration : 169  (B r, r) = 2.23499e-10\n   Iteration : 170  (B r, r) = 1.25714e-10\nAverage reduction factor = 0.921741\n\n|| E_h - E ||_{L^2} = 0.0821686   To visualize the entire vector field, type \" fooogtevv \" instead, which will use uniform sized arrows colored according to their magnitude. Here is the corresponding plot from \" ex3 -m ../data/beam-hex.mesh \":   Since entire vector fields in 3D might be difficult to see, a good alternative might be to plot the separate components of the field as scalar functions. For example:  ~/mfem/examples  ex3 -m ../data/escher.mesh\n   Iteration :   0  (B r, r) = 348.797\n   Iteration :   1  (B r, r) = 32.0699\n   Iteration :   2  (B r, r) = 14.902\n...\n   Iteration : 159  (B r, r) = 4.16076e-10\n   Iteration : 160  (B r, r) = 3.50907e-10\n   Iteration : 161  (B r, r) = 3.22923e-10\nAverage reduction factor = 0.917548\n\n|| E_h - E ||_{L^2} = 0.36541\n\n~/mfem/examples  glvis -m refined.mesh -g sol.gf -gc 0 -k  gooottF    The discontinuity of the Nedelec functions is clearly seen in the above plot.", 
            "title": "Example 3"
        }, 
        {
            "location": "/parallel-tutorial/", 
            "text": "Parallel Tutorial\n\n\nSummary\n\n\nThis tutorial illustrates the building and sample use of the following MFEM parallel example codes:\n\n\n\n\nExample 1p\n\n\nExample 2p\n\n\nExample 3p\n\n\n\n\nAn interactive documentation of all example codes is available \nhere\n.\n\n\nBuilding\n\n\nFollow the \nbuilding instructions\n to build the parallel MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).\n\n\nTo build the parallel example codes, type \nmake\n in MFEM's examples directory:\n\n\n~/mfem/examples\n make\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex1p.cpp -o ex1p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex2p.cpp -o ex2p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex3p.cpp -o ex3p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex4p.cpp -o ex4p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex5p.cpp -o ex5p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex7p.cpp -o ex7p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex8p.cpp -o ex8p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex9p.cpp -o ex9p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex10p.cpp -o ex10p ...\n\n\n\n\nExample 1p\n\n\nThis is a parallel version of \nExample 1\n using \nhypre\n's BoomerAMG preconditioner. Run this example as follows:\n\n\n~/mfem/examples\n mpirun -np 16 ex1p -m ../data/square-disc.mesh\n...\nPCG Iterations = 26\nFinal PCG Relative Residual Norm = 4.30922e-13\n\n\n\n\nIf a GLVis server is running, the computed finite element solution \ncombined from all processors\n, will appear in an interactive window:\n\n\n\n\nYou can examine the solution using the mouse and the GLVis \ncommand keystrokes\n.\nTo view the parallel partitioning, for example, press the following keys in the GLVis window: \"\nRAjlmm\n\" followed by F11/F12 and zooming with the right mouse button.\n\n\n\n\nTo examine the solution only in one, or a few parallel subdomains, one can use the F9/F10 and the F8 keys. In 2D, one can also use press \"\nb\n\" to draw the only the boundaries between the subdomains. For example\n\n\n\n\nwas produced by\n\n\nglvis -np 16 -m mesh -g sol -k \nRAjlb\n\n\n\n\n\nfollowed by F9 and scaling/position adjustment with the mouse.\n\n\nThree-dimensional and curvilinear meshes are also supported in parallel:\n\n\n~/mfem/examples\n mpirun -np 16 ex1p -m ../data/escher-p3.mesh\n...\nPCG Iterations = 24\nFinal PCG Relative Residual Norm = 3.59964e-13\n~/mfem/examples\n glvis -np 16 -m mesh -g sol -k \nAooogtt\n\n\n\n\n\n\n\nThe continuity of the solution across the inter-processor interfaces can be seen by using a cutting plane (keys \"\nAoooiMMtmm\n\" followed by \"\nz\n\" and \"\nY\n\" adjustments):\n\n\n\n\nExample 2p\n\n\nThis is a parallel version of \nExample 2\n using the systems version of \nhypre\n's BoomerAMG preconditioner, which can be run analogous to the serial case:\n\n\n~/mfem/examples\n mpirun -np 16 ex2p -m ../data/beam-hex.mesh -o 1\n...\nPCG Iterations = 39\nFinal PCG Relative Residual Norm = 2.91528e-09\n\n\n\n\nTo view the parallel partitioning with the magnitude of the computed displacement field, type \"\nAtttaa\n\" in the GLVis window followed by subdomain shrinking with F11 and scaling adjustments with the mouse:\n\n\n\n\nExample 3p\n\n\nThis is a parallel version of \nExample 3\n using \nhypre\n's AMS preconditioner. Its use is analogous to the serial case:\n\n\n/mfem/examples\n mpirun -np 16 ex3p -m ../data/fichera-q3.mesh\n...\nPCG Iterations = 17\nFinal PCG Relative Residual Norm = 7.61595e-13\n\n|| E_h - E ||_{L^2} = 0.0821685\n\n\n\n\nNote that AMS leads to much fewer iterations than the Gauss-Seidel preconditioner used in the serial code. The parallel subdomain partitioning can be seen with \"\nooogt\n\" and F11/F12:\n\n\n\n\nOne can also visualize individual components of the Nedelec solution and remove the elements in a cutting plane to see the surfaces corresponding to inter-processor boundaries:\n\n\nglvis -np 16 -m mesh -g sol -k \nooottmiEF", 
            "title": "Parallel Tutorial"
        }, 
        {
            "location": "/parallel-tutorial/#parallel-tutorial", 
            "text": "", 
            "title": "Parallel Tutorial"
        }, 
        {
            "location": "/parallel-tutorial/#summary", 
            "text": "This tutorial illustrates the building and sample use of the following MFEM parallel example codes:   Example 1p  Example 2p  Example 3p   An interactive documentation of all example codes is available  here .", 
            "title": "Summary"
        }, 
        {
            "location": "/parallel-tutorial/#building", 
            "text": "Follow the  building instructions  to build the parallel MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).  To build the parallel example codes, type  make  in MFEM's examples directory:  ~/mfem/examples  make\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex1p.cpp -o ex1p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex2p.cpp -o ex2p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex3p.cpp -o ex3p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex4p.cpp -o ex4p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex5p.cpp -o ex5p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex7p.cpp -o ex7p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex8p.cpp -o ex8p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex9p.cpp -o ex9p ...\nmpicxx  -O3 -I..  -I../../hypre/src/hypre/include ex10p.cpp -o ex10p ...", 
            "title": "Building"
        }, 
        {
            "location": "/parallel-tutorial/#example-1p", 
            "text": "This is a parallel version of  Example 1  using  hypre 's BoomerAMG preconditioner. Run this example as follows:  ~/mfem/examples  mpirun -np 16 ex1p -m ../data/square-disc.mesh\n...\nPCG Iterations = 26\nFinal PCG Relative Residual Norm = 4.30922e-13  If a GLVis server is running, the computed finite element solution  combined from all processors , will appear in an interactive window:   You can examine the solution using the mouse and the GLVis  command keystrokes .\nTo view the parallel partitioning, for example, press the following keys in the GLVis window: \" RAjlmm \" followed by F11/F12 and zooming with the right mouse button.   To examine the solution only in one, or a few parallel subdomains, one can use the F9/F10 and the F8 keys. In 2D, one can also use press \" b \" to draw the only the boundaries between the subdomains. For example   was produced by  glvis -np 16 -m mesh -g sol -k  RAjlb   followed by F9 and scaling/position adjustment with the mouse.  Three-dimensional and curvilinear meshes are also supported in parallel:  ~/mfem/examples  mpirun -np 16 ex1p -m ../data/escher-p3.mesh\n...\nPCG Iterations = 24\nFinal PCG Relative Residual Norm = 3.59964e-13\n~/mfem/examples  glvis -np 16 -m mesh -g sol -k  Aooogtt    The continuity of the solution across the inter-processor interfaces can be seen by using a cutting plane (keys \" AoooiMMtmm \" followed by \" z \" and \" Y \" adjustments):", 
            "title": "Example 1p"
        }, 
        {
            "location": "/parallel-tutorial/#example-2p", 
            "text": "This is a parallel version of  Example 2  using the systems version of  hypre 's BoomerAMG preconditioner, which can be run analogous to the serial case:  ~/mfem/examples  mpirun -np 16 ex2p -m ../data/beam-hex.mesh -o 1\n...\nPCG Iterations = 39\nFinal PCG Relative Residual Norm = 2.91528e-09  To view the parallel partitioning with the magnitude of the computed displacement field, type \" Atttaa \" in the GLVis window followed by subdomain shrinking with F11 and scaling adjustments with the mouse:", 
            "title": "Example 2p"
        }, 
        {
            "location": "/parallel-tutorial/#example-3p", 
            "text": "This is a parallel version of  Example 3  using  hypre 's AMS preconditioner. Its use is analogous to the serial case:  /mfem/examples  mpirun -np 16 ex3p -m ../data/fichera-q3.mesh\n...\nPCG Iterations = 17\nFinal PCG Relative Residual Norm = 7.61595e-13\n\n|| E_h - E ||_{L^2} = 0.0821685  Note that AMS leads to much fewer iterations than the Gauss-Seidel preconditioner used in the serial code. The parallel subdomain partitioning can be seen with \" ooogt \" and F11/F12:   One can also visualize individual components of the Nedelec solution and remove the elements in a cutting plane to see the surfaces corresponding to inter-processor boundaries:  glvis -np 16 -m mesh -g sol -k  ooottmiEF", 
            "title": "Example 3p"
        }, 
        {
            "location": "/fem/", 
            "text": "Finite Element Method\n\n\nThe finite element method is a general discretization technique that can utilize\nunstructured grids to approximate the solutions of many partial differential\nequations (PDEs).\n\n\nThere is a large body of literature on finite elements, including the\nfollowing excellent books:\n\n\n\n\nNumerical Solution of Partial Differential Equations by the Finite Element Method\n by \nClaes Johnson\n\n\nTheory and Practice of Finite Elements\n by \nAlexandre Ern\n and \nJean-Luc Guermond\n\n\nHigher-Order Finite Element Methods\n by \nPavel \u0160ol\u00edn\n, \nKarel Segeth\n and \nIvo Dole\u017eel\n\n\nHigh-Order Methods for Incompressible Fluid Flow\n by \nMichel Deville\n, \nPaul Fischer\n and \nErnest Mund\n\n\nFinite Elements: Theory, Fast Solvers, and Applications in Elasticity Theory\n by \nDietrich Braess\n\n\nThe Finite Element Method for Elliptic Problems\n by \nPhilippe Ciarlet\n\n\nThe Mathematical Theory of Finite Element Methods\n by \nSusanne Brenner\n and \nRidgway Scott\n\n\nAn Analysis of the Finite Element Method\n by \nGilbert Strang\n and \nGeorge Fix\n\n\nThe Finite Element Method: Its Basis and Fundamentals\n by \nOlek Zienkiewicz\n, \nRobert Taylor\n and \nJ.Z. Zhu\n\n\n\n\nThe MFEM library is designed to be lightweight, general and highly scalable\nfinite element toolkit that provides the building blocks for developing finite\nelement algorithms in a manner similar to that of MATLAB for linear algebra\nmethods.\n\n\nSome of the C++ classes for the finite element realizations of these\nPDE-level concepts in MFEM are described below.\n\n\nPrimal and Dual Vectors\n\n\nThe finite element method uses vectors of data in a variety of ways and the\ndifferences can be subtle.  MFEM defines \nGridFunction\n, \nLinearForm\n, and\n\nVector\n classes which help to distinguish the different roles that vectors of\ndata can play.\n\n\nBilinear Form Integrators\n\n\nBilinear form integrators are at the heart of any finite element method, they\nare used to compute the integrals of products of basis functions over individual\nmesh elements (or sometimes over edges or faces).  The \nBilinearForm\n class adds\nseveral \nBilinearFormIntegrator\ns together to build the global sparse finite\nelement matrix.\n\n\nLinear Form Integrators\n\n\nLinear form integrators are used to compute the integrals of products of a basis\nfunction with a given source function over individual mesh elements (or\nsometimes over edges or faces).  The \nLinearForm\n class adds several\n\nLinearFormIntegrator\ns together to build the global right-hand side for the\nfinite element linear system.\n\n\nLinear Interpolators\n\n\nUnlike Bilinear and Linear forms, Linear Interpolators do not perform\nintegrations, but project one basis function (or a\nlinear function of a basis function) onto another basis function.  The\n\nDiscreteLinearOperator\n class adds one or more \nLinearInterpolators\n\ntogether to build a global sparse matrix representation of the linear\noperator.", 
            "title": "Finite Elements"
        }, 
        {
            "location": "/fem/#finite-element-method", 
            "text": "The finite element method is a general discretization technique that can utilize\nunstructured grids to approximate the solutions of many partial differential\nequations (PDEs).  There is a large body of literature on finite elements, including the\nfollowing excellent books:   Numerical Solution of Partial Differential Equations by the Finite Element Method  by  Claes Johnson  Theory and Practice of Finite Elements  by  Alexandre Ern  and  Jean-Luc Guermond  Higher-Order Finite Element Methods  by  Pavel \u0160ol\u00edn ,  Karel Segeth  and  Ivo Dole\u017eel  High-Order Methods for Incompressible Fluid Flow  by  Michel Deville ,  Paul Fischer  and  Ernest Mund  Finite Elements: Theory, Fast Solvers, and Applications in Elasticity Theory  by  Dietrich Braess  The Finite Element Method for Elliptic Problems  by  Philippe Ciarlet  The Mathematical Theory of Finite Element Methods  by  Susanne Brenner  and  Ridgway Scott  An Analysis of the Finite Element Method  by  Gilbert Strang  and  George Fix  The Finite Element Method: Its Basis and Fundamentals  by  Olek Zienkiewicz ,  Robert Taylor  and  J.Z. Zhu   The MFEM library is designed to be lightweight, general and highly scalable\nfinite element toolkit that provides the building blocks for developing finite\nelement algorithms in a manner similar to that of MATLAB for linear algebra\nmethods.  Some of the C++ classes for the finite element realizations of these\nPDE-level concepts in MFEM are described below.", 
            "title": "Finite Element Method"
        }, 
        {
            "location": "/fem/#primal-and-dual-vectors", 
            "text": "The finite element method uses vectors of data in a variety of ways and the\ndifferences can be subtle.  MFEM defines  GridFunction ,  LinearForm , and Vector  classes which help to distinguish the different roles that vectors of\ndata can play.", 
            "title": "Primal and Dual Vectors"
        }, 
        {
            "location": "/fem/#bilinear-form-integrators", 
            "text": "Bilinear form integrators are at the heart of any finite element method, they\nare used to compute the integrals of products of basis functions over individual\nmesh elements (or sometimes over edges or faces).  The  BilinearForm  class adds\nseveral  BilinearFormIntegrator s together to build the global sparse finite\nelement matrix.", 
            "title": "Bilinear Form Integrators"
        }, 
        {
            "location": "/fem/#linear-form-integrators", 
            "text": "Linear form integrators are used to compute the integrals of products of a basis\nfunction with a given source function over individual mesh elements (or\nsometimes over edges or faces).  The  LinearForm  class adds several LinearFormIntegrator s together to build the global right-hand side for the\nfinite element linear system.", 
            "title": "Linear Form Integrators"
        }, 
        {
            "location": "/fem/#linear-interpolators", 
            "text": "Unlike Bilinear and Linear forms, Linear Interpolators do not perform\nintegrations, but project one basis function (or a\nlinear function of a basis function) onto another basis function.  The DiscreteLinearOperator  class adds one or more  LinearInterpolators \ntogether to build a global sparse matrix representation of the linear\noperator.", 
            "title": "Linear Interpolators"
        }, 
        {
            "location": "/pri-dual-vec/", 
            "text": "Primal and Dual Vectors\n\n\nThe finite element method uses vectors of data in a variety of ways and the\ndifferences can be subtle.  MFEM defines \nGridFunction\n, \nLinearForm\n, and\n\nVector\n classes which help to distinguish the different roles that vectors of\ndata can play.\n\n\nGraphical summary of Primal, Dual, DoF (dofs),\nand True DoF (tdofs) vectors\n\n\n\n\nPrimal Vectors\n\n\nThe finite element method is based on the notion that a smooth function can be\napproximated by a sum of piece-wise smooth functions (typically piece-wise\npolynomilas) called \nbasis functions\n:\n$$f(\\vec{x})\\approx\\sum_i f_i \\phi_i(\\vec{x}) \\label{expan}$$\nThe support of an individual basis function, $\\;\\phi_i(\\vec{x})$, will either be\na single zone or a collection of zones that share a common vertex, edge, or\nface.  The expansion coefficients, $\\;f_i$, are linear functionals of the field\nbeing approximated, $\\;f(\\vec{x})$ in this case.  The $\\;f_i$ could be as simple\nas values of the function at particular points, called interpolation points,\ne.g. $\\;f_i=f(\\vec{x}_i)$, or they could be integrals of the field over\nsubmanifolds of the domain, e.g. $\\;f_i = \\int_{\\Omega_i}f(\\vec{x})d\\vec{x}$.\nThere are many possibilities but the expansion coefficients must be linear\nfunctionals of $\\;f(\\vec{x})$.  The expansion coefficients are often called\n\ndegrees of freedom\n, or \nDoFs\n for short, though in certain cases they may\nnot be actually independent because of some problem specific constraints.\nWe'll discuss this more in a later section on\n\nTrue DoFs\n.\n\n\nOnce the basis functions are defined, with some unique ordering, the expansion\ncoefficients can be stored in a vector using the same order.  Such a vector of\ncoefficients is called a \nprimal vector\n.  The original function,\n$\\;f(\\vec{x})$, can then be approximated using \\eqref{expan}.  In practice this\nrequires not only the primal vector of coefficients but also knowledge of the\nmesh and the basis functions for each element of the mesh.  In MFEM these\ncollections of information are combined into \nGridFunction\n objects (or\n\nParGridFunction\n objects when used in parallel) which represent piece-wise\nfunctions belonging to a finite element approximation space.\n\n\nThe \nGridFunction\n class contains many \nGet\n methods which can compute the\nexpansion \\eqref{expan} at particular locations within an element.  The primal\nvector of expansion coefficients can be computed by solving a linear system or\nby using any of the various \nProject\n methods provided by the \nGridFunction\n\nclass. These methods compute the degrees of freedom, $\\;f_i$, or some subset\nof them, from a \nCoefficient\n object representing $\\;f(\\vec{x})$.\nOther methods in this class can be used to compute  various measures of the\nerror in the finite element approximation of $\\;f(\\vec{x})$.\n\n\nDual Vectors\n\n\nAny vector space, such as the space of \nprimal vectors\n, has a dual space\ncontaining \nco-vectors\n a.k.a. \ndual vectors\n.  In this context a \ndual vector\n\nis a linear functional of a \nprimal vector\n meaning that the action of a\n\ndual vector\n upon a \nprimal vector\n is a real number.  For example, the\nintegral of a field over a domain,\n$\\;\\alpha=\\int_\\Omega f(\\vec{x})d\\vec{x}$, is a linear functional because the\nintegral is linear with respect to the function being integrated and the result\nis a real number.  Indeed we can derive similar linear functionals using\ncompatible functions, $\\;g(\\vec{x})$, in this way\n$G(f)=\\int_\\Omega g(\\vec{x})f(\\vec{x})d\\vec{x}$. If we compute the action of our\nfunctional on the finite element basis functions,\n$$G_i=G(\\phi_i(\\vec{x})) =\n\\int_\\Omega g(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\label{dualvec},$$\nand we collect the results into a vector we call this a \ndual vector\n.\n\n\nIntegrals such as this often arise when enforcing energy balance in physical\nsystems. For example, if $\\vec{J}$ is a current density describing a flow of\ncharged particles and $\\vec{E}$ is an electric field acting upon those\nparticles, then $\\int_\\Omega\\vec{J}\\cdot\\vec{E}\\,d\\vec{x}$ is the rate at which\nwork is being done by the field on the charged particles.\n\n\nMFEM provides \nLinearForm\n objects (or \nParLinearForm\n objects in parallel)\nwhich can compute \ndual vectors\n from a given function, $\\;g(\\vec{x})$.  These\nobjects require not only the mesh, basis functions, and the field\n$\\;g(\\vec{x})$ but also a \nLinearFormIntegrator\n which defines precisely what\ntype of linear functional is being computed.\nSee \nLinear Form Integrators\n for more information about MFEM's\nlinear form integrators.\n\n\nA \nLinearForm\n objects provide one means for computing dual vectors if you have\na \nCoefficient\n describing the function $\\;g(\\vec{x})$.  If, on the other hand,\nyou have a \nprimal vector\n, $\\;g_i$, representing $\\;g(\\vec{x})$ you can form a\n\ndual vector\n by multiplying $\\;g_i$ by a bilinear form,\nsee \nBilinear Form Integrators\n for more information on\nbilinear forms.  To understand why this is so, consider inserting the expansion\n\\eqref{expan} into \\eqref{dualvec}.\n$$\nG_i=\\int_\\Omega \\left(\\sum_j g_j \\phi_j(\\vec{x})\\right)\\phi_i(\\vec{x})d\\vec{x}\n= \\sum_j \\left(\\int_\\Omega \\phi_j(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\right)g_j\n\\label{dualvecprod}$$\nThe last integral contains two indices and can therefore be viewed as an entry\nin a square matrix.  Furthermore each \ndual vector\n entry, $\\;G_i$, is\nequivalent to one row of a matrix-vector product between this matrix of basis\nfunction integrals and the \nprimal vector\n $\\;g_i$.  This particular matrix,\ninvolving only the product of basis functions, is traditionally called a\n\nmass matrix\n. However, the action of any matrix, resulting from a bilinear\nform, upon a \nprimal vector\n will produce a \ndual vector\n.  In general, such\n\ndual vectors\n will have more complicated definitions than \\eqref{dualvec} or\n\\eqref{dualvecprod} but they will still be linear functionals of \nprimal\nvectors\n.\n\n\nTrue Degree-of-Freedom Vectors\n\n\nPrimal vectors contain all of the expansion coefficients needed to compute the\nfinite element approximation of a function in each element of a mesh.  When run\nin parallel, the local portion of a primal vector only contains data for the\nlocally owned elements.  Regardless of whether or not the simulation is being\nrun in parallel, some of these coefficients may in fact be redundant or\ninterdependent.\n\n\nSources of redundancy:\n\n\n\n\nIn parallel some coefficients must be shared between processors.\n\n\nWhen using static condensation or hybridization many coefficients will\n  depend upon the coefficients which are associated with the skeleton of the\n  mesh as well as upon other data.\n\n\nWhen using non-conforming meshes some of the coefficients on the finer side\n  of a non-conforming interface between elements will depend upon those on the\n  coarser side of the interface.\n\n\n\n\nFor any or all of these reasons primal vectors may not contain the \ntrue\ndegrees-of-freedom\n for describing a finite element approximation of a field.\nThe \ntrue\n set of degrees-of-freedom may in fact be much smaller than the size\nof the primal vector.\n\n\nWhen setting up and solving a linear system to determine the finite element\napproximation of a field, the size of the linear system is determined by the\nnumber of \ntrue degrees-of-freedom\n.  The details of creating this linear\nsystem are mostly hidden within the \nBilinearForm\n object. To convert\nindividual bilinear form objects the user can call the\n\nBilinearForm::FormSystemMatrix()\n method, however, the more common task is to\nform the entire linear system with \nBilinearForm::FormLinearSystem()\n.  As\ninput, this method requires a \nprimal vector\n, a \ndual vector\n, and an array of\nDirichlet boundary degree-of-freedom indices.  The degree-of-freedom array\ncontains the true degrees-of-freedom, as obtained from a \nFiniteElementSpace\n\nobject, which coincide with the Dirichlet, a.k.a. \nessential\n, boundaries.\n\n\n// Given a bilinear form 'a', a primal vector 'x', a dual vector 'b',\n// and an array of essential boundary true dof indices...\nSparseMatrix A;\nVector B, X;\na.FormLinearSystem(ess_tdof_list, x, b, A, X, B);\n\n// Solve X = A^{-1}B\n...\n\na.RecoverFEMSolution(X, b, x);\n\n\n\n\nThe primal vector\nmust contain the appropriate values for the solution on the essential\nboundaries.  The interior of the primal vector is ignored by default although\nit can be used to supply an initial guess when using certain solvers.  The dual\nvector should be an assembled \nLinearForm\n object or the product of a\n\nGridFunction\n and a \nBilinearForm\n.  As output,\n\nBilinearForm::FormLinearSystem()\n produces the objects $A$, $X$, and $B$ in\nthe linear system $A X=B$.  Where $A$ is ready to be passed to the appropriate\nMFEM solver, $X$ is properly initialized, and $B$ has been modified to\nincorporate the essential boundary conditions.  After the linear system has\nbeen solved the primal vector representing the solution must be built from $X$\nand the original dual vector by calling \nBilinearForm::RecoverFEMSolution()\n.\n\n\nTechnical Details\n\n\nConstructing Dual Vectors\n\n\nIt was mentioned above, in the section on\n\nDual Vectors\n, that you can create a dual vector\nby multiplying a primal vector by a bilinear form.  But of course if you have a\nprimal vector you can also use a \nGridFunctionCoefficient\n to create a dual\nvector using a \nLinearForm\n and an appropriate \nLinearFormIntegrator\n.  These\ntwo choices should produce nearly identical results if the\n\nBilinearFormIntegrator\n and the \nLinearFormIntegrator\n use the same\nintegration rule order.  The order of the summation might differ between\n\nBilinearFormIntegrator\n and \nLinearFormIntegrator\n, potentially resulting in\nround-off errors differences.\n\n\nWhen considering to use a BilinearForm or a LinearForm, one must be aware of\ntheir different computational and memory costs. A bilinear form must create a\nsparse matrix which can require a great deal of memory.  Integrating a\n\nGridFunctionCoefficient\n in a \nLinearForm\n object will require very little\nmemory.  On the other hand, computing the integrals inside a \nLinearForm\n\nobject can be computationally expensive even in comparison to assembling the\nbilinear form.\n\n\nWhich is the better option?  As always, there are trade-offs.  The answer\ndepends on many variables; the complexities of the \nBilinearFormIntegrator\n and\nthe \nLinearFormIntegrator\n, the complexity of other coefficients that may be\npresent, the order of the basis functions, can the bilinear form be reused or\nis this a one-time calculation, whether the code runs on a CPU or GPU, etc.. On\nsome architectures the motion of data through memory during a matrix-vector\nmultiplication may be expensive enough that using a \nLinearForm\n and\nrecomputing the integrals is more efficient.\n\n\nOften the construction of dual vectors is a small portion of the overall\ncompute time so this choice may not be critical.  The best choice is to test\nyour application and determine which method is more appropriate for your\nalgorithm on your hardware.\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "_Primal and Dual Vectors"
        }, 
        {
            "location": "/pri-dual-vec/#primal-and-dual-vectors", 
            "text": "The finite element method uses vectors of data in a variety of ways and the\ndifferences can be subtle.  MFEM defines  GridFunction ,  LinearForm , and Vector  classes which help to distinguish the different roles that vectors of\ndata can play.  Graphical summary of Primal, Dual, DoF (dofs),\nand True DoF (tdofs) vectors", 
            "title": "Primal and Dual Vectors"
        }, 
        {
            "location": "/pri-dual-vec/#primal-vectors", 
            "text": "The finite element method is based on the notion that a smooth function can be\napproximated by a sum of piece-wise smooth functions (typically piece-wise\npolynomilas) called  basis functions :\n$$f(\\vec{x})\\approx\\sum_i f_i \\phi_i(\\vec{x}) \\label{expan}$$\nThe support of an individual basis function, $\\;\\phi_i(\\vec{x})$, will either be\na single zone or a collection of zones that share a common vertex, edge, or\nface.  The expansion coefficients, $\\;f_i$, are linear functionals of the field\nbeing approximated, $\\;f(\\vec{x})$ in this case.  The $\\;f_i$ could be as simple\nas values of the function at particular points, called interpolation points,\ne.g. $\\;f_i=f(\\vec{x}_i)$, or they could be integrals of the field over\nsubmanifolds of the domain, e.g. $\\;f_i = \\int_{\\Omega_i}f(\\vec{x})d\\vec{x}$.\nThere are many possibilities but the expansion coefficients must be linear\nfunctionals of $\\;f(\\vec{x})$.  The expansion coefficients are often called degrees of freedom , or  DoFs  for short, though in certain cases they may\nnot be actually independent because of some problem specific constraints.\nWe'll discuss this more in a later section on True DoFs .  Once the basis functions are defined, with some unique ordering, the expansion\ncoefficients can be stored in a vector using the same order.  Such a vector of\ncoefficients is called a  primal vector .  The original function,\n$\\;f(\\vec{x})$, can then be approximated using \\eqref{expan}.  In practice this\nrequires not only the primal vector of coefficients but also knowledge of the\nmesh and the basis functions for each element of the mesh.  In MFEM these\ncollections of information are combined into  GridFunction  objects (or ParGridFunction  objects when used in parallel) which represent piece-wise\nfunctions belonging to a finite element approximation space.  The  GridFunction  class contains many  Get  methods which can compute the\nexpansion \\eqref{expan} at particular locations within an element.  The primal\nvector of expansion coefficients can be computed by solving a linear system or\nby using any of the various  Project  methods provided by the  GridFunction \nclass. These methods compute the degrees of freedom, $\\;f_i$, or some subset\nof them, from a  Coefficient  object representing $\\;f(\\vec{x})$.\nOther methods in this class can be used to compute  various measures of the\nerror in the finite element approximation of $\\;f(\\vec{x})$.", 
            "title": "Primal Vectors"
        }, 
        {
            "location": "/pri-dual-vec/#dual-vectors", 
            "text": "Any vector space, such as the space of  primal vectors , has a dual space\ncontaining  co-vectors  a.k.a.  dual vectors .  In this context a  dual vector \nis a linear functional of a  primal vector  meaning that the action of a dual vector  upon a  primal vector  is a real number.  For example, the\nintegral of a field over a domain,\n$\\;\\alpha=\\int_\\Omega f(\\vec{x})d\\vec{x}$, is a linear functional because the\nintegral is linear with respect to the function being integrated and the result\nis a real number.  Indeed we can derive similar linear functionals using\ncompatible functions, $\\;g(\\vec{x})$, in this way\n$G(f)=\\int_\\Omega g(\\vec{x})f(\\vec{x})d\\vec{x}$. If we compute the action of our\nfunctional on the finite element basis functions,\n$$G_i=G(\\phi_i(\\vec{x})) =\n\\int_\\Omega g(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\label{dualvec},$$\nand we collect the results into a vector we call this a  dual vector .  Integrals such as this often arise when enforcing energy balance in physical\nsystems. For example, if $\\vec{J}$ is a current density describing a flow of\ncharged particles and $\\vec{E}$ is an electric field acting upon those\nparticles, then $\\int_\\Omega\\vec{J}\\cdot\\vec{E}\\,d\\vec{x}$ is the rate at which\nwork is being done by the field on the charged particles.  MFEM provides  LinearForm  objects (or  ParLinearForm  objects in parallel)\nwhich can compute  dual vectors  from a given function, $\\;g(\\vec{x})$.  These\nobjects require not only the mesh, basis functions, and the field\n$\\;g(\\vec{x})$ but also a  LinearFormIntegrator  which defines precisely what\ntype of linear functional is being computed.\nSee  Linear Form Integrators  for more information about MFEM's\nlinear form integrators.  A  LinearForm  objects provide one means for computing dual vectors if you have\na  Coefficient  describing the function $\\;g(\\vec{x})$.  If, on the other hand,\nyou have a  primal vector , $\\;g_i$, representing $\\;g(\\vec{x})$ you can form a dual vector  by multiplying $\\;g_i$ by a bilinear form,\nsee  Bilinear Form Integrators  for more information on\nbilinear forms.  To understand why this is so, consider inserting the expansion\n\\eqref{expan} into \\eqref{dualvec}.\n$$\nG_i=\\int_\\Omega \\left(\\sum_j g_j \\phi_j(\\vec{x})\\right)\\phi_i(\\vec{x})d\\vec{x}\n= \\sum_j \\left(\\int_\\Omega \\phi_j(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\right)g_j\n\\label{dualvecprod}$$\nThe last integral contains two indices and can therefore be viewed as an entry\nin a square matrix.  Furthermore each  dual vector  entry, $\\;G_i$, is\nequivalent to one row of a matrix-vector product between this matrix of basis\nfunction integrals and the  primal vector  $\\;g_i$.  This particular matrix,\ninvolving only the product of basis functions, is traditionally called a mass matrix . However, the action of any matrix, resulting from a bilinear\nform, upon a  primal vector  will produce a  dual vector .  In general, such dual vectors  will have more complicated definitions than \\eqref{dualvec} or\n\\eqref{dualvecprod} but they will still be linear functionals of  primal\nvectors .", 
            "title": "Dual Vectors"
        }, 
        {
            "location": "/pri-dual-vec/#true-degree-of-freedom-vectors", 
            "text": "Primal vectors contain all of the expansion coefficients needed to compute the\nfinite element approximation of a function in each element of a mesh.  When run\nin parallel, the local portion of a primal vector only contains data for the\nlocally owned elements.  Regardless of whether or not the simulation is being\nrun in parallel, some of these coefficients may in fact be redundant or\ninterdependent.  Sources of redundancy:   In parallel some coefficients must be shared between processors.  When using static condensation or hybridization many coefficients will\n  depend upon the coefficients which are associated with the skeleton of the\n  mesh as well as upon other data.  When using non-conforming meshes some of the coefficients on the finer side\n  of a non-conforming interface between elements will depend upon those on the\n  coarser side of the interface.   For any or all of these reasons primal vectors may not contain the  true\ndegrees-of-freedom  for describing a finite element approximation of a field.\nThe  true  set of degrees-of-freedom may in fact be much smaller than the size\nof the primal vector.  When setting up and solving a linear system to determine the finite element\napproximation of a field, the size of the linear system is determined by the\nnumber of  true degrees-of-freedom .  The details of creating this linear\nsystem are mostly hidden within the  BilinearForm  object. To convert\nindividual bilinear form objects the user can call the BilinearForm::FormSystemMatrix()  method, however, the more common task is to\nform the entire linear system with  BilinearForm::FormLinearSystem() .  As\ninput, this method requires a  primal vector , a  dual vector , and an array of\nDirichlet boundary degree-of-freedom indices.  The degree-of-freedom array\ncontains the true degrees-of-freedom, as obtained from a  FiniteElementSpace \nobject, which coincide with the Dirichlet, a.k.a.  essential , boundaries.  // Given a bilinear form 'a', a primal vector 'x', a dual vector 'b',\n// and an array of essential boundary true dof indices...\nSparseMatrix A;\nVector B, X;\na.FormLinearSystem(ess_tdof_list, x, b, A, X, B);\n\n// Solve X = A^{-1}B\n...\n\na.RecoverFEMSolution(X, b, x);  The primal vector\nmust contain the appropriate values for the solution on the essential\nboundaries.  The interior of the primal vector is ignored by default although\nit can be used to supply an initial guess when using certain solvers.  The dual\nvector should be an assembled  LinearForm  object or the product of a GridFunction  and a  BilinearForm .  As output, BilinearForm::FormLinearSystem()  produces the objects $A$, $X$, and $B$ in\nthe linear system $A X=B$.  Where $A$ is ready to be passed to the appropriate\nMFEM solver, $X$ is properly initialized, and $B$ has been modified to\nincorporate the essential boundary conditions.  After the linear system has\nbeen solved the primal vector representing the solution must be built from $X$\nand the original dual vector by calling  BilinearForm::RecoverFEMSolution() .", 
            "title": "True Degree-of-Freedom Vectors"
        }, 
        {
            "location": "/pri-dual-vec/#technical-details", 
            "text": "", 
            "title": "Technical Details"
        }, 
        {
            "location": "/pri-dual-vec/#constructing-dual-vectors", 
            "text": "It was mentioned above, in the section on Dual Vectors , that you can create a dual vector\nby multiplying a primal vector by a bilinear form.  But of course if you have a\nprimal vector you can also use a  GridFunctionCoefficient  to create a dual\nvector using a  LinearForm  and an appropriate  LinearFormIntegrator .  These\ntwo choices should produce nearly identical results if the BilinearFormIntegrator  and the  LinearFormIntegrator  use the same\nintegration rule order.  The order of the summation might differ between BilinearFormIntegrator  and  LinearFormIntegrator , potentially resulting in\nround-off errors differences.  When considering to use a BilinearForm or a LinearForm, one must be aware of\ntheir different computational and memory costs. A bilinear form must create a\nsparse matrix which can require a great deal of memory.  Integrating a GridFunctionCoefficient  in a  LinearForm  object will require very little\nmemory.  On the other hand, computing the integrals inside a  LinearForm \nobject can be computationally expensive even in comparison to assembling the\nbilinear form.  Which is the better option?  As always, there are trade-offs.  The answer\ndepends on many variables; the complexities of the  BilinearFormIntegrator  and\nthe  LinearFormIntegrator , the complexity of other coefficients that may be\npresent, the order of the basis functions, can the bilinear form be reused or\nis this a one-time calculation, whether the code runs on a CPU or GPU, etc.. On\nsome architectures the motion of data through memory during a matrix-vector\nmultiplication may be expensive enough that using a  LinearForm  and\nrecomputing the integrals is more efficient.  Often the construction of dual vectors is a small portion of the overall\ncompute time so this choice may not be critical.  The best choice is to test\nyour application and determine which method is more appropriate for your\nalgorithm on your hardware.  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Constructing Dual Vectors"
        }, 
        {
            "location": "/bilininteg/", 
            "text": "Bilinear Form Integrators\n\n\n$\n\\newcommand{\\cross}{\\times}\n\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\n\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}\n\\newcommand{\\ddx}[1]{\\frac{d#1}{dx}}\n\\newcommand{\\abs}[1]{|#1|}\n$\n\n\nBilinear form integrators are at the heart of any finite element method, they\nare used to compute the integrals of products of basis functions over individual\nmesh elements (or sometimes over edges or faces).  Typically each element is\ncontained in the support of several basis functions of both the domain and range\nspaces, therefore bilinear integrators simultaneously compute the integrals of\nall combinations of the relevant basis functions from the domain and range\nspaces.  This produces a two dimensional array of results that are arranged into\na small dense matrix of integral values called a \nlocal element (stiffness)\nmatrix\n.\n\n\nTo put this another way, the \nBilinearForm\n class builds a global, sparse,\nfinite element matrix, \nglb_mat\n, by performing the outer loop in the following\npseudocode snippet whereas the \nBilinearFormIntegrator\n class performs the\nnested inner loops to compute the dense local element matrix, \nloc_mat\n.\n\n\nfor each elem in elements\n   loc_mat = 0.0\n   for each pt in quadrature_points\n      for each u_j in elem\n         for each v_i in elem\n            loc_mat(i,j) += w(pt) * u_j(pt) v_i(pt)\n         end\n      end\n   end\n   glb_mat += loc_mat\nend\n\n\n\n\nThere are three types of integrals that typically arise although many other,\nmore exotic, forms are possible:\n\n\n\n\nIntegrals involving Scalar basis functions: $\\int_\\Omega \\lambda\\, u v$\n\n\nIntegrals involving Vector basis functions: $\\int_\\Omega \\lambda\\, \\vec{u}\\cdot\\vec{v}$\n\n\nIntegrals involving Scalar and Vector basis functions: $\\int_\\Omega u\\,\\vec{\\lambda}\\cdot\\vec{v}$\n\n\n\n\nThe \nBilinearFormIntegrator\n classes allow MFEM to produce a wide variety of\nlocal element matrices without modifying the \nBilinearForm\n class.  Many of the\npossible operators are collected below into tables that briefly describe their\naction and requirements.\n\n\nIn the tables below the \nSpace\n column refers to finite element spaces which\nimplement the following methods:\n\n\n\n\n\n\n\n\nSpace\n\n\nOperator\n\n\nDerivative Operator\n\n\n\n\n\n\n\n\n\n\nH1\n\n\nCalcShape\n\n\nCalcDShape\n\n\n\n\n\n\nND\n\n\nCalcVShape\n\n\nCalcCurlShape\n\n\n\n\n\n\nRT\n\n\nCalcVShape\n\n\nCalcDivShape\n\n\n\n\n\n\nL2\n\n\nCalcShape\n\n\nNone\n\n\n\n\n\n\n\n\nThe \nCoef.\n column refers to the types of coefficients that are\navailable.  A boldface coefficient type is required whereas most\ncoefficients are optional.\n\n\n\n\n\n\n\n\nCoef.\n\n\nType\n\n\n\n\n\n\n\n\n\n\nS\n\n\nScalar Valued Function\n\n\n\n\n\n\nV\n\n\nVector Valued Function\n\n\n\n\n\n\nD\n\n\nDiagonal Matrix Function\n\n\n\n\n\n\nM\n\n\nGeneral Matrix Function\n\n\n\n\n\n\n\n\nNotation: The integrals performed by the various integrators listed\nbelow are shown using inner product notation, $(\\cdot,\\cdot)$, defined\nas follows.\n\n\n$$(\\lambda u, v)\\equiv \\int_\\Omega \\lambda u v$$\n$$(\\lambda\\vec{u}, \\vec{v})\\equiv \\int_\\Omega\\lambda\\vec{u}\\cdot\\vec{v}$$\n\n\nWhere $u$ or $\\vec{u}$ is a function in the domain (or trial) space and $v$\nor $\\vec{v}$ is in the range (or test) space.\nFor boundary integrators, the integrals are over $\\partial \\Omega$.\nFace integrators integrate over the interior and boundary faces of mesh elements\nand are denoted with $\\left\n\\cdot,\\cdot\\right\n$.\n\n\nNote that any operators involving a derivative of the range function\n$v$ or $\\vec{v}$ are computed using integration by parts.  This leads\nto a boundary integral which can be used to apply Neumann boundary\nconditions.  Some of these operators are listed along with their\nboundary terms in section \nWeak Operators\n.\n\n\nScalar Field Operators\n\n\nThese operators require scalar-valued trial spaces.  Many of these\noperators will work with either H1 or L2 basis functions but some that\nrequire a gradient operator should be used with H1.\n\n\nSquare Operators\n\n\nThese integrators are designed to be used with the BilinearForm object\nto assemble square linear operators.\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpaces\n\n\nCoef.\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nMassIntegrator\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda u, v)$\n\n\n$\\lambda u$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nDiffusionIntegrator\n\n\nH1\n\n\nS, M\n\n\n$(\\lambda\\grad u, \\grad v)$\n\n\n$-\\div(\\lambda\\grad u)$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\n\n\nMixed Operators\n\n\nThese integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators.\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nMixedScalarMassIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda u, v)$\n\n\n$\\lambda u$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nMixedScalarWeakDivergenceIntegrator\n\n\nH1, L2\n\n\nH1\n\n\nV\n\n\n$(-\\vec{\\lambda}u,\\grad v)$\n\n\n$\\div(\\vec{\\lambda}u)$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedScalarWeakDerivativeIntegrator\n\n\nH1, L2\n\n\nH1\n\n\nS\n\n\n$(-\\lambda u, \\ddx{v})$\n\n\n$\\ddx{}(\\lambda u)\\;$\n\n\n1D\n\n\n\n\n\n\nMixedScalarWeakCurlIntegrator\n\n\nH1, L2\n\n\nND\n\n\nS\n\n\n$(\\lambda u,\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\,u\\,\\hat{z})\\;$\n\n\n2D\n\n\n\n\n\n\nMixedVectorProductIntegrator\n\n\nH1, L2\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}u,\\vec{v})$\n\n\n$\\vec{\\lambda}u$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedScalarWeakCrossProductIntegrator\n\n\nH1, L2\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda} u\\,\\hat{z},\\vec{v})$\n\n\n$\\vec{\\lambda}\\times\\,\\hat{z}\\,u$\n\n\n2D\n\n\n\n\n\n\nMixedScalarWeakGradientIntegrator\n\n\nH1, L2\n\n\nRT\n\n\nS\n\n\n$(-\\lambda u, \\div\\vec{v})$\n\n\n$\\grad(\\lambda u)$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedDirectionalDerivativeIntegrator\n\n\nH1\n\n\nH1, L2\n\n\nV\n\n\n$(\\vec{\\lambda}\\cdot\\grad u, v)$\n\n\n$\\vec{\\lambda}\\cdot\\grad u$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedScalarCrossGradIntegrator\n\n\nH1\n\n\nH1, L2\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\grad u, v)$\n\n\n$\\vec{\\lambda}\\cross\\grad u$\n\n\n2D\n\n\n\n\n\n\nMixedScalarDerivativeIntegrator\n\n\nH1\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda \\ddx{u}, v)$\n\n\n$\\lambda\\ddx{u}\\;$\n\n\n1D\n\n\n\n\n\n\nMixedGradGradIntegrator\n\n\nH1\n\n\nH1\n\n\nS, D, M\n\n\n$(\\lambda\\grad u,\\grad v)$\n\n\n$-\\div(\\lambda\\grad u)$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedCrossGradGradIntegrator\n\n\nH1\n\n\nH1\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\grad u,\\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\cross\\grad u)$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedVectorGradientIntegrator\n\n\nH1\n\n\nND, RT\n\n\nS, D, M\n\n\n$(\\lambda\\grad u,\\vec{v})$\n\n\n$\\lambda\\grad u$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedCrossGradIntegrator\n\n\nH1\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\grad u,\\vec{v})$\n\n\n$\\vec{\\lambda}\\cross\\grad u$\n\n\n3D\n\n\n\n\n\n\nMixedCrossGradCurlIntegrator\n\n\nH1\n\n\nND\n\n\nV\n\n\n$(\\vec{\\lambda}\\times\\grad u, \\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\times\\grad u)$\n\n\n3D\n\n\n\n\n\n\nMixedGradDivIntegrator\n\n\nH1\n\n\nRT\n\n\nV\n\n\n$(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$\n\n\n$-\\grad(\\vec{\\lambda}\\cdot\\grad u)$\n\n\n2D, 3D\n\n\n\n\n\n\n\n\nOther Scalar Operators\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nDimension\n\n\nOperator\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nDerivativeIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\nS\n\n\n1D, 2D, 3D\n\n\n$(\\lambda\\frac{\\partial u}{\\partial x_i}, v)$\n\n\nThe direction index \"i\" is passed by the user. See \nMixedDirectionalDerivativeIntegrator\n for a more general alternative.\n\n\n\n\n\n\nConvectionIntegrator\n\n\nH1\n\n\nH1\n\n\nV\n\n\n1D, 2D, 3D\n\n\n$(\\vec{\\lambda}\\cdot\\grad u, v)$\n\n\nThis is designed to be used with \nBilinearForm\n to produce a square matrix. See \nMixedDirectionalDerivativeIntegrator\n for a rectangular version.\n\n\n\n\n\n\nGroupConvectionIntegrator\n\n\nH1\n\n\nH1\n\n\nV\n\n\n1D, 2D, 3D\n\n\n$(\\alpha\\vec{\\lambda}\\cdot\\grad u, v)$\n\n\nUses the \"group\" finite element formulation for advection due to \nFletcher\n.\n\n\n\n\n\n\nBoundaryMassIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\nS\n\n\n1D, 2D, 3D\n\n\n$(\\lambda\\,u,v)$\n\n\nComputes a mass matrix on the exterior faces of a domain. See \nMassIntegrator\n above for a more general version.\n\n\n\n\n\n\n\n\nVector Finite Element Operators\n\n\nThese operators require vector-valued basis functions in the trial\nspace.  Many of these operators will work with either ND or RT basis\nfunctions but others require one or the other.\n\n\nSquare Operators\n\n\nThese integrators are designed to be used with the BilinearForm object\nto assemble square linear operators.\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpaces\n\n\nCoef.\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nVectorFEMassIntegrator\n\n\nND, RT\n\n\nS, D, M\n\n\n$(\\lambda\\vec{u},\\vec{v})$\n\n\n$\\lambda\\vec{u}$\n\n\n2D, 3D\n\n\n\n\n\n\nCurlCurlIntegrator\n\n\nND\n\n\nS\n\n\n$(\\lambda\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\curl\\vec{u})$\n\n\n2D, 3D\n\n\n\n\n\n\nDivDivIntegrator\n\n\nRT\n\n\nS\n\n\n$(\\lambda\\div\\vec{u},\\div\\vec{v})$\n\n\n$-\\grad(\\lambda\\div\\vec{u})$\n\n\n2D, 3D\n\n\n\n\n\n\n\n\nMixed Operators\n\n\nThese integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators.\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nMixedDotProductIntegrator\n\n\nND, RT\n\n\nH1, L2\n\n\nV\n\n\n$(\\vec{\\lambda}\\cdot\\vec{u},v)$\n\n\n$\\vec{\\lambda}\\cdot\\vec{u}$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedScalarCrossProductIntegrator\n\n\nND, RT\n\n\nH1, L2\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},v)$\n\n\n$\\vec{\\lambda}\\cross\\vec{u}$\n\n\n2D\n\n\n\n\n\n\nMixedVectorWeakDivergenceIntegrator\n\n\nND, RT\n\n\nH1\n\n\nS, D, M\n\n\n$(-\\lambda\\vec{u},\\grad v)$\n\n\n$\\div(\\lambda\\vec{u})$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedWeakDivCrossIntegrator\n\n\nND, RT\n\n\nH1\n\n\nV\n\n\n$(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$\n\n\n$\\div(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedVectorMassIntegrator\n\n\nND, RT\n\n\nND, RT\n\n\nS, D, M\n\n\n$(\\lambda\\vec{u},\\vec{v})$\n\n\n$\\lambda\\vec{u}$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedCrossProductIntegrator\n\n\nND, RT\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},\\vec{v})$\n\n\n$\\vec{\\lambda}\\cross\\vec{u}$\n\n\n3D\n\n\n\n\n\n\nMixedVectorWeakCurlIntegrator\n\n\nND, RT\n\n\nND\n\n\nS, D, M\n\n\n$(\\lambda\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedWeakCurlCrossIntegrator\n\n\nND, RT\n\n\nND\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedScalarWeakCurlCrossIntegrator\n\n\nND, RT\n\n\nND\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n2D\n\n\n\n\n\n\nMixedWeakGradDotIntegrator\n\n\nND, RT\n\n\nRT\n\n\nV\n\n\n$(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$\n\n\n$\\grad(\\vec{\\lambda}\\cdot\\vec{u})$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedScalarCurlIntegrator\n\n\nND\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda\\curl\\vec{u},v)$\n\n\n$\\lambda\\curl\\vec{u}\\;$\n\n\n2D\n\n\n\n\n\n\nMixedCrossCurlGradIntegrator\n\n\nND\n\n\nH1\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedVectorCurlIntegrator\n\n\nND\n\n\nND, RT\n\n\nS, D, M\n\n\n$(\\lambda\\curl\\vec{u},\\vec{v})$\n\n\n$\\lambda\\curl\\vec{u}$\n\n\n3D\n\n\n\n\n\n\nMixedCrossCurlIntegrator\n\n\nND\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\curl\\vec{u},\\vec{v})$\n\n\n$\\vec{\\lambda}\\cross\\curl\\vec{u}$\n\n\n3D\n\n\n\n\n\n\nMixedScalarCrossCurlIntegrator\n\n\nND\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u},\\vec{v})$\n\n\n$\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u}$\n\n\n2D\n\n\n\n\n\n\nMixedCurlCurlIntegrator\n\n\nND\n\n\nND\n\n\nS, D, M\n\n\n$(\\lambda\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\curl\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedCrossCurlCurlIntegrator\n\n\nND\n\n\nND\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedScalarDivergenceIntegrator\n\n\nRT\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda\\div\\vec{u}, v)$\n\n\n$\\lambda \\div\\vec{u}$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedDivGradIntegrator\n\n\nRT\n\n\nH1\n\n\nV\n\n\n$(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\div\\vec{u})$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedVectorDivergenceIntegrator\n\n\nRT\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}\\div\\vec{u}, \\vec{v})$\n\n\n$\\vec{\\lambda}\\div\\vec{u}$\n\n\n2D, 3D\n\n\n\n\n\n\n\n\nOther Vector Finite Element Operators\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nOperator\n\n\nDimension\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nVectorFEDivergenceIntegrator\n\n\nRT\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda\\div\\vec{u}, v)$\n\n\n2D, 3D\n\n\nAlternate implementation of MixedScalarDivergenceIntegrator.\n\n\n\n\n\n\nVectorFEWeakDivergenceIntegrator\n\n\nND\n\n\nH1\n\n\nS\n\n\n$(-\\lambda\\vec{u},\\grad v)$\n\n\n2D, 3D\n\n\nSee MixedVectorWeakDivergenceIntegrator for a more general implementation.\n\n\n\n\n\n\nVectorFECurlIntegrator\n\n\nND, RT\n\n\nND, RT\n\n\nS\n\n\n$(\\lambda\\curl\\vec{u},\\vec{v})$ or $(\\lambda\\vec{u},\\curl\\vec{v})$\n\n\n3D\n\n\nIf the domain is ND then the Curl operator is returned, if the range is ND then the weak Curl is returned, otherwise a failure is encountered. See MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator for more general implementations.\n\n\n\n\n\n\n\n\nVector Field Operators\n\n\nThese operators require vector-valued basis functions constructed by\nusing multiple copies of scalar fields.  In each of these integrators\nthe scalar basis function index increments most quickly followed by\nthe vector index.  This leads to local element matrix which have a\nblock structure.\n\n\nSquare Operators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpaces\n\n\nCoef.\n\n\nDimension\n\n\nOperator\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nVectorMassIntegrator\n\n\n$H_1^d$, $L_2^d$\n\n\nS, D, M\n\n\n1D, 2D, 3D\n\n\n$(\\lambda\\vec{u},\\vec{v})$\n\n\n\n\n\n\n\n\nVectorCurlCurlIntegrator\n\n\n$H_1^d$, $L_2^d$\n\n\nS\n\n\n2D, 3D\n\n\n$(\\lambda\\curl\\vec{u},\\curl\\vec{v})$\n\n\n\n\n\n\n\n\nVectorDiffusionIntegrator\n\n\n$H_1^d$, $L_2^d$\n\n\nS\n\n\n1D, 2D, 3D\n\n\n$(\\lambda\\grad u_i,\\grad v_i)$\n\n\nProduces a block diagonal matrix where $i\\in[0,dim)$ indicates the index of the block\n\n\n\n\n\n\nElasticityIntegrator\n\n\n$H_1^d$, $L_2^d$\n\n\n$2\\times$S\n\n\n1D, 2D, 3D\n\n\n$(c_{ikjl}\\grad u_j,\\grad v_i)$\n\n\nTakes two scalar coefficients $\\lambda$ and $\\mu$ and produces a $dim\\times dim$ block structured matrix where $i$ and $j$ are indices in this matrix.  The coefficient is defined by $c_{ikjl} = \\lambda\\delta_{ik}\\delta_{jl}+\\mu(\\delta_{ij}\\delta_{kl}+\\delta_{il}\\delta_{jk})$\n\n\n\n\n\n\n\n\nMixed Operators\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nDimension\n\n\nOperator\n\n\n\n\n\n\n\n\n\n\nVectorDivergenceIntegrator\n\n\n$H_1^d$, $L_2^d$\n\n\nH1, L2\n\n\nS\n\n\n1D, 2D, 3D\n\n\n$(\\lambda\\div\\vec{u},v)$\n\n\n\n\n\n\n\n\nDiscontinuous Galerkin Operators\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nOperator\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nDGTraceIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\n$\\alpha \\left\n\\rho_u(\\vec{u}\\cdot\\hat{n}) \\{v\\},[w]\\right\n \\\\ + \\beta \\left\n\\rho_u \\abs{\\vec{u}\\cdot\\hat{n}}[v],[w]\\right\n$\n\n\n\n\n\n\n\n\nDGDiffusionIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\n$-\\left\n\\{Q\\grad u\\cdot\\hat{n}\\},[v]\\right\n \\\\ + \\sigma \\left\n[u],\\{Q\\grad v\\cdot\\hat{n}\\}\\right\n \\\\ + \\kappa \\left\n\\{h^{-1}Q\\}[u],[v]\\right\n $\n\n\n\n\n\n\n\n\nDGElasticityIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\nsee $(\\ref{dg-elast})$\n\n\n\n\n\n\n\n\nTraceJumpIntegrator\n\n\n\n\n\n\n$\\left\n v, [w] \\right\n$\n\n\n\n\n\n\n\n\nNormalTraceJumpIntegrator\n\n\n\n\n\n\n$\\left\n v, \\left[\\vec{w}\\cdot \\vec{n}\\right] \\right\n$\n\n\n\n\n\n\n\n\n\n\nIntegrator for the DG elasticity form, for the formulations see:\n\n\n\n\nPhD Thesis of Jonas De Basabe, High-Order Finite Element Methods for\n  Seismic Wave Propagation, UT Austin, 2009, p. 23, and references therein\n\n\nPeter Hansbo and Mats G. Larson, Discontinuous Galerkin and the\n  Crouzeix-Raviart Element: Application to Elasticity, PREPRINT 2000-09,\n  p.3\n\n\n\n\n$$\n- \\left\n \\{ \\tau(u) \\}, [v] \\right\n + \\alpha \\left\n \\{ \\tau(v) \\}, [u]\n        \\right\n + \\kappa \\left\n h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right\n\n$$\n\n\nwhere $ \\left\n u, v\\right\n = \\int_{F} u \\cdot v $, and $ F $ is a\n    face which is either a boundary face $ F_b $ of an element $ K $ or\n    an interior face $ F_i $ separating elements $ K_1 $ and $ K_2 $.\n\n\nIn the bilinear form above $ \\tau(u) $ is traction, and it's also\n    $ \\tau(u) = \\sigma(u) \\cdot \\vec{n} $, where $ \\sigma(u) $ is\n    stress, and $ \\vec{n} $ is the unit normal vector w.r.t. to $ F $.\n\n\nIn other words, we have\n    $$\\label{dg-elast}\n    - \\left\n \\{ \\sigma(u) \\cdot \\vec{n} \\}, [v] \\right\n + \\alpha \\left\n \\{\n        \\sigma(v) \\cdot \\vec{n} \\}, [u] \\right\n + \\kappa \\left\n h^{-1} \\{\n        \\lambda + 2 \\mu \\} [u], [v] \\right\n\n    $$\n\n\nFor isotropic media\n    $$\n    \\begin{split}\n    \\sigma(u) \n= \\lambda \\nabla \\cdot u I + 2 \\mu \\varepsilon(u) \\\\\n              \n= \\lambda \\nabla \\cdot u I + 2 \\mu \\frac{1}{2} \\left( \\nabla u +\n             \\nabla u^T \\right) \\\\\n              \n= \\lambda \\nabla \\cdot u I + \\mu \\left( \\nabla u + \\nabla u^T\n             \\right)\n    \\end{split}\n    $$\n\n\nwhere $ I $ is identity matrix, $ \\lambda $ and $ \\mu $ are Lame\n    coefficients (see ElasticityIntegrator), $ u, v $ are the trial and test\n    functions, respectively.\n\n\nThe parameters $ \\alpha $ and $ \\kappa $ determine the DG method to\nuse (when this integrator is added to the \"broken\" ElasticityIntegrator):\n\n\n\n\n\n\nIIPG\n, $\\alpha = 0$,\n  C. Dawson, S. Sun, M. Wheeler, Compatible algorithms for coupled flow and\n  transport, Comp. Meth. Appl. Mech. Eng., 193(23-26), 2565-2580, 2004.\n\n\n\n\n\n\nSIPG\n, $\\alpha = -1$,\n  M. Grote, A. Schneebeli, D. Schotzau, Discontinuous Galerkin Finite\n  Element Method for the Wave Equation, SINUM, 44(6), 2408-2431, 2006.\n\n\n\n\n\n\nNIPG\n, $\\alpha = 1$,\n  B. Riviere, M. Wheeler, V. Girault, A Priori Error Estimates for Finite\n  Element Methods Based on Discontinuous Approximation Spaces for Elliptic\n  Problems, SINUM, 39(3), 902-931, 2001.\n\n\n\n\n\n\nThis is a 'Vector' integrator, i.e. defined for FE spaces using multiple\ncopies of a scalar FE space.\n\n\nSpecial Purpose Integrators\n\n\nThese \"integrators\" do not actually perform integrations they merely\nalter the results of other integrators.  As such they provide a\nconvenient and easy way to reuse existing integrators in special\nsituations rather than needing to reimplement their functionality.\n\n\n\n\n\n\n\n\nClass Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTransposeIntegrator\n\n\nReturns the transpose of the local matrix computed by another BilinearFormIntegrator\n\n\n\n\n\n\nLumpedIntegrator\n\n\nReturns a diagonal local matrix where each entry is the sum of the corresponding row of a local matrix computed by another BilinearFormIntegrator (only implemented for square matrices)\n\n\n\n\n\n\nInverseIntegrator\n\n\nReturns the inverse of the local matrix computed by another BilinearFormIntegrator which produces a square local matrix\n\n\n\n\n\n\nSumIntegrator\n\n\nReturns the sum of a series of integrators with compatible dimensions (only implemented for square matrices)\n\n\n\n\n\n\n\n\nWeak Operators and Their Boundary Integrals\n\n\nWeak operators use integration by parts to move a spatial derivative\nonto the test function.  This results in an implied boundary integral\nthat is often assumed to be zero but can be used to apply an\nnon-homogeneous Neumann boundary condition.\n\n\nOperator with Scalar Range\n\n\nThe following weak operators require the range (or test) space to be\n$H_1$ i.e. a scalar basis function with a gradient operator.  The implied\nnatural boundary condition when using these operators is for the\ncontinuous boundary operator (shown in the last column) to be equal to\nzero.  On the other hand an inhomogeneous Neumann boundary condition\ncan be applied by using a linear form boundary integrator to compute\nthis boundary term for a known function e.g. when using the\n\nDiffusionIntegrator\n one could provide a known function for\n$\\lambda\\,\\grad u$ to the \nBoundaryNormalLFIntegrator\n which would\nthen integrate the normal component of this function over the boundary\nof the domain.  See \nLinear Form Integrators\n for more\ninformation.\n\n\n\n\n\n\n\n\nClass Name\n\n\nOperator\n\n\nContinuous Op.\n\n\nContinuous Boundary Op.\n\n\n\n\n\n\n\n\n\n\nDiffusionIntegrator\n\n\n$(\\lambda\\grad u, \\grad v)$\n\n\n$-\\div(\\lambda\\grad u)$\n\n\n$\\lambda\\,\\hat{n}\\cdot\\grad u$\n\n\n\n\n\n\nMixedGradGradIntegrator\n\n\n$(\\lambda\\grad u, \\grad v)$\n\n\n$-\\div(\\lambda\\grad u)$\n\n\n$\\lambda\\,\\hat{n}\\cdot\\grad u$\n\n\n\n\n\n\nMixedCrossGradGradIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\grad u,\\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\cross\\grad u)$\n\n\n$\\hat{n}\\cdot(\\vec{\\lambda}\\times\\grad u)$\n\n\n\n\n\n\nMixedScalarWeakDivergenceIntegrator\n\n\n$(-\\vec{\\lambda}u,\\grad v)$\n\n\n$\\div(\\vec{\\lambda}u)$\n\n\n$-\\hat{n}\\cdot\\vec{\\lambda}\\,u$\n\n\n\n\n\n\nMixedScalarWeakDerivativeIntegrator\n\n\n$(-\\lambda u, \\ddx{v})$\n\n\n$\\ddx{}(\\lambda u)\\;$\n\n\n$-\\hat{n}\\cdot\\hat{x}\\,\\lambda\\,u$\n\n\n\n\n\n\nMixedVectorWeakDivergenceIntegrator\n\n\n$(-\\lambda\\vec{u},\\grad v)$\n\n\n$\\div(\\lambda\\vec{u})$\n\n\n$-\\hat{n}\\cdot(\\lambda\\,\\vec{u})$\n\n\n\n\n\n\nMixedWeakDivCrossIntegrator\n\n\n$(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$\n\n\n$\\div(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n$-\\hat{n}\\cdot(\\vec{\\lambda}\\times\\vec{u})$\n\n\n\n\n\n\nMixedCrossCurlGradIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n$\\hat{n}\\cdot(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n\n\n\n\nMixedDivGradIntegrator\n\n\n$(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\div\\vec{u})$\n\n\n$\\hat{n}\\cdot(\\vec{\\lambda}\\div\\vec{u})$\n\n\n\n\n\n\n\n\nOperator with Vector Range\n\n\nThe following weak operators require the range (or test) space to be\nH(Curl) i.e. a vector basis function with a curl operator.  The\nimplied natural boundary condition when using these operators is for\nthe continuous boundary operator (shown in the last column) to be\nequal to zero.  On the other hand an non-homogeneous Neumann boundary\ncondition can be applied by using a linear form boundary integrator to\ncompute this boundary term for a known function e.g. when using the\n\nCurlCurlIntegrator\n one could provide a known function for\n$\\lambda\\,\\curl\\vec{u}$ to the \nVectorFEBoundaryTangentLFIntegrator\n\nwhich would then integrate the product of the tangential portion of\nthis function with that of the ND basis function over the boundary of\nthe domain.  See \nLinear Form Integrators\n for more\ninformation.\n\n\n\n\n\n\n\n\nClass Name\n\n\nOperator\n\n\nContinuous Op.\n\n\nContinuous Boundary Op.\n\n\n\n\n\n\n\n\n\n\nCurlCurlIntegrator\n\n\n$(\\lambda\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\curl\\vec{u})$\n\n\n$\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$\n\n\n\n\n\n\nMixedCurlCurlIntegrator\n\n\n$(\\lambda\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\curl\\vec{u})$\n\n\n$\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$\n\n\n\n\n\n\nMixedCrossCurlCurlIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n$\\hat{n}\\times(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n\n\n\n\nMixedCrossGradCurlIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\grad u,\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\grad u)$\n\n\n$\\hat{n}\\times(\\vec{\\lambda}\\cross\\grad u)$\n\n\n\n\n\n\nMixedVectorWeakCurlIntegrator\n\n\n$(\\lambda\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\vec{u})$\n\n\n$\\lambda\\,\\hat{n}\\times\\vec{u}$\n\n\n\n\n\n\nMixedScalarWeakCurlIntegrator\n\n\n$(\\lambda u,\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\,u\\,\\hat{z})\\;$\n\n\n$\\lambda\\,u\\,\\hat{n}\\times\\hat{z}$\n\n\n\n\n\n\nMixedWeakCurlCrossIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n$\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n\n\n\n\nMixedScalarWeakCurlCrossIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n$\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n\n\n\n\n\n\nThe following weak operators require the range (or test) space to be\nH(Div) i.e. a vector basis function with a divergence operator.  The\nimplied natural boundary condition when using these operators is for\nthe continuous boundary operator (shown in the last column) to be\nequal to zero.  On the other hand an non-homogeneous Neumann boundary\ncondition can be applied by using a linear form boundary integrator to\ncompute this boundary term for a known function e.g. when using the\n\nDivDivIntegrator\n one could provide a known function for\n$\\lambda\\,\\div\\vec{u}$ to the \nVectorFEBoundaryFluxLFIntegrator\n\nwhich would then integrate the product of this function with the\nnormal component of the RT basis function over the boundary of the\ndomain.  See \nLinear Form Integrators\n for more\ninformation.\n\n\n\n\n\n\n\n\nClass Name\n\n\nOperator\n\n\nContinuous Op.\n\n\nContinuous Boundary Op.\n\n\n\n\n\n\n\n\n\n\nDivDivIntegrator\n\n\n$(\\lambda\\div\\vec{u},\\div\\vec{v})$\n\n\n$-\\grad(\\lambda\\div\\vec{u})$\n\n\n$\\lambda\\div\\vec{u}\\,\\hat{n}$\n\n\n\n\n\n\nMixedGradDivIntegrator\n\n\n$(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$\n\n\n$-\\grad(\\vec{\\lambda}\\cdot\\grad u)$\n\n\n$\\vec{\\lambda}\\cdot\\grad u\\,\\hat{n}$\n\n\n\n\n\n\nMixedScalarWeakGradientIntegrator\n\n\n$(-\\lambda u, \\div\\vec{v})$\n\n\n$\\grad(\\lambda u)$\n\n\n$-\\lambda u\\,\\hat{n}$\n\n\n\n\n\n\nMixedWeakGradDotIntegrator\n\n\n$(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$\n\n\n$\\grad(\\vec{\\lambda}\\cdot\\vec{u})$\n\n\n$-\\vec{\\lambda}\\cdot\\vec{u}\\,\\hat{n}$\n\n\n\n\n\n\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "_Bilinear Form Integrators"
        }, 
        {
            "location": "/bilininteg/#bilinear-form-integrators", 
            "text": "$\n\\newcommand{\\cross}{\\times}\n\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\n\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}\n\\newcommand{\\ddx}[1]{\\frac{d#1}{dx}}\n\\newcommand{\\abs}[1]{|#1|}\n$  Bilinear form integrators are at the heart of any finite element method, they\nare used to compute the integrals of products of basis functions over individual\nmesh elements (or sometimes over edges or faces).  Typically each element is\ncontained in the support of several basis functions of both the domain and range\nspaces, therefore bilinear integrators simultaneously compute the integrals of\nall combinations of the relevant basis functions from the domain and range\nspaces.  This produces a two dimensional array of results that are arranged into\na small dense matrix of integral values called a  local element (stiffness)\nmatrix .  To put this another way, the  BilinearForm  class builds a global, sparse,\nfinite element matrix,  glb_mat , by performing the outer loop in the following\npseudocode snippet whereas the  BilinearFormIntegrator  class performs the\nnested inner loops to compute the dense local element matrix,  loc_mat .  for each elem in elements\n   loc_mat = 0.0\n   for each pt in quadrature_points\n      for each u_j in elem\n         for each v_i in elem\n            loc_mat(i,j) += w(pt) * u_j(pt) v_i(pt)\n         end\n      end\n   end\n   glb_mat += loc_mat\nend  There are three types of integrals that typically arise although many other,\nmore exotic, forms are possible:   Integrals involving Scalar basis functions: $\\int_\\Omega \\lambda\\, u v$  Integrals involving Vector basis functions: $\\int_\\Omega \\lambda\\, \\vec{u}\\cdot\\vec{v}$  Integrals involving Scalar and Vector basis functions: $\\int_\\Omega u\\,\\vec{\\lambda}\\cdot\\vec{v}$   The  BilinearFormIntegrator  classes allow MFEM to produce a wide variety of\nlocal element matrices without modifying the  BilinearForm  class.  Many of the\npossible operators are collected below into tables that briefly describe their\naction and requirements.  In the tables below the  Space  column refers to finite element spaces which\nimplement the following methods:     Space  Operator  Derivative Operator      H1  CalcShape  CalcDShape    ND  CalcVShape  CalcCurlShape    RT  CalcVShape  CalcDivShape    L2  CalcShape  None     The  Coef.  column refers to the types of coefficients that are\navailable.  A boldface coefficient type is required whereas most\ncoefficients are optional.     Coef.  Type      S  Scalar Valued Function    V  Vector Valued Function    D  Diagonal Matrix Function    M  General Matrix Function     Notation: The integrals performed by the various integrators listed\nbelow are shown using inner product notation, $(\\cdot,\\cdot)$, defined\nas follows.  $$(\\lambda u, v)\\equiv \\int_\\Omega \\lambda u v$$\n$$(\\lambda\\vec{u}, \\vec{v})\\equiv \\int_\\Omega\\lambda\\vec{u}\\cdot\\vec{v}$$  Where $u$ or $\\vec{u}$ is a function in the domain (or trial) space and $v$\nor $\\vec{v}$ is in the range (or test) space.\nFor boundary integrators, the integrals are over $\\partial \\Omega$.\nFace integrators integrate over the interior and boundary faces of mesh elements\nand are denoted with $\\left \\cdot,\\cdot\\right $.  Note that any operators involving a derivative of the range function\n$v$ or $\\vec{v}$ are computed using integration by parts.  This leads\nto a boundary integral which can be used to apply Neumann boundary\nconditions.  Some of these operators are listed along with their\nboundary terms in section  Weak Operators .", 
            "title": "Bilinear Form Integrators"
        }, 
        {
            "location": "/bilininteg/#scalar-field-operators", 
            "text": "These operators require scalar-valued trial spaces.  Many of these\noperators will work with either H1 or L2 basis functions but some that\nrequire a gradient operator should be used with H1.", 
            "title": "Scalar Field Operators"
        }, 
        {
            "location": "/bilininteg/#square-operators", 
            "text": "These integrators are designed to be used with the BilinearForm object\nto assemble square linear operators.     Class Name  Spaces  Coef.  Operator  Continuous Op.  Dimension      MassIntegrator  H1, L2  S  $(\\lambda u, v)$  $\\lambda u$  1D, 2D, 3D    DiffusionIntegrator  H1  S, M  $(\\lambda\\grad u, \\grad v)$  $-\\div(\\lambda\\grad u)$  1D, 2D, 3D", 
            "title": "Square Operators"
        }, 
        {
            "location": "/bilininteg/#mixed-operators", 
            "text": "These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators.     Class Name  Domain  Range  Coef.  Operator  Continuous Op.  Dimension      MixedScalarMassIntegrator  H1, L2  H1, L2  S  $(\\lambda u, v)$  $\\lambda u$  1D, 2D, 3D    MixedScalarWeakDivergenceIntegrator  H1, L2  H1  V  $(-\\vec{\\lambda}u,\\grad v)$  $\\div(\\vec{\\lambda}u)$  2D, 3D    MixedScalarWeakDerivativeIntegrator  H1, L2  H1  S  $(-\\lambda u, \\ddx{v})$  $\\ddx{}(\\lambda u)\\;$  1D    MixedScalarWeakCurlIntegrator  H1, L2  ND  S  $(\\lambda u,\\curl\\vec{v})$  $\\curl(\\lambda\\,u\\,\\hat{z})\\;$  2D    MixedVectorProductIntegrator  H1, L2  ND, RT  V  $(\\vec{\\lambda}u,\\vec{v})$  $\\vec{\\lambda}u$  2D, 3D    MixedScalarWeakCrossProductIntegrator  H1, L2  ND, RT  V  $(\\vec{\\lambda} u\\,\\hat{z},\\vec{v})$  $\\vec{\\lambda}\\times\\,\\hat{z}\\,u$  2D    MixedScalarWeakGradientIntegrator  H1, L2  RT  S  $(-\\lambda u, \\div\\vec{v})$  $\\grad(\\lambda u)$  2D, 3D    MixedDirectionalDerivativeIntegrator  H1  H1, L2  V  $(\\vec{\\lambda}\\cdot\\grad u, v)$  $\\vec{\\lambda}\\cdot\\grad u$  2D, 3D    MixedScalarCrossGradIntegrator  H1  H1, L2  V  $(\\vec{\\lambda}\\cross\\grad u, v)$  $\\vec{\\lambda}\\cross\\grad u$  2D    MixedScalarDerivativeIntegrator  H1  H1, L2  S  $(\\lambda \\ddx{u}, v)$  $\\lambda\\ddx{u}\\;$  1D    MixedGradGradIntegrator  H1  H1  S, D, M  $(\\lambda\\grad u,\\grad v)$  $-\\div(\\lambda\\grad u)$  2D, 3D    MixedCrossGradGradIntegrator  H1  H1  V  $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$  $-\\div(\\vec{\\lambda}\\cross\\grad u)$  2D, 3D    MixedVectorGradientIntegrator  H1  ND, RT  S, D, M  $(\\lambda\\grad u,\\vec{v})$  $\\lambda\\grad u$  2D, 3D    MixedCrossGradIntegrator  H1  ND, RT  V  $(\\vec{\\lambda}\\cross\\grad u,\\vec{v})$  $\\vec{\\lambda}\\cross\\grad u$  3D    MixedCrossGradCurlIntegrator  H1  ND  V  $(\\vec{\\lambda}\\times\\grad u, \\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\times\\grad u)$  3D    MixedGradDivIntegrator  H1  RT  V  $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$  $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$  2D, 3D", 
            "title": "Mixed Operators"
        }, 
        {
            "location": "/bilininteg/#other-scalar-operators", 
            "text": "Class Name  Domain  Range  Coef.  Dimension  Operator  Notes      DerivativeIntegrator  H1, L2  H1, L2  S  1D, 2D, 3D  $(\\lambda\\frac{\\partial u}{\\partial x_i}, v)$  The direction index \"i\" is passed by the user. See  MixedDirectionalDerivativeIntegrator  for a more general alternative.    ConvectionIntegrator  H1  H1  V  1D, 2D, 3D  $(\\vec{\\lambda}\\cdot\\grad u, v)$  This is designed to be used with  BilinearForm  to produce a square matrix. See  MixedDirectionalDerivativeIntegrator  for a rectangular version.    GroupConvectionIntegrator  H1  H1  V  1D, 2D, 3D  $(\\alpha\\vec{\\lambda}\\cdot\\grad u, v)$  Uses the \"group\" finite element formulation for advection due to  Fletcher .    BoundaryMassIntegrator  H1, L2  H1, L2  S  1D, 2D, 3D  $(\\lambda\\,u,v)$  Computes a mass matrix on the exterior faces of a domain. See  MassIntegrator  above for a more general version.", 
            "title": "Other Scalar Operators"
        }, 
        {
            "location": "/bilininteg/#vector-finite-element-operators", 
            "text": "These operators require vector-valued basis functions in the trial\nspace.  Many of these operators will work with either ND or RT basis\nfunctions but others require one or the other.", 
            "title": "Vector Finite Element Operators"
        }, 
        {
            "location": "/bilininteg/#square-operators_1", 
            "text": "These integrators are designed to be used with the BilinearForm object\nto assemble square linear operators.     Class Name  Spaces  Coef.  Operator  Continuous Op.  Dimension      VectorFEMassIntegrator  ND, RT  S, D, M  $(\\lambda\\vec{u},\\vec{v})$  $\\lambda\\vec{u}$  2D, 3D    CurlCurlIntegrator  ND  S  $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\curl\\vec{u})$  2D, 3D    DivDivIntegrator  RT  S  $(\\lambda\\div\\vec{u},\\div\\vec{v})$  $-\\grad(\\lambda\\div\\vec{u})$  2D, 3D", 
            "title": "Square Operators"
        }, 
        {
            "location": "/bilininteg/#mixed-operators_1", 
            "text": "These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators.     Class Name  Domain  Range  Coef.  Operator  Continuous Op.  Dimension      MixedDotProductIntegrator  ND, RT  H1, L2  V  $(\\vec{\\lambda}\\cdot\\vec{u},v)$  $\\vec{\\lambda}\\cdot\\vec{u}$  2D, 3D    MixedScalarCrossProductIntegrator  ND, RT  H1, L2  V  $(\\vec{\\lambda}\\cross\\vec{u},v)$  $\\vec{\\lambda}\\cross\\vec{u}$  2D    MixedVectorWeakDivergenceIntegrator  ND, RT  H1  S, D, M  $(-\\lambda\\vec{u},\\grad v)$  $\\div(\\lambda\\vec{u})$  2D, 3D    MixedWeakDivCrossIntegrator  ND, RT  H1  V  $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$  $\\div(\\vec{\\lambda}\\cross\\vec{u})$  3D    MixedVectorMassIntegrator  ND, RT  ND, RT  S, D, M  $(\\lambda\\vec{u},\\vec{v})$  $\\lambda\\vec{u}$  2D, 3D    MixedCrossProductIntegrator  ND, RT  ND, RT  V  $(\\vec{\\lambda}\\cross\\vec{u},\\vec{v})$  $\\vec{\\lambda}\\cross\\vec{u}$  3D    MixedVectorWeakCurlIntegrator  ND, RT  ND  S, D, M  $(\\lambda\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\vec{u})$  3D    MixedWeakCurlCrossIntegrator  ND, RT  ND  V  $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\vec{u})$  3D    MixedScalarWeakCurlCrossIntegrator  ND, RT  ND  V  $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\vec{u})$  2D    MixedWeakGradDotIntegrator  ND, RT  RT  V  $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$  $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$  2D, 3D    MixedScalarCurlIntegrator  ND  H1, L2  S  $(\\lambda\\curl\\vec{u},v)$  $\\lambda\\curl\\vec{u}\\;$  2D    MixedCrossCurlGradIntegrator  ND  H1  V  $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$  $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$  3D    MixedVectorCurlIntegrator  ND  ND, RT  S, D, M  $(\\lambda\\curl\\vec{u},\\vec{v})$  $\\lambda\\curl\\vec{u}$  3D    MixedCrossCurlIntegrator  ND  ND, RT  V  $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\vec{v})$  $\\vec{\\lambda}\\cross\\curl\\vec{u}$  3D    MixedScalarCrossCurlIntegrator  ND  ND, RT  V  $(\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u},\\vec{v})$  $\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u}$  2D    MixedCurlCurlIntegrator  ND  ND  S, D, M  $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\curl\\vec{u})$  3D    MixedCrossCurlCurlIntegrator  ND  ND  V  $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$  3D    MixedScalarDivergenceIntegrator  RT  H1, L2  S  $(\\lambda\\div\\vec{u}, v)$  $\\lambda \\div\\vec{u}$  2D, 3D    MixedDivGradIntegrator  RT  H1  V  $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$  $-\\div(\\vec{\\lambda}\\div\\vec{u})$  2D, 3D    MixedVectorDivergenceIntegrator  RT  ND, RT  V  $(\\vec{\\lambda}\\div\\vec{u}, \\vec{v})$  $\\vec{\\lambda}\\div\\vec{u}$  2D, 3D", 
            "title": "Mixed Operators"
        }, 
        {
            "location": "/bilininteg/#other-vector-finite-element-operators", 
            "text": "Class Name  Domain  Range  Coef.  Operator  Dimension  Notes      VectorFEDivergenceIntegrator  RT  H1, L2  S  $(\\lambda\\div\\vec{u}, v)$  2D, 3D  Alternate implementation of MixedScalarDivergenceIntegrator.    VectorFEWeakDivergenceIntegrator  ND  H1  S  $(-\\lambda\\vec{u},\\grad v)$  2D, 3D  See MixedVectorWeakDivergenceIntegrator for a more general implementation.    VectorFECurlIntegrator  ND, RT  ND, RT  S  $(\\lambda\\curl\\vec{u},\\vec{v})$ or $(\\lambda\\vec{u},\\curl\\vec{v})$  3D  If the domain is ND then the Curl operator is returned, if the range is ND then the weak Curl is returned, otherwise a failure is encountered. See MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator for more general implementations.", 
            "title": "Other Vector Finite Element Operators"
        }, 
        {
            "location": "/bilininteg/#vector-field-operators", 
            "text": "These operators require vector-valued basis functions constructed by\nusing multiple copies of scalar fields.  In each of these integrators\nthe scalar basis function index increments most quickly followed by\nthe vector index.  This leads to local element matrix which have a\nblock structure.", 
            "title": "Vector Field Operators"
        }, 
        {
            "location": "/bilininteg/#square-operators_2", 
            "text": "Class Name  Spaces  Coef.  Dimension  Operator  Notes      VectorMassIntegrator  $H_1^d$, $L_2^d$  S, D, M  1D, 2D, 3D  $(\\lambda\\vec{u},\\vec{v})$     VectorCurlCurlIntegrator  $H_1^d$, $L_2^d$  S  2D, 3D  $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$     VectorDiffusionIntegrator  $H_1^d$, $L_2^d$  S  1D, 2D, 3D  $(\\lambda\\grad u_i,\\grad v_i)$  Produces a block diagonal matrix where $i\\in[0,dim)$ indicates the index of the block    ElasticityIntegrator  $H_1^d$, $L_2^d$  $2\\times$S  1D, 2D, 3D  $(c_{ikjl}\\grad u_j,\\grad v_i)$  Takes two scalar coefficients $\\lambda$ and $\\mu$ and produces a $dim\\times dim$ block structured matrix where $i$ and $j$ are indices in this matrix.  The coefficient is defined by $c_{ikjl} = \\lambda\\delta_{ik}\\delta_{jl}+\\mu(\\delta_{ij}\\delta_{kl}+\\delta_{il}\\delta_{jk})$", 
            "title": "Square Operators"
        }, 
        {
            "location": "/bilininteg/#mixed-operators_2", 
            "text": "Class Name  Domain  Range  Coef.  Dimension  Operator      VectorDivergenceIntegrator  $H_1^d$, $L_2^d$  H1, L2  S  1D, 2D, 3D  $(\\lambda\\div\\vec{u},v)$", 
            "title": "Mixed Operators"
        }, 
        {
            "location": "/bilininteg/#discontinuous-galerkin-operators", 
            "text": "Class Name  Domain  Range  Operator  Notes      DGTraceIntegrator  H1, L2  H1, L2  $\\alpha \\left \\rho_u(\\vec{u}\\cdot\\hat{n}) \\{v\\},[w]\\right  \\\\ + \\beta \\left \\rho_u \\abs{\\vec{u}\\cdot\\hat{n}}[v],[w]\\right $     DGDiffusionIntegrator  H1, L2  H1, L2  $-\\left \\{Q\\grad u\\cdot\\hat{n}\\},[v]\\right  \\\\ + \\sigma \\left [u],\\{Q\\grad v\\cdot\\hat{n}\\}\\right  \\\\ + \\kappa \\left \\{h^{-1}Q\\}[u],[v]\\right  $     DGElasticityIntegrator  H1, L2  H1, L2  see $(\\ref{dg-elast})$     TraceJumpIntegrator    $\\left  v, [w] \\right $     NormalTraceJumpIntegrator    $\\left  v, \\left[\\vec{w}\\cdot \\vec{n}\\right] \\right $      Integrator for the DG elasticity form, for the formulations see:   PhD Thesis of Jonas De Basabe, High-Order Finite Element Methods for\n  Seismic Wave Propagation, UT Austin, 2009, p. 23, and references therein  Peter Hansbo and Mats G. Larson, Discontinuous Galerkin and the\n  Crouzeix-Raviart Element: Application to Elasticity, PREPRINT 2000-09,\n  p.3   $$\n- \\left  \\{ \\tau(u) \\}, [v] \\right  + \\alpha \\left  \\{ \\tau(v) \\}, [u]\n        \\right  + \\kappa \\left  h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right \n$$  where $ \\left  u, v\\right  = \\int_{F} u \\cdot v $, and $ F $ is a\n    face which is either a boundary face $ F_b $ of an element $ K $ or\n    an interior face $ F_i $ separating elements $ K_1 $ and $ K_2 $.  In the bilinear form above $ \\tau(u) $ is traction, and it's also\n    $ \\tau(u) = \\sigma(u) \\cdot \\vec{n} $, where $ \\sigma(u) $ is\n    stress, and $ \\vec{n} $ is the unit normal vector w.r.t. to $ F $.  In other words, we have\n    $$\\label{dg-elast}\n    - \\left  \\{ \\sigma(u) \\cdot \\vec{n} \\}, [v] \\right  + \\alpha \\left  \\{\n        \\sigma(v) \\cdot \\vec{n} \\}, [u] \\right  + \\kappa \\left  h^{-1} \\{\n        \\lambda + 2 \\mu \\} [u], [v] \\right \n    $$  For isotropic media\n    $$\n    \\begin{split}\n    \\sigma(u)  = \\lambda \\nabla \\cdot u I + 2 \\mu \\varepsilon(u) \\\\\n               = \\lambda \\nabla \\cdot u I + 2 \\mu \\frac{1}{2} \\left( \\nabla u +\n             \\nabla u^T \\right) \\\\\n               = \\lambda \\nabla \\cdot u I + \\mu \\left( \\nabla u + \\nabla u^T\n             \\right)\n    \\end{split}\n    $$  where $ I $ is identity matrix, $ \\lambda $ and $ \\mu $ are Lame\n    coefficients (see ElasticityIntegrator), $ u, v $ are the trial and test\n    functions, respectively.  The parameters $ \\alpha $ and $ \\kappa $ determine the DG method to\nuse (when this integrator is added to the \"broken\" ElasticityIntegrator):    IIPG , $\\alpha = 0$,\n  C. Dawson, S. Sun, M. Wheeler, Compatible algorithms for coupled flow and\n  transport, Comp. Meth. Appl. Mech. Eng., 193(23-26), 2565-2580, 2004.    SIPG , $\\alpha = -1$,\n  M. Grote, A. Schneebeli, D. Schotzau, Discontinuous Galerkin Finite\n  Element Method for the Wave Equation, SINUM, 44(6), 2408-2431, 2006.    NIPG , $\\alpha = 1$,\n  B. Riviere, M. Wheeler, V. Girault, A Priori Error Estimates for Finite\n  Element Methods Based on Discontinuous Approximation Spaces for Elliptic\n  Problems, SINUM, 39(3), 902-931, 2001.    This is a 'Vector' integrator, i.e. defined for FE spaces using multiple\ncopies of a scalar FE space.", 
            "title": "Discontinuous Galerkin Operators"
        }, 
        {
            "location": "/bilininteg/#special-purpose-integrators", 
            "text": "These \"integrators\" do not actually perform integrations they merely\nalter the results of other integrators.  As such they provide a\nconvenient and easy way to reuse existing integrators in special\nsituations rather than needing to reimplement their functionality.     Class Name  Description      TransposeIntegrator  Returns the transpose of the local matrix computed by another BilinearFormIntegrator    LumpedIntegrator  Returns a diagonal local matrix where each entry is the sum of the corresponding row of a local matrix computed by another BilinearFormIntegrator (only implemented for square matrices)    InverseIntegrator  Returns the inverse of the local matrix computed by another BilinearFormIntegrator which produces a square local matrix    SumIntegrator  Returns the sum of a series of integrators with compatible dimensions (only implemented for square matrices)", 
            "title": "Special Purpose Integrators"
        }, 
        {
            "location": "/bilininteg/#weak-operators-and-their-boundary-integrals", 
            "text": "Weak operators use integration by parts to move a spatial derivative\nonto the test function.  This results in an implied boundary integral\nthat is often assumed to be zero but can be used to apply an\nnon-homogeneous Neumann boundary condition.", 
            "title": "Weak Operators and Their Boundary Integrals"
        }, 
        {
            "location": "/bilininteg/#operator-with-scalar-range", 
            "text": "The following weak operators require the range (or test) space to be\n$H_1$ i.e. a scalar basis function with a gradient operator.  The implied\nnatural boundary condition when using these operators is for the\ncontinuous boundary operator (shown in the last column) to be equal to\nzero.  On the other hand an inhomogeneous Neumann boundary condition\ncan be applied by using a linear form boundary integrator to compute\nthis boundary term for a known function e.g. when using the DiffusionIntegrator  one could provide a known function for\n$\\lambda\\,\\grad u$ to the  BoundaryNormalLFIntegrator  which would\nthen integrate the normal component of this function over the boundary\nof the domain.  See  Linear Form Integrators  for more\ninformation.     Class Name  Operator  Continuous Op.  Continuous Boundary Op.      DiffusionIntegrator  $(\\lambda\\grad u, \\grad v)$  $-\\div(\\lambda\\grad u)$  $\\lambda\\,\\hat{n}\\cdot\\grad u$    MixedGradGradIntegrator  $(\\lambda\\grad u, \\grad v)$  $-\\div(\\lambda\\grad u)$  $\\lambda\\,\\hat{n}\\cdot\\grad u$    MixedCrossGradGradIntegrator  $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$  $-\\div(\\vec{\\lambda}\\cross\\grad u)$  $\\hat{n}\\cdot(\\vec{\\lambda}\\times\\grad u)$    MixedScalarWeakDivergenceIntegrator  $(-\\vec{\\lambda}u,\\grad v)$  $\\div(\\vec{\\lambda}u)$  $-\\hat{n}\\cdot\\vec{\\lambda}\\,u$    MixedScalarWeakDerivativeIntegrator  $(-\\lambda u, \\ddx{v})$  $\\ddx{}(\\lambda u)\\;$  $-\\hat{n}\\cdot\\hat{x}\\,\\lambda\\,u$    MixedVectorWeakDivergenceIntegrator  $(-\\lambda\\vec{u},\\grad v)$  $\\div(\\lambda\\vec{u})$  $-\\hat{n}\\cdot(\\lambda\\,\\vec{u})$    MixedWeakDivCrossIntegrator  $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$  $\\div(\\vec{\\lambda}\\cross\\vec{u})$  $-\\hat{n}\\cdot(\\vec{\\lambda}\\times\\vec{u})$    MixedCrossCurlGradIntegrator  $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$  $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$  $\\hat{n}\\cdot(\\vec{\\lambda}\\cross\\curl\\vec{u})$    MixedDivGradIntegrator  $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$  $-\\div(\\vec{\\lambda}\\div\\vec{u})$  $\\hat{n}\\cdot(\\vec{\\lambda}\\div\\vec{u})$", 
            "title": "Operator with Scalar Range"
        }, 
        {
            "location": "/bilininteg/#operator-with-vector-range", 
            "text": "The following weak operators require the range (or test) space to be\nH(Curl) i.e. a vector basis function with a curl operator.  The\nimplied natural boundary condition when using these operators is for\nthe continuous boundary operator (shown in the last column) to be\nequal to zero.  On the other hand an non-homogeneous Neumann boundary\ncondition can be applied by using a linear form boundary integrator to\ncompute this boundary term for a known function e.g. when using the CurlCurlIntegrator  one could provide a known function for\n$\\lambda\\,\\curl\\vec{u}$ to the  VectorFEBoundaryTangentLFIntegrator \nwhich would then integrate the product of the tangential portion of\nthis function with that of the ND basis function over the boundary of\nthe domain.  See  Linear Form Integrators  for more\ninformation.     Class Name  Operator  Continuous Op.  Continuous Boundary Op.      CurlCurlIntegrator  $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\curl\\vec{u})$  $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$    MixedCurlCurlIntegrator  $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\curl\\vec{u})$  $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$    MixedCrossCurlCurlIntegrator  $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$  $\\hat{n}\\times(\\vec{\\lambda}\\cross\\curl\\vec{u})$    MixedCrossGradCurlIntegrator  $(\\vec{\\lambda}\\cross\\grad u,\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\grad u)$  $\\hat{n}\\times(\\vec{\\lambda}\\cross\\grad u)$    MixedVectorWeakCurlIntegrator  $(\\lambda\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\vec{u})$  $\\lambda\\,\\hat{n}\\times\\vec{u}$    MixedScalarWeakCurlIntegrator  $(\\lambda u,\\curl\\vec{v})$  $\\curl(\\lambda\\,u\\,\\hat{z})\\;$  $\\lambda\\,u\\,\\hat{n}\\times\\hat{z}$    MixedWeakCurlCrossIntegrator  $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\vec{u})$  $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$    MixedScalarWeakCurlCrossIntegrator  $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\vec{u})$  $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$     The following weak operators require the range (or test) space to be\nH(Div) i.e. a vector basis function with a divergence operator.  The\nimplied natural boundary condition when using these operators is for\nthe continuous boundary operator (shown in the last column) to be\nequal to zero.  On the other hand an non-homogeneous Neumann boundary\ncondition can be applied by using a linear form boundary integrator to\ncompute this boundary term for a known function e.g. when using the DivDivIntegrator  one could provide a known function for\n$\\lambda\\,\\div\\vec{u}$ to the  VectorFEBoundaryFluxLFIntegrator \nwhich would then integrate the product of this function with the\nnormal component of the RT basis function over the boundary of the\ndomain.  See  Linear Form Integrators  for more\ninformation.     Class Name  Operator  Continuous Op.  Continuous Boundary Op.      DivDivIntegrator  $(\\lambda\\div\\vec{u},\\div\\vec{v})$  $-\\grad(\\lambda\\div\\vec{u})$  $\\lambda\\div\\vec{u}\\,\\hat{n}$    MixedGradDivIntegrator  $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$  $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$  $\\vec{\\lambda}\\cdot\\grad u\\,\\hat{n}$    MixedScalarWeakGradientIntegrator  $(-\\lambda u, \\div\\vec{v})$  $\\grad(\\lambda u)$  $-\\lambda u\\,\\hat{n}$    MixedWeakGradDotIntegrator  $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$  $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$  $-\\vec{\\lambda}\\cdot\\vec{u}\\,\\hat{n}$     MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Operator with Vector Range"
        }, 
        {
            "location": "/lininteg/", 
            "text": "Linear Form Integrators\n\n\n$\n\\newcommand{\\cross}{\\times}\n\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\n\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}\n\\newcommand{\\ddx}[1]{\\frac{d#1}{dx}}\n$\n\n\nLinear form integrators are the right-hand side companion to \nBilinear Form\nIntegrators\n that compute the integrals of products of a basis\nfunction and a given \"right-hand side\" function (coefficient) $\\,f$ over\nindividual mesh elements (or sometimes over edges or faces). Typically each\nelement is contained in the support of several basis functions, therefore linear\nintegrators simultaneously compute the integrals of all combinations of the\nrelevant basis functions with the given input function $\\,f$. This produces a\none dimensional array of results that is arranged into a small vector of\nintegral (dual) values called a \nlocal element (load) vector\n.\n\n\nTo put this another way, the \nLinearForm\n class builds a global vector,\n\nglb_vec\n, by performing the outer loop in the following pseudocode snippet\nwhereas the \nLinearFormIntegrator\n class performs the nested inner loops to\ncompute the local vector, \nloc_vec\n.\n\n\nfor each elem in elements\n   loc_vec = 0.0\n   for each pt in quadrature_points\n      for each v_i in elem\n         loc_vec(i) += w(pt) * rhs(pt) v_i(pt)\n      end\n   end\n   glb_vec += loc_vec\nend\n\n\n\n\nThere are three types of integrals that typically arise although many other,\nmore exotic, forms are possible:\n\n\n\n\nIntegrals involving Scalar rhs $\\,f$ and basis functions: $\\int_\\Omega\\, f v$\n\n\nIntegrals involving Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega\\, \\vec{f}\\cdot\\vec{v}$\n\n\nIntegrals involving mix of Scalar and Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega f\\,\\vec{\\lambda}\\cdot\\vec{v}$ and $\\int_\\Omega v\\,\\vec{\\lambda}\\cdot\\vec{f}$\n\n\n\n\nThe \nLinearFormIntegrator\n classes allow MFEM to produce a wide variety of local\nelement matrices without modifying the \nLinearForm\n class. Many of the possible\noperators are collected below into tables that briefly describe their action and\nrequirements.\n\n\nIn the tables below the \nSpace\n column refers to finite element spaces which\nimplement the following methods:\n\n\n\n\n\n\n\n\nSpace\n\n\nOperator\n\n\nDerivative Operator\n\n\n\n\n\n\n\n\n\n\nH1\n\n\nCalcShape\n\n\nCalcDShape\n\n\n\n\n\n\nND\n\n\nCalcVShape\n\n\nCalcCurlShape\n\n\n\n\n\n\nRT\n\n\nCalcVShape\n\n\nCalcDivShape\n\n\n\n\n\n\nL2\n\n\nCalcShape\n\n\nNone\n\n\n\n\n\n\n\n\nNotation:\n$$\\{(f, v)\\}_i\\equiv \\int_\\Omega f v_i$$\n$$\\{(\\vec{F}, \\vec{v})\\}_i\\equiv \\int_\\Omega \\lambda \\vec{F}\\cdot\\vec{v}_i$$\nFor boundary integrators, the integrals are over $\\partial \\Omega$.\nFace integrators integrate over the interior and boundary faces of mesh elements\nand are denoted with $\\left\n\\cdot,\\cdot\\right\n$.\n\n\nScalar Field Operators\n\n\nDomain Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nDomainLFIntegrator\n\n\nH1, L2\n\n\n$(f, v)$\n\n\n$f$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\n\n\nBoundary Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nBoundaryLFIntegrator\n\n\nH1, L2\n\n\n$(f, v)$\n\n\n$f$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nBoundaryNormalLFIntegrator\n\n\nH1, L2\n\n\n$(\\vec{f} \\cdot \\vec{n}, v)$\n\n\n$\\vec{f} \\cdot \\vec{n}$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nBoundaryTangentialLFIntegrator\n\n\nH1, L2\n\n\n$(\\vec{f} \\cdot \\vec{\\tau}, v)$\n\n\n$\\vec{f} \\cdot \\vec{\\tau}$\n\n\n2D\n\n\n\n\n\n\nBoundaryFlowIntegrator\n\n\nH1, L2\n\n\n$\\frac{\\alpha}{2}\\, \\left\n (\\vec{u} \\cdot \\vec{n})\\, f, v \\right\n - \\beta\\, \\left\n\\mid \\vec{u} \\cdot \\vec{n} \\mid f, v \\right\n$\n\n\n$\\frac{\\alpha}{2} (\\vec{u} \\cdot \\vec{n})\\, f - \\beta \\mid \\vec{u} \\cdot \\vec{n} \\mid f$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\n\n\nFace Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nDGDirichletLFIntegrator\n\n\nL2\n\n\n$\\sigma \\left\n u_D, Q \\nabla v \\cdot \\vec{n} \\right\n + \\kappa \\left\n \\{h^{-1} Q\\} u_D, v \\right\n$\n\n\nDG essential BCs for $u_D$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\n\n\nVector Field Operators\n\n\nDomain Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nVectorDomainLFIntegrator\n\n\nH1, L2\n\n\n$(\\vec{f}, \\vec{v})$\n\n\n$\\vec{f}$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nVectorFEDomainLFIntegrator\n\n\nND, RT\n\n\n$(\\vec{f}, \\vec{v})$\n\n\n$\\vec{f}$\n\n\n2D, 3D\n\n\n\n\n\n\n\n\nBoundary Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nVectorBoundaryLFIntegrator\n\n\nH1, L2\n\n\n$( \\vec{f}, \\vec{v} )$\n\n\n$\\vec{f}$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nVectorBoundaryFluxLFIntegrator\n\n\nH1, L2\n\n\n$( f, \\vec{v} \\cdot \\vec{n} )$\n\n\n$\\vec{f}$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nVectorFEBoundaryFluxLFIntegrator\n\n\nRT\n\n\n$( f, \\vec{v} \\cdot \\vec{n} )$\n\n\n$\\vec{f}$\n\n\n2D, 3D\n\n\n\n\n\n\nVectorFEBoundaryTangentLFIntegrator\n\n\nND\n\n\n$( \\vec{n} \\times \\vec{f}, \\vec{v} )$\n\n\n$\\vec{n} \\times \\vec{f}$\n\n\n2D, 3D\n\n\n\n\n\n\n\n\nFace Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nDGElasticityDirichletLFIntegrator\n\n\nL2\n\n\n$\\alpha\\left\n\\vec{u_D}, \\left(\\lambda \\left(\\div \\vec{v}\\right) I + \\mu \\left(\\nabla\\vec{v} + \\nabla\\vec{v}^T\\right)\\right) \\cdot \\vec{n}\\right\n \\\\ + \\kappa\\left\n h^{-1} (\\lambda + 2 \\mu) \\vec{u_D}, \\vec{v} \\right\n$\n\n\nDG essential BCs for $\\vec{u_D}$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "_Linear Form Integrators"
        }, 
        {
            "location": "/lininteg/#linear-form-integrators", 
            "text": "$\n\\newcommand{\\cross}{\\times}\n\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\n\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}\n\\newcommand{\\ddx}[1]{\\frac{d#1}{dx}}\n$  Linear form integrators are the right-hand side companion to  Bilinear Form\nIntegrators  that compute the integrals of products of a basis\nfunction and a given \"right-hand side\" function (coefficient) $\\,f$ over\nindividual mesh elements (or sometimes over edges or faces). Typically each\nelement is contained in the support of several basis functions, therefore linear\nintegrators simultaneously compute the integrals of all combinations of the\nrelevant basis functions with the given input function $\\,f$. This produces a\none dimensional array of results that is arranged into a small vector of\nintegral (dual) values called a  local element (load) vector .  To put this another way, the  LinearForm  class builds a global vector, glb_vec , by performing the outer loop in the following pseudocode snippet\nwhereas the  LinearFormIntegrator  class performs the nested inner loops to\ncompute the local vector,  loc_vec .  for each elem in elements\n   loc_vec = 0.0\n   for each pt in quadrature_points\n      for each v_i in elem\n         loc_vec(i) += w(pt) * rhs(pt) v_i(pt)\n      end\n   end\n   glb_vec += loc_vec\nend  There are three types of integrals that typically arise although many other,\nmore exotic, forms are possible:   Integrals involving Scalar rhs $\\,f$ and basis functions: $\\int_\\Omega\\, f v$  Integrals involving Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega\\, \\vec{f}\\cdot\\vec{v}$  Integrals involving mix of Scalar and Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega f\\,\\vec{\\lambda}\\cdot\\vec{v}$ and $\\int_\\Omega v\\,\\vec{\\lambda}\\cdot\\vec{f}$   The  LinearFormIntegrator  classes allow MFEM to produce a wide variety of local\nelement matrices without modifying the  LinearForm  class. Many of the possible\noperators are collected below into tables that briefly describe their action and\nrequirements.  In the tables below the  Space  column refers to finite element spaces which\nimplement the following methods:     Space  Operator  Derivative Operator      H1  CalcShape  CalcDShape    ND  CalcVShape  CalcCurlShape    RT  CalcVShape  CalcDivShape    L2  CalcShape  None     Notation:\n$$\\{(f, v)\\}_i\\equiv \\int_\\Omega f v_i$$\n$$\\{(\\vec{F}, \\vec{v})\\}_i\\equiv \\int_\\Omega \\lambda \\vec{F}\\cdot\\vec{v}_i$$\nFor boundary integrators, the integrals are over $\\partial \\Omega$.\nFace integrators integrate over the interior and boundary faces of mesh elements\nand are denoted with $\\left \\cdot,\\cdot\\right $.", 
            "title": "Linear Form Integrators"
        }, 
        {
            "location": "/lininteg/#scalar-field-operators", 
            "text": "", 
            "title": "Scalar Field Operators"
        }, 
        {
            "location": "/lininteg/#domain-integrators", 
            "text": "Class Name  Space  Operator  Continuous Op.  Dimension      DomainLFIntegrator  H1, L2  $(f, v)$  $f$  1D, 2D, 3D", 
            "title": "Domain Integrators"
        }, 
        {
            "location": "/lininteg/#boundary-integrators", 
            "text": "Class Name  Space  Operator  Continuous Op.  Dimension      BoundaryLFIntegrator  H1, L2  $(f, v)$  $f$  1D, 2D, 3D    BoundaryNormalLFIntegrator  H1, L2  $(\\vec{f} \\cdot \\vec{n}, v)$  $\\vec{f} \\cdot \\vec{n}$  1D, 2D, 3D    BoundaryTangentialLFIntegrator  H1, L2  $(\\vec{f} \\cdot \\vec{\\tau}, v)$  $\\vec{f} \\cdot \\vec{\\tau}$  2D    BoundaryFlowIntegrator  H1, L2  $\\frac{\\alpha}{2}\\, \\left  (\\vec{u} \\cdot \\vec{n})\\, f, v \\right  - \\beta\\, \\left \\mid \\vec{u} \\cdot \\vec{n} \\mid f, v \\right $  $\\frac{\\alpha}{2} (\\vec{u} \\cdot \\vec{n})\\, f - \\beta \\mid \\vec{u} \\cdot \\vec{n} \\mid f$  1D, 2D, 3D", 
            "title": "Boundary Integrators"
        }, 
        {
            "location": "/lininteg/#face-integrators", 
            "text": "Class Name  Space  Operator  Continuous Op.  Dimension      DGDirichletLFIntegrator  L2  $\\sigma \\left  u_D, Q \\nabla v \\cdot \\vec{n} \\right  + \\kappa \\left  \\{h^{-1} Q\\} u_D, v \\right $  DG essential BCs for $u_D$  1D, 2D, 3D", 
            "title": "Face Integrators"
        }, 
        {
            "location": "/lininteg/#vector-field-operators", 
            "text": "", 
            "title": "Vector Field Operators"
        }, 
        {
            "location": "/lininteg/#domain-integrators_1", 
            "text": "Class Name  Space  Operator  Continuous Op.  Dimension      VectorDomainLFIntegrator  H1, L2  $(\\vec{f}, \\vec{v})$  $\\vec{f}$  1D, 2D, 3D    VectorFEDomainLFIntegrator  ND, RT  $(\\vec{f}, \\vec{v})$  $\\vec{f}$  2D, 3D", 
            "title": "Domain Integrators"
        }, 
        {
            "location": "/lininteg/#boundary-integrators_1", 
            "text": "Class Name  Space  Operator  Continuous Op.  Dimension      VectorBoundaryLFIntegrator  H1, L2  $( \\vec{f}, \\vec{v} )$  $\\vec{f}$  1D, 2D, 3D    VectorBoundaryFluxLFIntegrator  H1, L2  $( f, \\vec{v} \\cdot \\vec{n} )$  $\\vec{f}$  1D, 2D, 3D    VectorFEBoundaryFluxLFIntegrator  RT  $( f, \\vec{v} \\cdot \\vec{n} )$  $\\vec{f}$  2D, 3D    VectorFEBoundaryTangentLFIntegrator  ND  $( \\vec{n} \\times \\vec{f}, \\vec{v} )$  $\\vec{n} \\times \\vec{f}$  2D, 3D", 
            "title": "Boundary Integrators"
        }, 
        {
            "location": "/lininteg/#face-integrators_1", 
            "text": "Class Name  Space  Operator  Continuous Op.  Dimension      DGElasticityDirichletLFIntegrator  L2  $\\alpha\\left \\vec{u_D}, \\left(\\lambda \\left(\\div \\vec{v}\\right) I + \\mu \\left(\\nabla\\vec{v} + \\nabla\\vec{v}^T\\right)\\right) \\cdot \\vec{n}\\right  \\\\ + \\kappa\\left  h^{-1} (\\lambda + 2 \\mu) \\vec{u_D}, \\vec{v} \\right $  DG essential BCs for $\\vec{u_D}$  1D, 2D, 3D     MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Face Integrators"
        }, 
        {
            "location": "/lininterp/", 
            "text": "Linear Interpolators\n\n\n$\n\\newcommand{\\cross}{\\times}\n\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\n\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}\n\\newcommand{\\ddx}[1]{\\frac{d#1}{dx}}\n\\newcommand{\\abs}[1]{|#1|}\n$\n\n\nLinear interpolators can be very useful for interpolating one discrete\nrepresentation of a field onto another set of basis functions to\nproduce another representation.  However, this must be done with care\nbecause different discrete representations are not completely\ninterchangeable.\n\n\nAs an example consider a scalar field projected onto either piece-wise\nlinear ($H_1$) or piece-wise constant ($L_2$) basis functions.\nInterpolating from an $H_1$ representation to an $L_2$ representation\nshould produce a reasonable result because the constant value needed\nin each element can be computed as a weighted sum of the $H_1$ basis\nfunctions in that element.  On the other hand, if we try to\ninterpolate from the $L_2$ representation to an $H_1$ representation\nwe don't have enough information to determine reasonable values for\nthe degrees of freedom which are shared between neighboring elements\nbecause linear interpolators can only access one element at a time.\nTo accurately compute an $H_1$ representation from an $L_2$\nrepresentation requires the type of weighted average of values from\nneighboring elements that bilinear forms provide but this requires a\nlinear solve and often suitable boundary conditions.\n\n\nThe operators produced by the \nBilinearForm\n classes involve\nintegrations and therefore they sum the various contributions from\nneighboring elements to compute a full integral.  The\n\nDiscreteLinearOperator\n classes are not performing integrals but\nrather interpolations and as such they do not combine contributions\nfrom different elements in any way.  Consequently if the\n\nLinearInterpolator\ns produce different results for entities that are\nshared between neighboring elements then the resulting representation\nwill depend on the order in which the elements are processed.  Such\noperators are not good candidates for \nDiscreteLinearOperator\ns.  The\nsections below will offer some guidance on the appropriate use of these\noperators.\n\n\nIn the tables below the \nSpace\n column refers to finite element spaces which\nimplement the following methods:\n\n\n\n\n\n\n\n\nSpace\n\n\nOperator\n\n\nDerivative Operator\n\n\n\n\n\n\n\n\n\n\nH1\n\n\nCalcShape\n\n\nCalcDShape\n\n\n\n\n\n\nND\n\n\nCalcVShape\n\n\nCalcCurlShape\n\n\n\n\n\n\nRT\n\n\nCalcVShape\n\n\nCalcDivShape\n\n\n\n\n\n\nL2\n\n\nCalcShape\n\n\nNone\n\n\n\n\n\n\n\n\nThe \nCoef.\n column refers to the types of coefficients that are\navailable.  A boldface coefficient type is required whereas most\ncoefficients are optional.\n\n\n\n\n\n\n\n\nCoef.\n\n\nType\n\n\n\n\n\n\n\n\n\n\nS\n\n\nScalar Valued Function\n\n\n\n\n\n\nV\n\n\nVector Valued Function\n\n\n\n\n\n\nD\n\n\nDiagonal Matrix Function\n\n\n\n\n\n\nM\n\n\nGeneral Matrix Function\n\n\n\n\n\n\n\n\nDerivative Interpolators\n\n\nThe $H(Curl)$ and $H(Div)$ spaces are specifically designed to support\nthese derivative operators by having the necessary inter-element\ncontinuity.  Other possible derivative operators would not possess the\ncorrect continuity and must therefore be implemented in a weak sense.\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nOperator\n\n\n\n\n\n\n\n\n\n\nGradientInterpolator\n\n\nH1\n\n\nND\n\n\n$\\grad u$\n\n\n\n\n\n\nCurlInterpolator\n\n\nND\n\n\nRT\n\n\n$\\curl\\vec{u}$\n\n\n\n\n\n\nDivergenceInterpolator\n\n\nRT\n\n\nL2\n\n\n$\\div\\vec{u}$\n\n\n\n\n\n\n\n\nProduct Interpolators\n\n\nThese operators require a bit more care than the previous set.  In\norder for these operators to produce valid results the product of the\ncoefficient with the domain space must be uniquely representable\nwithin the desired range space.  Additionally, it may sometimes be\ndesirable for the range space to have a higher order than the domain\nspace if the coefficient is not constant.  For example if the domain\nspace and the coefficient are both linear it might be desirable,\nthough not necessary, for the range space to be quadratic.\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nOperator\n\n\n\n\n\n\n\n\n\n\nScalarProductInterpolator\n\n\nH1,L2\n\n\nH1,L2\n\n\nS\n\n\n$\\lambda u$\n\n\n\n\n\n\nScalarVectorProductInterpolator\n\n\nND,RT\n\n\nND,RT\n\n\nS\n\n\n$\\lambda\\vec{u}$\n\n\n\n\n\n\nVectorScalarProductInterpolator\n\n\nH1,L2\n\n\nND,RT\n\n\nV\n\n\n$\\vec{\\lambda}u$\n\n\n\n\n\n\nVectorCrossProductInterpolator\n\n\nND,RT\n\n\nND,RT\n\n\nV\n\n\n$\\vec{\\lambda}\\times\\vec{u}$\n\n\n\n\n\n\nVectorInnerProductInterpolator\n\n\nND,RT\n\n\nH1,L2\n\n\nV\n\n\n$\\vec{\\lambda}\\cdot\\vec{u}$\n\n\n\n\n\n\n\n\nSpecial Purpose Interpolators\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nOperator\n\n\n\n\n\n\n\n\n\n\nIdentityInterpolator\n\n\nH1,L2\n\n\nH1,L2\n\n\n$u$\n\n\n\n\n\n\nNormalInterpolator\n\n\nH1$^d$\n\n\nRT_Trace\n\n\n$\\hat{n}\\cdot\\vec{u}$\n\n\n\n\n\n\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "_Linear Interpolators"
        }, 
        {
            "location": "/lininterp/#linear-interpolators", 
            "text": "$\n\\newcommand{\\cross}{\\times}\n\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\n\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}\n\\newcommand{\\ddx}[1]{\\frac{d#1}{dx}}\n\\newcommand{\\abs}[1]{|#1|}\n$  Linear interpolators can be very useful for interpolating one discrete\nrepresentation of a field onto another set of basis functions to\nproduce another representation.  However, this must be done with care\nbecause different discrete representations are not completely\ninterchangeable.  As an example consider a scalar field projected onto either piece-wise\nlinear ($H_1$) or piece-wise constant ($L_2$) basis functions.\nInterpolating from an $H_1$ representation to an $L_2$ representation\nshould produce a reasonable result because the constant value needed\nin each element can be computed as a weighted sum of the $H_1$ basis\nfunctions in that element.  On the other hand, if we try to\ninterpolate from the $L_2$ representation to an $H_1$ representation\nwe don't have enough information to determine reasonable values for\nthe degrees of freedom which are shared between neighboring elements\nbecause linear interpolators can only access one element at a time.\nTo accurately compute an $H_1$ representation from an $L_2$\nrepresentation requires the type of weighted average of values from\nneighboring elements that bilinear forms provide but this requires a\nlinear solve and often suitable boundary conditions.  The operators produced by the  BilinearForm  classes involve\nintegrations and therefore they sum the various contributions from\nneighboring elements to compute a full integral.  The DiscreteLinearOperator  classes are not performing integrals but\nrather interpolations and as such they do not combine contributions\nfrom different elements in any way.  Consequently if the LinearInterpolator s produce different results for entities that are\nshared between neighboring elements then the resulting representation\nwill depend on the order in which the elements are processed.  Such\noperators are not good candidates for  DiscreteLinearOperator s.  The\nsections below will offer some guidance on the appropriate use of these\noperators.  In the tables below the  Space  column refers to finite element spaces which\nimplement the following methods:     Space  Operator  Derivative Operator      H1  CalcShape  CalcDShape    ND  CalcVShape  CalcCurlShape    RT  CalcVShape  CalcDivShape    L2  CalcShape  None     The  Coef.  column refers to the types of coefficients that are\navailable.  A boldface coefficient type is required whereas most\ncoefficients are optional.     Coef.  Type      S  Scalar Valued Function    V  Vector Valued Function    D  Diagonal Matrix Function    M  General Matrix Function", 
            "title": "Linear Interpolators"
        }, 
        {
            "location": "/lininterp/#derivative-interpolators", 
            "text": "The $H(Curl)$ and $H(Div)$ spaces are specifically designed to support\nthese derivative operators by having the necessary inter-element\ncontinuity.  Other possible derivative operators would not possess the\ncorrect continuity and must therefore be implemented in a weak sense.     Class Name  Domain  Range  Operator      GradientInterpolator  H1  ND  $\\grad u$    CurlInterpolator  ND  RT  $\\curl\\vec{u}$    DivergenceInterpolator  RT  L2  $\\div\\vec{u}$", 
            "title": "Derivative Interpolators"
        }, 
        {
            "location": "/lininterp/#product-interpolators", 
            "text": "These operators require a bit more care than the previous set.  In\norder for these operators to produce valid results the product of the\ncoefficient with the domain space must be uniquely representable\nwithin the desired range space.  Additionally, it may sometimes be\ndesirable for the range space to have a higher order than the domain\nspace if the coefficient is not constant.  For example if the domain\nspace and the coefficient are both linear it might be desirable,\nthough not necessary, for the range space to be quadratic.     Class Name  Domain  Range  Coef.  Operator      ScalarProductInterpolator  H1,L2  H1,L2  S  $\\lambda u$    ScalarVectorProductInterpolator  ND,RT  ND,RT  S  $\\lambda\\vec{u}$    VectorScalarProductInterpolator  H1,L2  ND,RT  V  $\\vec{\\lambda}u$    VectorCrossProductInterpolator  ND,RT  ND,RT  V  $\\vec{\\lambda}\\times\\vec{u}$    VectorInnerProductInterpolator  ND,RT  H1,L2  V  $\\vec{\\lambda}\\cdot\\vec{u}$", 
            "title": "Product Interpolators"
        }, 
        {
            "location": "/lininterp/#special-purpose-interpolators", 
            "text": "Class Name  Domain  Range  Operator      IdentityInterpolator  H1,L2  H1,L2  $u$    NormalInterpolator  H1$^d$  RT_Trace  $\\hat{n}\\cdot\\vec{u}$     MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Special Purpose Interpolators"
        }, 
        {
            "location": "/electromagnetics/", 
            "text": "Electromagnetics Mini Applications\n\n\n$\\newcommand{\\A}{\\vec{A}}\\newcommand{\\B}{\\vec{B}}\n\\newcommand{\\D}{\\vec{D}}\\newcommand{\\E}{\\vec{E}}\n\\newcommand{\\H}{\\vec{H}}\\newcommand{\\J}{\\vec{J}}\n\\newcommand{\\M}{\\vec{M}}\\newcommand{\\P}{\\vec{P}}\n\\newcommand{\\F}{\\vec{F}}\n\\newcommand{\\dd}[2]{\\frac{\\partial #1}{\\partial #2}}\n\\newcommand{\\cross}{\\times}\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}$\n\n\nThe \nminiapps/electromagnetics\n directory contains a collection of\nelectromagnetic miniapps based on MFEM.\n\n\nCompared to the \nexample codes\n, the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.\n\n\nThe current electromagnetic miniapps are described below.\n\n\nElectromagnetics\n\n\nThe equations describing electromagnetic phenomena are known collectively as\nthe Maxwell Equations. They are usually given as:\n\n\n$$\\begin{align}\n    \\curl\\H - \\dd{\\D}{t} \n = \\J    \\label{ampere}  \\\\\n    \\curl\\E + \\dd{\\B}{t} \n = 0     \\label{faraday} \\\\\n                  \\div\\D \n = \\rho  \\label{gauss}   \\\\\n                  \\div\\B \n = 0     \\label{divb}\n  \\end{align}$$\n\n\nWhere equation \\eqref{ampere} can be referred to as \nAmp\u00e9re's Law\n, equation\n\\eqref{faraday} is called \nFaraday's Law\n, equation \\eqref{gauss} is \nGauss's\nLaw\n, and equation \\eqref{divb} doesn't generally have a name but is related to\nthe nonexistence of magnetic monopoles. The various fields in these equations\nare:\n\n\n\n\n\n\n\n\nSymbol\n\n\nName\n\n\nSI Units\n\n\n\n\n\n\n\n\n\n\n$\\H$\n\n\nmagnetic field\n\n\nAmpere/meter\n\n\n\n\n\n\n$\\B$\n\n\nmagnetic flux density\n\n\nTesla\n\n\n\n\n\n\n$\\E$\n\n\nelectric field\n\n\nVolts/meter\n\n\n\n\n\n\n$\\D$\n\n\nelectric displacement\n\n\nCoulomb/meter$^2$\n\n\n\n\n\n\n$\\J$\n\n\ncurrent density\n\n\nAmpere/meter$^2$\n\n\n\n\n\n\n$\\rho$\n\n\ncharge density\n\n\nCoulomb/meter$^3$\n\n\n\n\n\n\n\n\nIn the literature these names do vary, particularly those for $\\H$ and $\\B$,\nbut in this document we will try to adhere to the convention laid out above.\n\n\nGenerally we also need constitutive relations between $\\E$ and $\\D$ and/or\nbetween $\\H$ and $\\B$. These relations start with the definitions:\n\n\n$$\\begin{align}\n    \\D \n = \\epsilon_0\\E + \\P \\label{const_d}  \\\\\n    \\B \n = \\mu_0(\\H + \\M)    \\label{const_b}\n  \\end{align}$$\n\n\nWhere $\\P$ is the \npolarization density\n, and $\\M$ is the \nmagnetization\n.\nAlso, $\\epsilon_0$ is the \npermittivity of free space\n and $\\mu_0$ is the\n\npermeability of free space\n which are both constants of nature. In many common\nmaterials the polarization density can be approximated as a scalar multiple of\nthe electric field, i.e., $\\P = \\epsilon_0\\chi\\E$, where $\\chi$ is called the\n\nelectric susceptibility\n. In such cases we usually use the relation $\\D =\n\\epsilon\\E$ with $\\epsilon = \\epsilon_0(1 + \\chi)$ and call $\\epsilon$ the\n\npermittivity\n of the material.\n\n\nThe nature of magnetization is more complicated but we will take a very\nsimplified view which is valid in many situations. Specifically, we will assume\nthat either $\\M$ is proportional to $\\H$ yielding the relation $\\B = \\mu\\H$\nwhere $\\mu = \\mu_0(1 + \\chi_M)$ and $\\chi_M$ is the \nmagnetic susceptibility\n\nor that $\\M$ is independent of the applied field. The former case pertains to\nboth diamagnetic and paramagnetic materials and the latter to ferromagnetic\nmaterials.\n\n\nFinally we should note that equations \\eqref{ampere} and \\eqref{gauss} can be\ncombined to yield the equation of charge continuity $\\dd{\\rho}{t} + \\div\\J = 0$\nwhich can be important in plasma physics and magnetohydrodynamics (MHD).\n\n\nElectrostatics\n\n\nElectrostatic problems come in a variety of subtypes but they all derive from\nGauss's Law and Faraday's Law (equations \\eqref{gauss} and \\eqref{faraday}).\nWhen we assume no time variation, Faraday's Law becomes simply $\\curl\\E = 0$.\nThis suggests that the electric field can be expressed as the gradient of a\nscalar field which is traditionally taken to be $-\\varphi$, i.e.\n\n\n$$\\E = -\\grad\\varphi   \\label{gradphi}$$\n\n\nwhere $\\varphi$ is called the \nelectric potential\n and has units of Volts in\nthe SI system. Inserting this definition into equation \\eqref{gauss} gives:\n\n\n$$-\\div\\epsilon\\grad\\varphi = \\rho - \\div\\P   \\label{poisson}$$\n\n\nwhich is \nPoisson's equation\n for the electric potential, where we have assumed\na linear constitutive relation between $\\D$ and $\\E$ of the form $\\D =\n\\epsilon\\E + \\P$. This allows a polarization which is proportional to $\\E$ as\nwell a polarization independent of $\\E$. If this relation happens to be\nnonlinear then Poisson's equation would need to be replaced with a more\ncomplicated nonlinear expression.\n\n\nThe solutions to equation \\eqref{poisson} are non unique because they can be\nshifted by any additive constant. This means that we must apply a Dirichlet\nboundary condition at least at one point in the problem domain in order to\nobtain a solution. Typically this point will be on the boundary but it need not\nbe so. Such a Dirichlet value is equivalent to fixing the voltage (a.k.a.\npotential) at one or more locations. Additionally, this equation admits a normal\nderivative boundary condition. This corresponds to setting $\\hat{n}\\cdot\\D$ to a\nprescribed value on some portion of the boundary. This is equivalent to defining\na surface charge density on that portion of the boundary.\n\n\nVolta Mini Application\n\n\nThe electrostatics mini application, named \nvolta\n after the inventor of the\n\nvoltaic pile\n, is intended to\ndemonstrate how to solve standard electrostatics problems in MFEM. Its source\nterms and boundary conditions are simple but they should indicate how more\nspecialized sources or boundary conditions could be implemented.\n\n\n\n\nNote that this application assumes the mesh coordinates are given in meters.\n\n\nMini Application Features\n\n\nPermittivity:\n The permittivity, $\\epsilon$, is assumed to be that of free\n  space except for an optional sphere of dielectric material which can be\n  defined by the user. The command line option \n-ds\n can be used to set the\n  parameters for this dielectric sphere. For example, to produce a sphere at the\n  origin with a radius of 0.5 and a relative permittivity of 3 the user would\n  specify: \n-ds '0 0 0 0.5 3'\n.\n\n\nCharge Density:\n The charge density, $\\rho$, is assumed to be zero except for\n  an optional sphere of uniform charge density which can be defined by the user.\n  The command line option for this is \n-cs\n which follows the same pattern as\n  the dielectric sphere. Note that the last entry is the total charge of the\n  sphere and not its charge density.\n\n\nPolarization:\n A polarization vector function, $\\P$, can be imposed as a\n  source of the electric field. The command line option \n-vp\n creates a\n  polarization due to a simple voltaic pile, i.e., a cylinder which is\n  electrically polarized along its axis. The user should specify the two end\n  points of the cylinder axis, its radius and the magnitude of the polarization\n  vector.\n\n\nDirichlet BC:\n Dirichlet boundary conditions can either specify piecewise\n  constant voltages on a collection of surfaces or they can specify a gradient\n  field which approximates a uniform applied electric field. In either case the\n  user specifies the surfaces where the Dirichlet boundary condition should be\n  applied using the \n-dbcs\n option followed by a list of boundary attributes.\n  For example to select surfaces 2, 3, and 4 the user would use the following:\n  \n-dbcs '2 3 4'\n.\n\n\nTo apply a gradient field on these surfaces the user would also use the\n  \n-dbcg\n option. This defaults to the uniform field $\\E = (0,0,1)$ in 3D or\n  $\\E = (0,1)$ in 2D. An arbitrary vector can be specified with \n-uebc\n\n  followed by the desired vector, e.g., to apply $\\E = (1,2,3)$ the user would\n  supply: \n-uebc '1 2 3'\n.\n\n\nTo specify piecewise constant potential values the user would list the\n  desired values after \n-dbcv\n as follows: \n-dbcv '0.0 1.0 -1.0'\n.\n\n\nNeumann BC:\n Neumann boundary conditions set the normal component of the\n  electric displacement on portions of the boundary. This normal component is\n  equivalent to the surface charge density on the surface. This is rarely used\n  because surface charge densities are rarely known unless they are know to be\n  zero. However, if the surface charge density is zero then the Neumann BCs are\n  not needed because this is the natural boundary condition. Only piecewise\n  constant Neumann boundary conditions are supported. They can be set\n  analogously to piecewise Dirichlet boundary conditions but using options\n  \n-nbcs\n and \n-nbcv\n.\n\n\nMagnetostatics\n\n\nMagnetostatic problems arise when we assume no time variation in Amp\u00e9re's Law\n\\eqref{ampere} which leads to:\n\n\n$$\\curl\\H = \\J   \\nonumber$$\n\n\nWe will again assume a somewhat more general constitutive relation between $\\H$\nand $\\vec{B}$ than is normally seen:\n\n\n$$\\B = \\mu\\H + \\mu_0\\M = \\mu_0(1 + \\chi_M)\\H + \\mu_0\\M   \\nonumber$$\n\n\nWhere the magnetization is split into two portions; one which is proportional\nto $\\H$ and given by $\\chi_M\\H$, and another which is independent of $\\H$ and\nis given by $\\M$. This allows for paramagnetic and/or diamagnetic materials\ndefined through $\\mu$ as well as ferromagnetic materials represented by $\\M$.\nThis choice yields:\n\n\n$$\\curl\\mu^{-1}\\B = \\J + \\curl\\mu^{-1}\\mu_0\\M   \\nonumber$$\n\n\nWhich, when combined with equation \\eqref{divb}, becomes:\n\n\n$$\\curl\\mu^{-1}\\curl\\A = \\J + \\curl\\mu^{-1}\\mu_0\\M $$\n\n\nIf $\\J$ happens to be zero we have another option because we can assume that\n$\\H = -\\grad\\varphi_M$ for some scalar potential $\\varphi_M$. When combined\nwith equation \\eqref{divb} this leads to:\n\n\n$$\\div\\mu\\grad\\varphi_M = \\div\\mu_0\\M $$\n\n\nCurrently only the vector potential equation is used so we will focus on that\nfor the remainder of this document.\n\n\nThe vector potential is again non unique so we must apply additional\nconstraints in order to arrive at a solution for $\\A$. When working\nanalytically it is common to constrain the solution by restricting the\ndivergence of $\\A$ but numerically this leads to other complications. For our\nproblems of interest it will be necessary to require Dirichlet boundary\nconditions on the entire outer surface in order to sufficiently constrain the\nsolution.\n\n\nDirichlet boundary conditions for the vector potential on a surface provide a\nmeans to specify the component of $\\B$ normal to that surface. For example,\nsetting the tangential components of $\\A$ to be zero on a particular surface\nresults in a magnetic flux density which must be tangent to that surface.\n\n\nTesla Mini Application\n\n\nThe magnetostatics mini application, named \ntesla\n after the unit of magnetic\nfield strength (and of course the man Nikola Tesla), is intended to demonstrate\nhow to solve standard magnetostatics problems in MFEM. Its source terms and\nboundary conditions are simple but they should indicate how more specialized\nsources of boundary conditions could be implemented.\n\n\n\n\nNote that this application assumes the mesh coordinates are given in meters.\n\n\nMini Application Features\n\n\nPermeability:\n The permeability, $\\mu$, is assumed to be that of free space\n  except for an optional spherical shell of diamagnetic or paramagnetic material\n  which can be defined by the user. The command line option \n-ms\n can be used to\n  set the parameters for this shell.\n\n\nFor example, to produce a shell at the origin with inner and outer radii of\n  0.4 and 0.5 respectively and a relative permeability of 3 the user would\n  specify: \n-ms '0 0 0 0.4 0.5 3'\n.\n\n\nCurrent Density:\n The current density, $\\J$, is assumed to be zero except for\n  an optional ring of constant current which can be defined by the user. The\n  command line option for this is \n-cr\n which requires two points giving the end\n  points of the ring's axis, inner and outer radii, and a constant total\n  current.\n\n\nFor example, to specify a ring centered at the origin and laying in the XY\n  plane with a thickness of 0.2 and radii 0.4 and 0.5, and a current of 2 amps\n  the user would give: \n-cr 0 0 -0.1 0 0 0.1 0.4 0.5 2\n.\n\n\nMagnetization:\n A permanent magnetization, $\\M$, can be applied in the form\n  of a cylindrical magnet with poles at its circular ends. The command line\n  option is \n-bm\n which indicates a 'bar magnet'. The option requires the two\n  end points of the cylinder's axis, its radius, and the magnitude of the\n  magnetization.\n\n\nSurface Current Density:\n A surface current can be imposed indirectly by\n  specifying separate surface patches with different voltages as well as a\n  collection of surface patches connecting the voltages through which the\n  current will flow. The voltage surfaces and their voltages can be specified\n  using \n-vbcs\n followed by the indices of the surfaces and \n-vbcv\n followed by\n  their voltages. The path for the surface current ($\\vec{K}$) is specified by\n  using \n-kbcs\n followed by a set of surface indices.\n\n\nFor example, applying voltages 1 and -1 to surfaces 2 and 3 with a current\n  path along surfaces 4 and 6 would be specified as:\n  \n-vbcs '2 3' -vbcv '1 -1' -kbcs '4 6'\n.\n\n\nAny surfaces not listed as voltage or current surfaces will be assigned as\n  homogeneous Dirichlet boundaries. Note that when this option is selected an\n  auxiliary electrostatic problem will be solved on the surface of the\n  geometry to compute the surface current.\n\n\nDirichlet BC:\n Dirichlet boundary conditions are required if a surface\n  current density is not defined. For this reason the user need not specify\n  boundary surfaces by number since the boundary condition must be applied on\n  all of them. The default boundary condition is a homogeneous Dirichlet\n  boundary condition on all outer surfaces. This means that the normal\n  component of $\\B$ will be zero at the outer boundary. An alternative is to\n  specify a desired uniform magnetic flux density on the entire outer surface.\n  This is accomplished with the \n-ubbc\n command line option followed by the\n  desired $\\B$ vector.\n\n\nTransient Full-Wave Electromagnetics\n\n\nTransient electromagnetics problems are governed by the time-dependent\nMaxwell equations \\eqref{ampere} and \\eqref{faraday} when combined\nusing the constitutive relations \\eqref{const_d} and \\eqref{const_b}.\nWhen combined these equations can describe the evolution and\npropagation of electromagnetic waves.\n\n\n$$\\begin{align}\n    \\dd{(\\epsilon\\E)}{t} \n =   \\curl(\\mu^{-1}\\B) - \\sigma \\E - \\J  \\\\\n    \\dd{\\B}{t}           \n = - \\curl\\E\n  \\end{align}$$\n\n\nThe term $\\sigma\\E$ arises in the presence of electrically conductive\nmaterials where the electric field induces a current which can be\nseparated from $\\J$.  In such cases the total current appearing in\nAmp\u00e9re's Law \\eqref{ampere} can be expressed as the sum of an applied\ncurrent (also labeled as $\\J$) and an induced current $\\sigma\\E$.\n\n\nSolving these equations requires initial conditions for both the\nelectric and magnetic fields $\\E$ and $\\B$ as well as boundary\nconditions related to the tangential components of $\\E$ or $\\H$.\nOther formulations are possible such as evolving $\\H$ and $\\D$ or the\npotentials $\\varphi$ and $\\A$.  This system of equations can also be\nwritten as a single second order equation involving only $\\E$, $\\H$,\n$\\varphi$, or $\\A$.  Each of these formulations has a different set of\nsources, initial and boundary conditions for which it is well-suited.\nThe choice we make here is perhaps the most common but it may not be\nthe most convenient choice for a given application.\n\n\nThese equations can be used to evolve their initial conditions or they\ncan be driven by either a current source or through time-varying\nboundary conditions.  It is also possible to combine all three of\nthese sources in a single simulation.\n\n\nMaxwell Mini Application\n\n\nThe electrodynamics mini application, named \nmaxwell\n after James Clerk Maxwell\nwho first formulated the classical theory of electromagnetic radiation, is\nintended to demonstrate how to solve transient wave problems in MFEM. Its source\nterms and boundary conditions are simple but they should indicate how more\nspecialized sources or boundary conditions could be implemented.\n\n\nAn example simulation is depicted below (click to animate the wave propagation).\n\n\n\n\nTime integration is handled by a variable order symplectic time integration\nalgorithm.  This algorithm is designed for systems of equations which are\nderived from a Hamiltonian and it helps to ensure energy conservation within\nsome tolerance.  The time step used during integration is automatically chosen\nbased on the largest stable time step as computed from the largest eigenvalue of\nthe update equations.  This determination involves a user-adjustable factor\nwhich creates a safety margin.  By default the actual time step is less than 95%\nof the estimate for the largest stable time step.\n\n\nNote that this application assumes the mesh coordinates are given in meters.\nInternally the code assumes time is in seconds but the command line options use\nnanoseconds for convenience.\n\n\nMini Application Features\n\n\nTime Evolution:\n The initial and final times for the simulation can be\n  specified, in nanoseconds, with the \n-ti\n and \n-tf\n options.  Visualization\n  snapshots of data will be written out after time intervals specified by \n-ts\n\n  which again given in nanoseconds.  The order of the time integration can be\n  specified, from 1 to 4, using the \n-to\n option.\n\n\nPermittivity:\n The permittivity, $\\epsilon$, is assumed to be that of free\n  space except for an optional sphere of dielectric material which can be\n  defined by the user. The command line option \n-ds\n can be used to set the\n  parameters for this dielectric sphere. For example, to produce a sphere at the\n  origin with a radius of 0.5 and a relative permittivity of 3 the user would\n  specify: \n-ds '0 0 0 0.5 3'\n.\n\n\nPermeability:\n The permeability, $\\mu$, is assumed to be that of free space\n  except for an optional spherical shell of diamagnetic or paramagnetic material\n  which can be defined by the user. The command line option \n-ms\n can be used to\n  set the parameters for this shell.\n\n\nFor example, to produce a shell at the origin with inner and outer radii of\n  0.4 and 0.5 respectively and a relative permeability of 3 the user would\n  specify: \n-ms '0 0 0 0.4 0.5 3'\n.\n\n\nConductivity:\n The conductivity, $\\sigma$, is assumed to be zero except for\n  an optional sphere of conductive material which can be defined by the user.\n  The command line option \n-cs\n can be used to set the parameters for this\n  conductive sphere. For example, to produce a sphere at the origin with a\n  radius of 0.5 and a conductivity of 3,000,000 S/m the user would specify: \n-cs\n  '0 0 0 0.5 3e6'\n.\n\n\nCurrent Density:\n The current density, $\\J$, is assumed to be zero except for\n  an optional cylinder of pulsed current which can be defined by the user.  The\n  command line option for this is \n-dp\n, short for 'dipole pulse', which\n  requires two points giving the end points of the cylinder's axis, radius,\n  amplitude ($\\alpha$), pulse center ($\\beta$), and a pulse width ($\\gamma$).\n  The time dependence of this pulse is given by: $$\\J(t) = \\hat{a} \\alpha\n  e^{-(t-\\beta)^2/(2\\gamma^2)}$$ Where $\\hat{a}$ is the unit vector along the\n  cylinder's axis and both $\\beta$ and $\\gamma$ are specified in nanoseconds.\n\n\nDirichlet BC:\n Homogeneous Dirichlet boundary conditions, which constrain the\n  tangential components of $\\frac{\\partial\\E}{\\partial t}$ to be zero, can be\n  activated on a portion of the boundary by specifying a list of boundary\n  attributes such as \n-dbcs '4 8'\n.  For convenience a boundary attribute of\n  '-1' can be used to specify all boundary surfaces.  Non-Homogeneous,\n  time-dependent Dirichlet boundary conditions are supported by the Maxwell\n  solver so a user can edit \nmaxwell.cpp\n and supply their own function if\n  desired.\n\n\nAbsorbing BC:\n A first order Sommerfeld absorbing boundary condition can be\n  applied to a portion of the boundary using the \n-abcs\n option along with a\n  list of boundary attributes such as \n-abcs '4 18'\n.  Again, the special\n  purpose boundary attribute '-1' can be used to specify all boundary surfaces.\n  This boundary condition depends on a coefficient,\n  $\\eta^{-1}=\\sqrt{\\epsilon/\\mu}$, which must be matched to the materials just\n  inside the boundary.  The code assumes that the permittivity and permeability\n  are those of the vacuum near the surface but, if this is not the case, an\n  ambitious user can replace \netaInvCoef_\n with a more appropriate function.\n\n\nTransient Magnetics and Joule Heating\n\n\nJoule Mini Application\n\n\nThe transient magnetics mini application, named \njoule\n after the SI unit of energy (and the\nscientist James Prescott Joule, who was also a brewer), is intended to demonstrate how to solve\ntransient implicit diffusion problems. The equations of low-frequency electromagnetics are coupled\nwith the equations of heat transfer. The coupling is one way, electromagnetics generates Joule\nheating, but the heating does not affect the electromagnetics.  The thermal problem\nis solved using an $H(\\mathrm{div})$ method, i.e. temperature is discontinuous and the\nthermal flux $\\F$ is in $H(\\mathrm{div})$.\nThere are three linear solves per time step:\n\n\n\n\nPoisson's equation for the scalar electric potential is solved using the AMG\n preconditioner,\n\n\nthe electric diffusion equation is solved using the AMS preconditioner, and\n\n\nthe thermal diffusion equation is solved using the ADS preconditioner.\n\n\n\n\nTwo example meshes are provided, one is a straight circular metal rod in vacuum, the other is a helical\ncoil in vacuum (the latter is 21MB and can be downloaded from \nhere\n).\nThe idea is that a voltage is applied to the ends of the rod/coil, the electric field diffuses\ninto the metal, the metal is heated by Joule heating, the heat diffuses out.\n\n\nThe equations are:\n\n\n$$\\begin{align}\n    \\div\\sigma\\grad\\Phi \n= 0 \\\\\n    \\sigma \\E \n= \\curl\\mu^{-1} \\B - \\sigma \\grad \\Phi \\\\\n    \\frac{d \\B}{d t} \n= - \\curl \\E \\\\\n    \\F \n= -k \\grad T \\\\\n    c \\frac{d T}{d t} \n= - \\div \\F + \\sigma \\E \\cdot \\E\n  \\end{align}$$\n\n\nThe equations are integrated in time using implicit time integration, either midpoint or\nhigher order SDIRK.\n\n\nSince there are three solves,  three sets of boundary conditions must be specified. The\nessential BC's are the scalar potential, the electric field, and the thermal flux. These are not\nset via command line arguments, you have to edit the code to change these. To change these,\nsearch the code for \ness_bdr\n\n\nThere are conducting and non-conducting material regions, and the mesh must have integer attributes\nto specify these regions. To change these, search the code for \nstd::map\nint, double\n this maps the\ninteger attribute to the floating-point material value.\n\n\nNote that this application assumes the mesh coordinates are given in meters.\n\n\n\n\nThe above picture shows Joule heating of a cylinder using the mesh \ncylinder-hex.mesh\n. The cylinder is\nsurrounded by vacuum. The black arrows show the magnetic field $\\B$, the magenta arrows show the heat\nflux $\\F$, and the pseudocolor in the center of the cylinder shows the temperature.\n\n\nMini Application Features\n\n\nBoundary Conditions:\n Since there are three solves,  three sets of boundary conditions must be specified. The\nessential BC's are the voltage for the scalar potential, the tangential electric field, and the normal thermal flux.\nThese are not\nset via command line arguments, you have to edit the code to change these. To change these,\nsearch the code for \ness_bdr\n. Note that the essential BC's can be time varying.\n\n\nMaterial Properties:\n There are conducting and non-conducting material regions, and the mesh must have integer attributes\nto specify these regions. To change these, search the code for \nstd::map\nint, double\n this maps the\ninteger attribute to the floating-point material value.\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Electromagnetics"
        }, 
        {
            "location": "/electromagnetics/#electromagnetics-mini-applications", 
            "text": "$\\newcommand{\\A}{\\vec{A}}\\newcommand{\\B}{\\vec{B}}\n\\newcommand{\\D}{\\vec{D}}\\newcommand{\\E}{\\vec{E}}\n\\newcommand{\\H}{\\vec{H}}\\newcommand{\\J}{\\vec{J}}\n\\newcommand{\\M}{\\vec{M}}\\newcommand{\\P}{\\vec{P}}\n\\newcommand{\\F}{\\vec{F}}\n\\newcommand{\\dd}[2]{\\frac{\\partial #1}{\\partial #2}}\n\\newcommand{\\cross}{\\times}\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}$  The  miniapps/electromagnetics  directory contains a collection of\nelectromagnetic miniapps based on MFEM.  Compared to the  example codes , the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.  The current electromagnetic miniapps are described below.", 
            "title": "Electromagnetics Mini Applications"
        }, 
        {
            "location": "/electromagnetics/#electromagnetics", 
            "text": "The equations describing electromagnetic phenomena are known collectively as\nthe Maxwell Equations. They are usually given as:  $$\\begin{align}\n    \\curl\\H - \\dd{\\D}{t}   = \\J    \\label{ampere}  \\\\\n    \\curl\\E + \\dd{\\B}{t}   = 0     \\label{faraday} \\\\\n                  \\div\\D   = \\rho  \\label{gauss}   \\\\\n                  \\div\\B   = 0     \\label{divb}\n  \\end{align}$$  Where equation \\eqref{ampere} can be referred to as  Amp\u00e9re's Law , equation\n\\eqref{faraday} is called  Faraday's Law , equation \\eqref{gauss} is  Gauss's\nLaw , and equation \\eqref{divb} doesn't generally have a name but is related to\nthe nonexistence of magnetic monopoles. The various fields in these equations\nare:     Symbol  Name  SI Units      $\\H$  magnetic field  Ampere/meter    $\\B$  magnetic flux density  Tesla    $\\E$  electric field  Volts/meter    $\\D$  electric displacement  Coulomb/meter$^2$    $\\J$  current density  Ampere/meter$^2$    $\\rho$  charge density  Coulomb/meter$^3$     In the literature these names do vary, particularly those for $\\H$ and $\\B$,\nbut in this document we will try to adhere to the convention laid out above.  Generally we also need constitutive relations between $\\E$ and $\\D$ and/or\nbetween $\\H$ and $\\B$. These relations start with the definitions:  $$\\begin{align}\n    \\D   = \\epsilon_0\\E + \\P \\label{const_d}  \\\\\n    \\B   = \\mu_0(\\H + \\M)    \\label{const_b}\n  \\end{align}$$  Where $\\P$ is the  polarization density , and $\\M$ is the  magnetization .\nAlso, $\\epsilon_0$ is the  permittivity of free space  and $\\mu_0$ is the permeability of free space  which are both constants of nature. In many common\nmaterials the polarization density can be approximated as a scalar multiple of\nthe electric field, i.e., $\\P = \\epsilon_0\\chi\\E$, where $\\chi$ is called the electric susceptibility . In such cases we usually use the relation $\\D =\n\\epsilon\\E$ with $\\epsilon = \\epsilon_0(1 + \\chi)$ and call $\\epsilon$ the permittivity  of the material.  The nature of magnetization is more complicated but we will take a very\nsimplified view which is valid in many situations. Specifically, we will assume\nthat either $\\M$ is proportional to $\\H$ yielding the relation $\\B = \\mu\\H$\nwhere $\\mu = \\mu_0(1 + \\chi_M)$ and $\\chi_M$ is the  magnetic susceptibility \nor that $\\M$ is independent of the applied field. The former case pertains to\nboth diamagnetic and paramagnetic materials and the latter to ferromagnetic\nmaterials.  Finally we should note that equations \\eqref{ampere} and \\eqref{gauss} can be\ncombined to yield the equation of charge continuity $\\dd{\\rho}{t} + \\div\\J = 0$\nwhich can be important in plasma physics and magnetohydrodynamics (MHD).", 
            "title": "Electromagnetics"
        }, 
        {
            "location": "/electromagnetics/#electrostatics", 
            "text": "Electrostatic problems come in a variety of subtypes but they all derive from\nGauss's Law and Faraday's Law (equations \\eqref{gauss} and \\eqref{faraday}).\nWhen we assume no time variation, Faraday's Law becomes simply $\\curl\\E = 0$.\nThis suggests that the electric field can be expressed as the gradient of a\nscalar field which is traditionally taken to be $-\\varphi$, i.e.  $$\\E = -\\grad\\varphi   \\label{gradphi}$$  where $\\varphi$ is called the  electric potential  and has units of Volts in\nthe SI system. Inserting this definition into equation \\eqref{gauss} gives:  $$-\\div\\epsilon\\grad\\varphi = \\rho - \\div\\P   \\label{poisson}$$  which is  Poisson's equation  for the electric potential, where we have assumed\na linear constitutive relation between $\\D$ and $\\E$ of the form $\\D =\n\\epsilon\\E + \\P$. This allows a polarization which is proportional to $\\E$ as\nwell a polarization independent of $\\E$. If this relation happens to be\nnonlinear then Poisson's equation would need to be replaced with a more\ncomplicated nonlinear expression.  The solutions to equation \\eqref{poisson} are non unique because they can be\nshifted by any additive constant. This means that we must apply a Dirichlet\nboundary condition at least at one point in the problem domain in order to\nobtain a solution. Typically this point will be on the boundary but it need not\nbe so. Such a Dirichlet value is equivalent to fixing the voltage (a.k.a.\npotential) at one or more locations. Additionally, this equation admits a normal\nderivative boundary condition. This corresponds to setting $\\hat{n}\\cdot\\D$ to a\nprescribed value on some portion of the boundary. This is equivalent to defining\na surface charge density on that portion of the boundary.", 
            "title": "Electrostatics"
        }, 
        {
            "location": "/electromagnetics/#volta-mini-application", 
            "text": "The electrostatics mini application, named  volta  after the inventor of the voltaic pile , is intended to\ndemonstrate how to solve standard electrostatics problems in MFEM. Its source\nterms and boundary conditions are simple but they should indicate how more\nspecialized sources or boundary conditions could be implemented.   Note that this application assumes the mesh coordinates are given in meters.", 
            "title": "Volta Mini Application"
        }, 
        {
            "location": "/electromagnetics/#mini-application-features", 
            "text": "Permittivity:  The permittivity, $\\epsilon$, is assumed to be that of free\n  space except for an optional sphere of dielectric material which can be\n  defined by the user. The command line option  -ds  can be used to set the\n  parameters for this dielectric sphere. For example, to produce a sphere at the\n  origin with a radius of 0.5 and a relative permittivity of 3 the user would\n  specify:  -ds '0 0 0 0.5 3' .  Charge Density:  The charge density, $\\rho$, is assumed to be zero except for\n  an optional sphere of uniform charge density which can be defined by the user.\n  The command line option for this is  -cs  which follows the same pattern as\n  the dielectric sphere. Note that the last entry is the total charge of the\n  sphere and not its charge density.  Polarization:  A polarization vector function, $\\P$, can be imposed as a\n  source of the electric field. The command line option  -vp  creates a\n  polarization due to a simple voltaic pile, i.e., a cylinder which is\n  electrically polarized along its axis. The user should specify the two end\n  points of the cylinder axis, its radius and the magnitude of the polarization\n  vector.  Dirichlet BC:  Dirichlet boundary conditions can either specify piecewise\n  constant voltages on a collection of surfaces or they can specify a gradient\n  field which approximates a uniform applied electric field. In either case the\n  user specifies the surfaces where the Dirichlet boundary condition should be\n  applied using the  -dbcs  option followed by a list of boundary attributes.\n  For example to select surfaces 2, 3, and 4 the user would use the following:\n   -dbcs '2 3 4' .  To apply a gradient field on these surfaces the user would also use the\n   -dbcg  option. This defaults to the uniform field $\\E = (0,0,1)$ in 3D or\n  $\\E = (0,1)$ in 2D. An arbitrary vector can be specified with  -uebc \n  followed by the desired vector, e.g., to apply $\\E = (1,2,3)$ the user would\n  supply:  -uebc '1 2 3' .  To specify piecewise constant potential values the user would list the\n  desired values after  -dbcv  as follows:  -dbcv '0.0 1.0 -1.0' .  Neumann BC:  Neumann boundary conditions set the normal component of the\n  electric displacement on portions of the boundary. This normal component is\n  equivalent to the surface charge density on the surface. This is rarely used\n  because surface charge densities are rarely known unless they are know to be\n  zero. However, if the surface charge density is zero then the Neumann BCs are\n  not needed because this is the natural boundary condition. Only piecewise\n  constant Neumann boundary conditions are supported. They can be set\n  analogously to piecewise Dirichlet boundary conditions but using options\n   -nbcs  and  -nbcv .", 
            "title": "Mini Application Features"
        }, 
        {
            "location": "/electromagnetics/#magnetostatics", 
            "text": "Magnetostatic problems arise when we assume no time variation in Amp\u00e9re's Law\n\\eqref{ampere} which leads to:  $$\\curl\\H = \\J   \\nonumber$$  We will again assume a somewhat more general constitutive relation between $\\H$\nand $\\vec{B}$ than is normally seen:  $$\\B = \\mu\\H + \\mu_0\\M = \\mu_0(1 + \\chi_M)\\H + \\mu_0\\M   \\nonumber$$  Where the magnetization is split into two portions; one which is proportional\nto $\\H$ and given by $\\chi_M\\H$, and another which is independent of $\\H$ and\nis given by $\\M$. This allows for paramagnetic and/or diamagnetic materials\ndefined through $\\mu$ as well as ferromagnetic materials represented by $\\M$.\nThis choice yields:  $$\\curl\\mu^{-1}\\B = \\J + \\curl\\mu^{-1}\\mu_0\\M   \\nonumber$$  Which, when combined with equation \\eqref{divb}, becomes:  $$\\curl\\mu^{-1}\\curl\\A = \\J + \\curl\\mu^{-1}\\mu_0\\M $$  If $\\J$ happens to be zero we have another option because we can assume that\n$\\H = -\\grad\\varphi_M$ for some scalar potential $\\varphi_M$. When combined\nwith equation \\eqref{divb} this leads to:  $$\\div\\mu\\grad\\varphi_M = \\div\\mu_0\\M $$  Currently only the vector potential equation is used so we will focus on that\nfor the remainder of this document.  The vector potential is again non unique so we must apply additional\nconstraints in order to arrive at a solution for $\\A$. When working\nanalytically it is common to constrain the solution by restricting the\ndivergence of $\\A$ but numerically this leads to other complications. For our\nproblems of interest it will be necessary to require Dirichlet boundary\nconditions on the entire outer surface in order to sufficiently constrain the\nsolution.  Dirichlet boundary conditions for the vector potential on a surface provide a\nmeans to specify the component of $\\B$ normal to that surface. For example,\nsetting the tangential components of $\\A$ to be zero on a particular surface\nresults in a magnetic flux density which must be tangent to that surface.", 
            "title": "Magnetostatics"
        }, 
        {
            "location": "/electromagnetics/#tesla-mini-application", 
            "text": "The magnetostatics mini application, named  tesla  after the unit of magnetic\nfield strength (and of course the man Nikola Tesla), is intended to demonstrate\nhow to solve standard magnetostatics problems in MFEM. Its source terms and\nboundary conditions are simple but they should indicate how more specialized\nsources of boundary conditions could be implemented.   Note that this application assumes the mesh coordinates are given in meters.", 
            "title": "Tesla Mini Application"
        }, 
        {
            "location": "/electromagnetics/#mini-application-features_1", 
            "text": "Permeability:  The permeability, $\\mu$, is assumed to be that of free space\n  except for an optional spherical shell of diamagnetic or paramagnetic material\n  which can be defined by the user. The command line option  -ms  can be used to\n  set the parameters for this shell.  For example, to produce a shell at the origin with inner and outer radii of\n  0.4 and 0.5 respectively and a relative permeability of 3 the user would\n  specify:  -ms '0 0 0 0.4 0.5 3' .  Current Density:  The current density, $\\J$, is assumed to be zero except for\n  an optional ring of constant current which can be defined by the user. The\n  command line option for this is  -cr  which requires two points giving the end\n  points of the ring's axis, inner and outer radii, and a constant total\n  current.  For example, to specify a ring centered at the origin and laying in the XY\n  plane with a thickness of 0.2 and radii 0.4 and 0.5, and a current of 2 amps\n  the user would give:  -cr 0 0 -0.1 0 0 0.1 0.4 0.5 2 .  Magnetization:  A permanent magnetization, $\\M$, can be applied in the form\n  of a cylindrical magnet with poles at its circular ends. The command line\n  option is  -bm  which indicates a 'bar magnet'. The option requires the two\n  end points of the cylinder's axis, its radius, and the magnitude of the\n  magnetization.  Surface Current Density:  A surface current can be imposed indirectly by\n  specifying separate surface patches with different voltages as well as a\n  collection of surface patches connecting the voltages through which the\n  current will flow. The voltage surfaces and their voltages can be specified\n  using  -vbcs  followed by the indices of the surfaces and  -vbcv  followed by\n  their voltages. The path for the surface current ($\\vec{K}$) is specified by\n  using  -kbcs  followed by a set of surface indices.  For example, applying voltages 1 and -1 to surfaces 2 and 3 with a current\n  path along surfaces 4 and 6 would be specified as:\n   -vbcs '2 3' -vbcv '1 -1' -kbcs '4 6' .  Any surfaces not listed as voltage or current surfaces will be assigned as\n  homogeneous Dirichlet boundaries. Note that when this option is selected an\n  auxiliary electrostatic problem will be solved on the surface of the\n  geometry to compute the surface current.  Dirichlet BC:  Dirichlet boundary conditions are required if a surface\n  current density is not defined. For this reason the user need not specify\n  boundary surfaces by number since the boundary condition must be applied on\n  all of them. The default boundary condition is a homogeneous Dirichlet\n  boundary condition on all outer surfaces. This means that the normal\n  component of $\\B$ will be zero at the outer boundary. An alternative is to\n  specify a desired uniform magnetic flux density on the entire outer surface.\n  This is accomplished with the  -ubbc  command line option followed by the\n  desired $\\B$ vector.", 
            "title": "Mini Application Features"
        }, 
        {
            "location": "/electromagnetics/#transient-full-wave-electromagnetics", 
            "text": "Transient electromagnetics problems are governed by the time-dependent\nMaxwell equations \\eqref{ampere} and \\eqref{faraday} when combined\nusing the constitutive relations \\eqref{const_d} and \\eqref{const_b}.\nWhen combined these equations can describe the evolution and\npropagation of electromagnetic waves.  $$\\begin{align}\n    \\dd{(\\epsilon\\E)}{t}   =   \\curl(\\mu^{-1}\\B) - \\sigma \\E - \\J  \\\\\n    \\dd{\\B}{t}             = - \\curl\\E\n  \\end{align}$$  The term $\\sigma\\E$ arises in the presence of electrically conductive\nmaterials where the electric field induces a current which can be\nseparated from $\\J$.  In such cases the total current appearing in\nAmp\u00e9re's Law \\eqref{ampere} can be expressed as the sum of an applied\ncurrent (also labeled as $\\J$) and an induced current $\\sigma\\E$.  Solving these equations requires initial conditions for both the\nelectric and magnetic fields $\\E$ and $\\B$ as well as boundary\nconditions related to the tangential components of $\\E$ or $\\H$.\nOther formulations are possible such as evolving $\\H$ and $\\D$ or the\npotentials $\\varphi$ and $\\A$.  This system of equations can also be\nwritten as a single second order equation involving only $\\E$, $\\H$,\n$\\varphi$, or $\\A$.  Each of these formulations has a different set of\nsources, initial and boundary conditions for which it is well-suited.\nThe choice we make here is perhaps the most common but it may not be\nthe most convenient choice for a given application.  These equations can be used to evolve their initial conditions or they\ncan be driven by either a current source or through time-varying\nboundary conditions.  It is also possible to combine all three of\nthese sources in a single simulation.", 
            "title": "Transient Full-Wave Electromagnetics"
        }, 
        {
            "location": "/electromagnetics/#maxwell-mini-application", 
            "text": "The electrodynamics mini application, named  maxwell  after James Clerk Maxwell\nwho first formulated the classical theory of electromagnetic radiation, is\nintended to demonstrate how to solve transient wave problems in MFEM. Its source\nterms and boundary conditions are simple but they should indicate how more\nspecialized sources or boundary conditions could be implemented.  An example simulation is depicted below (click to animate the wave propagation).   Time integration is handled by a variable order symplectic time integration\nalgorithm.  This algorithm is designed for systems of equations which are\nderived from a Hamiltonian and it helps to ensure energy conservation within\nsome tolerance.  The time step used during integration is automatically chosen\nbased on the largest stable time step as computed from the largest eigenvalue of\nthe update equations.  This determination involves a user-adjustable factor\nwhich creates a safety margin.  By default the actual time step is less than 95%\nof the estimate for the largest stable time step.  Note that this application assumes the mesh coordinates are given in meters.\nInternally the code assumes time is in seconds but the command line options use\nnanoseconds for convenience.", 
            "title": "Maxwell Mini Application"
        }, 
        {
            "location": "/electromagnetics/#mini-application-features_2", 
            "text": "Time Evolution:  The initial and final times for the simulation can be\n  specified, in nanoseconds, with the  -ti  and  -tf  options.  Visualization\n  snapshots of data will be written out after time intervals specified by  -ts \n  which again given in nanoseconds.  The order of the time integration can be\n  specified, from 1 to 4, using the  -to  option.  Permittivity:  The permittivity, $\\epsilon$, is assumed to be that of free\n  space except for an optional sphere of dielectric material which can be\n  defined by the user. The command line option  -ds  can be used to set the\n  parameters for this dielectric sphere. For example, to produce a sphere at the\n  origin with a radius of 0.5 and a relative permittivity of 3 the user would\n  specify:  -ds '0 0 0 0.5 3' .  Permeability:  The permeability, $\\mu$, is assumed to be that of free space\n  except for an optional spherical shell of diamagnetic or paramagnetic material\n  which can be defined by the user. The command line option  -ms  can be used to\n  set the parameters for this shell.  For example, to produce a shell at the origin with inner and outer radii of\n  0.4 and 0.5 respectively and a relative permeability of 3 the user would\n  specify:  -ms '0 0 0 0.4 0.5 3' .  Conductivity:  The conductivity, $\\sigma$, is assumed to be zero except for\n  an optional sphere of conductive material which can be defined by the user.\n  The command line option  -cs  can be used to set the parameters for this\n  conductive sphere. For example, to produce a sphere at the origin with a\n  radius of 0.5 and a conductivity of 3,000,000 S/m the user would specify:  -cs\n  '0 0 0 0.5 3e6' .  Current Density:  The current density, $\\J$, is assumed to be zero except for\n  an optional cylinder of pulsed current which can be defined by the user.  The\n  command line option for this is  -dp , short for 'dipole pulse', which\n  requires two points giving the end points of the cylinder's axis, radius,\n  amplitude ($\\alpha$), pulse center ($\\beta$), and a pulse width ($\\gamma$).\n  The time dependence of this pulse is given by: $$\\J(t) = \\hat{a} \\alpha\n  e^{-(t-\\beta)^2/(2\\gamma^2)}$$ Where $\\hat{a}$ is the unit vector along the\n  cylinder's axis and both $\\beta$ and $\\gamma$ are specified in nanoseconds.  Dirichlet BC:  Homogeneous Dirichlet boundary conditions, which constrain the\n  tangential components of $\\frac{\\partial\\E}{\\partial t}$ to be zero, can be\n  activated on a portion of the boundary by specifying a list of boundary\n  attributes such as  -dbcs '4 8' .  For convenience a boundary attribute of\n  '-1' can be used to specify all boundary surfaces.  Non-Homogeneous,\n  time-dependent Dirichlet boundary conditions are supported by the Maxwell\n  solver so a user can edit  maxwell.cpp  and supply their own function if\n  desired.  Absorbing BC:  A first order Sommerfeld absorbing boundary condition can be\n  applied to a portion of the boundary using the  -abcs  option along with a\n  list of boundary attributes such as  -abcs '4 18' .  Again, the special\n  purpose boundary attribute '-1' can be used to specify all boundary surfaces.\n  This boundary condition depends on a coefficient,\n  $\\eta^{-1}=\\sqrt{\\epsilon/\\mu}$, which must be matched to the materials just\n  inside the boundary.  The code assumes that the permittivity and permeability\n  are those of the vacuum near the surface but, if this is not the case, an\n  ambitious user can replace  etaInvCoef_  with a more appropriate function.", 
            "title": "Mini Application Features"
        }, 
        {
            "location": "/electromagnetics/#transient-magnetics-and-joule-heating", 
            "text": "", 
            "title": "Transient Magnetics and Joule Heating"
        }, 
        {
            "location": "/electromagnetics/#joule-mini-application", 
            "text": "The transient magnetics mini application, named  joule  after the SI unit of energy (and the\nscientist James Prescott Joule, who was also a brewer), is intended to demonstrate how to solve\ntransient implicit diffusion problems. The equations of low-frequency electromagnetics are coupled\nwith the equations of heat transfer. The coupling is one way, electromagnetics generates Joule\nheating, but the heating does not affect the electromagnetics.  The thermal problem\nis solved using an $H(\\mathrm{div})$ method, i.e. temperature is discontinuous and the\nthermal flux $\\F$ is in $H(\\mathrm{div})$.\nThere are three linear solves per time step:   Poisson's equation for the scalar electric potential is solved using the AMG\n preconditioner,  the electric diffusion equation is solved using the AMS preconditioner, and  the thermal diffusion equation is solved using the ADS preconditioner.   Two example meshes are provided, one is a straight circular metal rod in vacuum, the other is a helical\ncoil in vacuum (the latter is 21MB and can be downloaded from  here ).\nThe idea is that a voltage is applied to the ends of the rod/coil, the electric field diffuses\ninto the metal, the metal is heated by Joule heating, the heat diffuses out.  The equations are:  $$\\begin{align}\n    \\div\\sigma\\grad\\Phi  = 0 \\\\\n    \\sigma \\E  = \\curl\\mu^{-1} \\B - \\sigma \\grad \\Phi \\\\\n    \\frac{d \\B}{d t}  = - \\curl \\E \\\\\n    \\F  = -k \\grad T \\\\\n    c \\frac{d T}{d t}  = - \\div \\F + \\sigma \\E \\cdot \\E\n  \\end{align}$$  The equations are integrated in time using implicit time integration, either midpoint or\nhigher order SDIRK.  Since there are three solves,  three sets of boundary conditions must be specified. The\nessential BC's are the scalar potential, the electric field, and the thermal flux. These are not\nset via command line arguments, you have to edit the code to change these. To change these,\nsearch the code for  ess_bdr  There are conducting and non-conducting material regions, and the mesh must have integer attributes\nto specify these regions. To change these, search the code for  std::map int, double  this maps the\ninteger attribute to the floating-point material value.  Note that this application assumes the mesh coordinates are given in meters.   The above picture shows Joule heating of a cylinder using the mesh  cylinder-hex.mesh . The cylinder is\nsurrounded by vacuum. The black arrows show the magnetic field $\\B$, the magenta arrows show the heat\nflux $\\F$, and the pseudocolor in the center of the cylinder shows the temperature.", 
            "title": "Joule Mini Application"
        }, 
        {
            "location": "/electromagnetics/#mini-application-features_3", 
            "text": "Boundary Conditions:  Since there are three solves,  three sets of boundary conditions must be specified. The\nessential BC's are the voltage for the scalar potential, the tangential electric field, and the normal thermal flux.\nThese are not\nset via command line arguments, you have to edit the code to change these. To change these,\nsearch the code for  ess_bdr . Note that the essential BC's can be time varying.  Material Properties:  There are conducting and non-conducting material regions, and the mesh must have integer attributes\nto specify these regions. To change these, search the code for  std::map int, double  this maps the\ninteger attribute to the floating-point material value.  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Mini Application Features"
        }, 
        {
            "location": "/meshing/", 
            "text": "Meshing\n\n\nThis page provides a brief description of MFEM's mesh formats, meshing mini applications, and related tools.\n\n\nMesh formats\n\n\nMFEM supports a number of mesh formats, including:\n\n\n\n\nMFEM's \nmesh v1.0 format\n for \nstraight\n meshes,\n\n\nMFEM's \nmesh v1.0 format\n for \narbitrary high-order curvilinear\n and more general meshes,\n\n\nMFEM's \nmesh v1.1 format\n, which adds support for non-conforming (AMR) meshes,\n\n\nMFEM's mesh v1.2 format, which adds support for parallel meshes,\n\n\nMFEM's format for \nNURBS\n meshes,\n\n\nThe \nVTK\n unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes,\n\n\nThe \nGmsh\n ASCII and binary formats for 2D and 3D meshes.\n\n\nThe \nCUBIT\n meshes through the Genesis (NetCDF) binary format.\n\n\nThe \nNETGEN\n triangular and tetrahedral mesh formats,\n\n\nThe \nTrueGrid\n hexahedral mesh format.\n\n\n\n\nDetailed description of these formats can be found on the \nmesh formats\n page. These formats are also supported by MFEM's native visualization tool, \nGLVis\n.\n\n\nMeshing miniapps\n\n\nThe \nminiapps/meshing\n directory contains a collection of meshing-related miniapps based on MFEM.\n\n\nCompared to the \nexample codes\n, the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.\n\n\nThe current meshing miniapps are described below. Related tools are listed at the \nbottom\n of the page.\n\n\nMobius Strip\n\n\nThis miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.\n\n\n\n\nManipulating the mesh topology and\nperforming mesh transformation are demonstrated. The \nmobius-strip\n mesh in the\n\ndata\n directory was generated with this miniapp.\n\n\nKlein Bottle\n\n\nThis miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.\n\n\n\n\nThe \nklein-bottle\n and \nklein-donut\n meshes in the\n\ndata\n directory were generated with this miniapp.\n\n\nToroid\n\n\nThis miniapp generates two types of toroidal volume meshes; one with\ntriangular cross sections and one with square cross sections.\n\n\n\n\nA wide variety of toroidal meshes can be generated by varying the\namount of twist as well as the major and minor radii and other\nvariables.  The \ntoroid-wedge\n and \ntoroid-hex\n meshes in the \ndata\n directory\nwere generated with this miniapp.\n\n\nExtruder\n\n\nThis miniapp creates higher dimensional meshes from lower dimensional meshes\nby extrusion.\n\n\n\n\nSimple coordinate transformations can also be applied if desired.  The initial\nmesh can be 1D or 2D. 1D meshes can be extruded in the y-direction first and\nthen in the z-direction.  2D meshes can be triangular, quadrilateral, or\ncontain both element types.\n\n\nShaper\n\n\nThis miniapp performs multiple levels of adaptive mesh refinement to resolve the\ninterfaces between different \"materials\" in the mesh, as specified by a given\nmaterial() function.\n\n\n\n\nIt can be used as a simple initial mesh generator, for example in the case when\nthe interface is too complex to describe without local refinement. Both\nconforming and non-conforming refinements are supported.\n\n\nMesh Explorer\n\n\nThis miniapp is a handy tool to examine, visualize and manipulate a given\nmesh.\n\n\n\n\nSome of its features are:\n\n\n\n\nvisualizing of mesh materials and individual mesh elements\n\n\nmesh scaling, randomization, and general transformation\n\n\nmanipulation of the mesh curvature\n\n\nthe ability to simulate parallel partitioning\n\n\nquantitative and visual reports of mesh quality\n\n\n\n\nMesh Optimizer\n\n\nThis miniapp performs mesh optimization using the Target-Matrix Optimization\nParadigm (TMOP) by P.Knupp et al., and a global variational minimization\napproach.\n\n\n\n\nIt minimizes the quantity $\\sum_T \\int_T \\mu(J(x))$, where $T$ are the target\n(ideal) elements, $J$ is the Jacobian of the transformation from the target\nto the physical element, and $\\mu$ is the mesh quality metric.\n\n\nThis metric can measure shape, size or alignment of the region around each\nquadrature point. The combination of targets and quality metrics is used to\noptimize the physical node positions, i.e., they must be as close as possible to\nthe shape / size / alignment of their targets.\n\n\nTools\n\n\nLow-Order Refined Transfer\n\n\nThe \nlor-transfer\n miniapp, found under \nminiapps/tools\n demonstrates the\ncapability to generate a \nlow-order refined\n mesh from a high-order mesh, and to\ntransfer solutions between these meshes.\n\n\n\n\nGrid functions can be transferred between the coarse, high-order mesh and the\nlow-order refined mesh using either $L^2$ projection or pointwise evaluation.\nThese transfer operators can be designed to discretely conserve mass and to\nrecover the original high-order solution when transferring a low-order grid\nfunction that was obtained by restricting a high-order grid function to the\nlow-order refined space.\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Meshing"
        }, 
        {
            "location": "/meshing/#meshing", 
            "text": "This page provides a brief description of MFEM's mesh formats, meshing mini applications, and related tools.", 
            "title": "Meshing"
        }, 
        {
            "location": "/meshing/#mesh-formats", 
            "text": "MFEM supports a number of mesh formats, including:   MFEM's  mesh v1.0 format  for  straight  meshes,  MFEM's  mesh v1.0 format  for  arbitrary high-order curvilinear  and more general meshes,  MFEM's  mesh v1.1 format , which adds support for non-conforming (AMR) meshes,  MFEM's mesh v1.2 format, which adds support for parallel meshes,  MFEM's format for  NURBS  meshes,  The  VTK  unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes,  The  Gmsh  ASCII and binary formats for 2D and 3D meshes.  The  CUBIT  meshes through the Genesis (NetCDF) binary format.  The  NETGEN  triangular and tetrahedral mesh formats,  The  TrueGrid  hexahedral mesh format.   Detailed description of these formats can be found on the  mesh formats  page. These formats are also supported by MFEM's native visualization tool,  GLVis .", 
            "title": "Mesh formats"
        }, 
        {
            "location": "/meshing/#meshing-miniapps", 
            "text": "The  miniapps/meshing  directory contains a collection of meshing-related miniapps based on MFEM.  Compared to the  example codes , the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.  The current meshing miniapps are described below. Related tools are listed at the  bottom  of the page.", 
            "title": "Meshing miniapps"
        }, 
        {
            "location": "/meshing/#mobius-strip", 
            "text": "This miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.   Manipulating the mesh topology and\nperforming mesh transformation are demonstrated. The  mobius-strip  mesh in the data  directory was generated with this miniapp.", 
            "title": "Mobius Strip"
        }, 
        {
            "location": "/meshing/#klein-bottle", 
            "text": "This miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.   The  klein-bottle  and  klein-donut  meshes in the data  directory were generated with this miniapp.", 
            "title": "Klein Bottle"
        }, 
        {
            "location": "/meshing/#toroid", 
            "text": "This miniapp generates two types of toroidal volume meshes; one with\ntriangular cross sections and one with square cross sections.   A wide variety of toroidal meshes can be generated by varying the\namount of twist as well as the major and minor radii and other\nvariables.  The  toroid-wedge  and  toroid-hex  meshes in the  data  directory\nwere generated with this miniapp.", 
            "title": "Toroid"
        }, 
        {
            "location": "/meshing/#extruder", 
            "text": "This miniapp creates higher dimensional meshes from lower dimensional meshes\nby extrusion.   Simple coordinate transformations can also be applied if desired.  The initial\nmesh can be 1D or 2D. 1D meshes can be extruded in the y-direction first and\nthen in the z-direction.  2D meshes can be triangular, quadrilateral, or\ncontain both element types.", 
            "title": "Extruder"
        }, 
        {
            "location": "/meshing/#shaper", 
            "text": "This miniapp performs multiple levels of adaptive mesh refinement to resolve the\ninterfaces between different \"materials\" in the mesh, as specified by a given\nmaterial() function.   It can be used as a simple initial mesh generator, for example in the case when\nthe interface is too complex to describe without local refinement. Both\nconforming and non-conforming refinements are supported.", 
            "title": "Shaper"
        }, 
        {
            "location": "/meshing/#mesh-explorer", 
            "text": "This miniapp is a handy tool to examine, visualize and manipulate a given\nmesh.   Some of its features are:   visualizing of mesh materials and individual mesh elements  mesh scaling, randomization, and general transformation  manipulation of the mesh curvature  the ability to simulate parallel partitioning  quantitative and visual reports of mesh quality", 
            "title": "Mesh Explorer"
        }, 
        {
            "location": "/meshing/#mesh-optimizer", 
            "text": "This miniapp performs mesh optimization using the Target-Matrix Optimization\nParadigm (TMOP) by P.Knupp et al., and a global variational minimization\napproach.   It minimizes the quantity $\\sum_T \\int_T \\mu(J(x))$, where $T$ are the target\n(ideal) elements, $J$ is the Jacobian of the transformation from the target\nto the physical element, and $\\mu$ is the mesh quality metric.  This metric can measure shape, size or alignment of the region around each\nquadrature point. The combination of targets and quality metrics is used to\noptimize the physical node positions, i.e., they must be as close as possible to\nthe shape / size / alignment of their targets.", 
            "title": "Mesh Optimizer"
        }, 
        {
            "location": "/meshing/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/meshing/#low-order-refined-transfer", 
            "text": "The  lor-transfer  miniapp, found under  miniapps/tools  demonstrates the\ncapability to generate a  low-order refined  mesh from a high-order mesh, and to\ntransfer solutions between these meshes.   Grid functions can be transferred between the coarse, high-order mesh and the\nlow-order refined mesh using either $L^2$ projection or pointwise evaluation.\nThese transfer operators can be designed to discretely conserve mass and to\nrecover the original high-order solution when transferring a low-order grid\nfunction that was obtained by restricting a high-order grid function to the\nlow-order refined space.  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Low-Order Refined Transfer"
        }, 
        {
            "location": "/mesh-formats/", 
            "text": "Mesh Formats\n\n\nMFEM mesh v1.0\n\n\nThis is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.\n\n\nStraight meshes\n\n\nIn the simple case of a mesh with straight edges the format looks as follows\n\n\nMFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension\n\ndimension\n\n\n# Mesh elements, e.g. tetrahedrons (4)\nelements\n\nnumber of elements\n\n\nelement attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary\n\nnumber of boundary elements\n\n\nboundary element attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Vertex coordinates\nvertices\n\nnumber of vertices\n\n\nvdim\n\n\ncoordinate 1\n ... \ncoordinate \nvdim\n\n...\n\n\n\n\nLines starting with \"#\" denote comments. The supported geometry types are:\n\n\n\n\nPOINT       = 0\n\n\nSEGMENT     = 1\n\n\nTRIANGLE    = 2\n\n\nSQUARE      = 3\n\n\nTETRAHEDRON = 4\n\n\nCUBE        = 5\n\n\nPRISM       = 6\n\n\n\n\nsee the comments in \nthis source file\n for more details.\n\n\nFor example, the \nbeam-quad.mesh\n file from the data directory looks like this:\n\n\nMFEM mesh v1.0\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 1 0\n3 1 2 1\n3 1 3 2\n3 1 4 3\n3 1 5 4\n3 1 6 5\n3 1 7 6\n3 1 8 7\n3 1 9 10\n3 1 10 11\n3 1 11 12\n3 1 12 13\n3 1 13 14\n3 1 14 15\n3 1 15 16\n3 1 16 17\n1 1 0 9\n2 1 17 8\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\n\n\nwhich corresponds to the mesh\n\n\n\n\nvisualized with\n\n\nglvis -m beam-quad.mesh -k \nAme****\n\n\n\n\n\nCurvilinear and more general meshes\n\n\nThe MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh. This general format is described briefly below, and in more details on the \nGeneral Mesh Format page\n.\n\n\nMFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension\n\ndimension\n\n\n# Mesh elements, e.g. tetrahedrons (4)\nelements\n\nnumber of elements\n\n\nelement attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary\n\nnumber of boundary elements\n\n\nboundary element attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Number of vertices (no coordinates)\nvertices\n\nnumber of vertices\n\n\n# Mesh nodes as degrees of freedom of a finite element grid function\nnodes\nFiniteElementSpace\nFiniteElementCollection: \nfinite element collection\n\nVDim: \ndimension\n\nOrdering: 0\n\nx-coordinate degrees of freedom\n\n...\n\ny-coordinate degrees of freedom\n\n...\n\nz-coordinate degrees of freedom\n\n...\n\n\n\n\nSome possible \nfinite element collection\n choices are: \nLinear\n, \nQuadratic\n and \nCubic\n corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in \nMFEM's source code\n.\n\n\nFor example, the \nescher-p3.mesh\n from MFEM's \ndata directory\n describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with\n\n\nglvis -m escher-p3.mesh -k \nAaaoooooooooo**************tt\n\n\n\n\n\nwe get:\n\n\n\n\nTopologically periodic meshes can also be described in this format, see for example the \nperiodic-segment\n, \nperiodic-square\n, and \nperiodic-cube\n meshes in the data directory, as well as \nExample 9\n.\n\n\nMFEM mesh v1.1\n\n\nThis format adds support for non-conforming (AMR) meshes. The sections\n\ndimension\n, \nelements\n, and \nboundary\n are the same as in MFEM mesh v1.0 and\nare followed by two new (optional) sections, \nvertex_parents\n and\n\ncoarse_elements\n:\n\n\n# Vertex hierarchy\nvertex_parents\n\nnumber of relations\n\n\nvertex index\n \nparent 1 index\n \nparent 2 index\n\n...\n\n# Element hierarchy\ncoarse_elements\n\nnumber of coarse elements\n\n\nrefinement type\n \nchild index 1\n ... \nchild index n\n\n...\n\n\n\n\nThese are followed by the standard sections \nvertices\n and \nnodes\n of the format\nMFEM mesh v1.0.\n\n\nThe new section \nvertex_parents\n identifies all vertices (by their zero-based\nindex) that have been created as new mid-edge vertices by adaptive refinement\nof elements. Each such vertex has exactly two \"parents\" identified again by two\nzero-based indices. This information is needed to construct constraining\nrelations in a mesh with hanging nodes. The order the vertex-parent relations\nare stated in the file is not significant.\n\n\nThe second optional section \ncoarse_elements\n describes the element refinement\nhierarchy. While the standard section \nelements\n lists all leaf elements of the\nrefinement tree, this section describes all elements that have been refined and\nare no longer active. Each line describes one such virtual element, its\nrefinement type and up to 8 children. Child indices between 0 and \nN-1\n refer\nto the \nN\n active elements in the \nelements\n section. A coarse element has an\nimplied index starting with \nN\n. A coarse element can refer to another coarse\nelement of \nindex \n= N\n, but only after such child has been defined in the\n\ncoarse_elements\n section. The hierarchy is thus represented from the bottom\nup. The refinement types are: 1=X, 2=Y, 4=Z, 3=XY, 5=XZ, 6=YZ, 7=XYZ, where X,\nY, Z refer to one or more splits in the respective axes of the element\nreference domain. If the entire section is missing, MFEM will not be able to\nderefine the mesh.\n\n\n\n\nThe files\n\namr-quad.mesh\n,\n\namr-hex.mesh\n and\n\nfichera-amr.mesh\n\n(above) in the \ndata\n directory are examples of AMR meshes.\n\n\nNURBS meshes\n\n\nMFEM provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general \ncurvilinear meshes\n where the NURBS nodes are specified as a grid function at the end of the mesh file.\n\n\nFor example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.)\n\n\nMFEM NURBS mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# SEGMENT     = 1\n# SQUARE      = 3\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n4\n1 3 0 1 5 4\n1 3 1 2 6 5\n1 3 2 3 7 6\n1 3 3 0 4 7\n\nboundary\n8\n1 1 0 1\n1 1 1 2\n1 1 2 3\n1 1 3 0\n1 1 5 4\n1 1 6 5\n1 1 7 6\n1 1 4 7\n\nedges\n12\n0 0 1\n0 4 5\n1 1 2\n1 5 6\n2 2 3\n2 6 7\n3 3 0\n3 7 4\n4 0 4\n4 1 5\n4 2 6\n4 3 7\n\nvertices\n8\n\nknotvectors\n5\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n\nweights\n1\n1\n1\n1\n1\n1\n1\n1\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n1\n1\n1\n0.853553391\n0.853553391\n0.853553391\n0.853553391\n\nFiniteElementSpace\nFiniteElementCollection: NURBS2\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n1 1\n0 1\n0.358578644 0.358578644\n0.641421356 0.358578644\n0.641421356 0.641421356\n0.358578644 0.641421356\n0.5 0\n0.5 0.217157288\n1 0.5\n0.782842712 0.5\n0.5 1\n0.5 0.782842712\n0 0.5\n0.217157288 0.5\n0.15 0.15\n0.85 0.15\n0.85 0.85\n0.15 0.85\n0.5  0.108578644\n0.891421356 0.5\n0.5 0.891421356\n0.108578644 0.5\n\n\n\n\nThis above file, as well as other examples of NURBS meshes, can be found in \nMFEM's data directory\n. It can be visualized directly with\n\n\nglvis -m square-disc-nurbs.mesh\n\n\n\n\nwhich after several refinements with the \"\ni\n\" key looks like\n\n\n\n\nTo explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the \nelements\n and \nboundary\n sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices.\n\n\nIn the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the \nedges\n section where the first index in each row refers to the knot vector id (from the following \nknotvectors\n section), while the remaining two indexes are the edge vertex numbers.\n\n\nThe position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding \nweights\n section.\n\n\nSome examples of VTK meshes can be found in MFEM's \ndata directory\n. Here is one of the 3D NURBS meshes\n\n\n\n\nThe image above was produced with some refinement (key \"\no\n\") and mouse manipulations from\n\n\nglvis -m pipe-nurbs.mesh\n\n\n\n\nSolutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh.\n\n\nglvis -m square-disc-nurbs.mesh -g sol.gf\n\n\n\n\n\n\nCurvilinear VTK meshes\n\n\nMFEM also supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the \nVTK file format documentation\n. The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the \nvtkBiQuadraticQuad\n and \nvtkTriQuadraticHexahedron\n classes. Currently VTK does not support cubic, and higher-order meshes.\n\n\nAs an example, consider a simple curved quadrilateral saved in a file \nquad.vtk\n:\n\n\n# vtk DataFile Version 3.0\nGenerated by MFEM\nASCII\nDATASET UNSTRUCTURED_GRID\nPOINTS 9 double\n0 0 0\n1 0 0\n1 1 0\n0.1 0.9 0\n0.5 -0.05 0\n0.9 0.5 0\n0.5 1 0\n0 0.5 0\n0.45 0.55 0\nCELLS 1 10\n9 0 1 2 3 4 5 6 7 8\nCELL_TYPES 1\n28\nCELL_DATA 1\nSCALARS material int\nLOOKUP_TABLE default\n1\n\n\n\n\nVisualizing it with \"\nglvis -m quad.vtk\n\" and typing \"\nAemiii\n\" in the GLVis window we get:\n\n\n\n\nThe \"\ni\n\" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g.,\n\n\nglvis -m quad.vtk -k \nAemIIiii\n\n\n\n\n\n\n\nHere is a slightly more complicated \nquadratic quadrilateral\n mesh example (the different colors in the GLVis window are used to distinguish neighboring elements):\n\n\nglvis -m star-q2.vtk -k \nAm\n\n\n\n\n\n\n\nMFEM and GLVis can also handle \nquadratic triangular\n meshes:\n\n\nglvis -m square-disc-p2.vtk -k \nAm\n\n\n\n\n\n\n\nAs well as \nquadratic tetrahedral\n and \nquadratic hexahedral\n VTK meshes:\n\n\nglvis -m escher-p2.vtk -k \nAaaooooo**************\n\n\n\n\n\n\n\nglvis -m fichera-q2.vtk -k \nAaaooooo******", 
            "title": "_Mesh Formats"
        }, 
        {
            "location": "/mesh-formats/#mesh-formats", 
            "text": "", 
            "title": "Mesh Formats"
        }, 
        {
            "location": "/mesh-formats/#mfem-mesh-v10", 
            "text": "This is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.", 
            "title": "MFEM mesh v1.0"
        }, 
        {
            "location": "/mesh-formats/#straight-meshes", 
            "text": "In the simple case of a mesh with straight edges the format looks as follows  MFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension dimension \n\n# Mesh elements, e.g. tetrahedrons (4)\nelements number of elements  element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary number of boundary elements  boundary element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Vertex coordinates\nvertices number of vertices  vdim  coordinate 1  ...  coordinate  vdim \n...  Lines starting with \"#\" denote comments. The supported geometry types are:   POINT       = 0  SEGMENT     = 1  TRIANGLE    = 2  SQUARE      = 3  TETRAHEDRON = 4  CUBE        = 5  PRISM       = 6   see the comments in  this source file  for more details.  For example, the  beam-quad.mesh  file from the data directory looks like this:  MFEM mesh v1.0\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 1 0\n3 1 2 1\n3 1 3 2\n3 1 4 3\n3 1 5 4\n3 1 6 5\n3 1 7 6\n3 1 8 7\n3 1 9 10\n3 1 10 11\n3 1 11 12\n3 1 12 13\n3 1 13 14\n3 1 14 15\n3 1 15 16\n3 1 16 17\n1 1 0 9\n2 1 17 8\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1  which corresponds to the mesh   visualized with  glvis -m beam-quad.mesh -k  Ame****", 
            "title": "Straight meshes"
        }, 
        {
            "location": "/mesh-formats/#curvilinear-and-more-general-meshes", 
            "text": "The MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh. This general format is described briefly below, and in more details on the  General Mesh Format page .  MFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension dimension \n\n# Mesh elements, e.g. tetrahedrons (4)\nelements number of elements  element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary number of boundary elements  boundary element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Number of vertices (no coordinates)\nvertices number of vertices \n\n# Mesh nodes as degrees of freedom of a finite element grid function\nnodes\nFiniteElementSpace\nFiniteElementCollection:  finite element collection \nVDim:  dimension \nOrdering: 0 x-coordinate degrees of freedom \n... y-coordinate degrees of freedom \n... z-coordinate degrees of freedom \n...  Some possible  finite element collection  choices are:  Linear ,  Quadratic  and  Cubic  corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in  MFEM's source code .  For example, the  escher-p3.mesh  from MFEM's  data directory  describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with  glvis -m escher-p3.mesh -k  Aaaoooooooooo**************tt   we get:   Topologically periodic meshes can also be described in this format, see for example the  periodic-segment ,  periodic-square , and  periodic-cube  meshes in the data directory, as well as  Example 9 .", 
            "title": "Curvilinear and more general meshes"
        }, 
        {
            "location": "/mesh-formats/#mfem-mesh-v11", 
            "text": "This format adds support for non-conforming (AMR) meshes. The sections dimension ,  elements , and  boundary  are the same as in MFEM mesh v1.0 and\nare followed by two new (optional) sections,  vertex_parents  and coarse_elements :  # Vertex hierarchy\nvertex_parents number of relations  vertex index   parent 1 index   parent 2 index \n...\n\n# Element hierarchy\ncoarse_elements number of coarse elements  refinement type   child index 1  ...  child index n \n...  These are followed by the standard sections  vertices  and  nodes  of the format\nMFEM mesh v1.0.  The new section  vertex_parents  identifies all vertices (by their zero-based\nindex) that have been created as new mid-edge vertices by adaptive refinement\nof elements. Each such vertex has exactly two \"parents\" identified again by two\nzero-based indices. This information is needed to construct constraining\nrelations in a mesh with hanging nodes. The order the vertex-parent relations\nare stated in the file is not significant.  The second optional section  coarse_elements  describes the element refinement\nhierarchy. While the standard section  elements  lists all leaf elements of the\nrefinement tree, this section describes all elements that have been refined and\nare no longer active. Each line describes one such virtual element, its\nrefinement type and up to 8 children. Child indices between 0 and  N-1  refer\nto the  N  active elements in the  elements  section. A coarse element has an\nimplied index starting with  N . A coarse element can refer to another coarse\nelement of  index  = N , but only after such child has been defined in the coarse_elements  section. The hierarchy is thus represented from the bottom\nup. The refinement types are: 1=X, 2=Y, 4=Z, 3=XY, 5=XZ, 6=YZ, 7=XYZ, where X,\nY, Z refer to one or more splits in the respective axes of the element\nreference domain. If the entire section is missing, MFEM will not be able to\nderefine the mesh.   The files amr-quad.mesh , amr-hex.mesh  and fichera-amr.mesh \n(above) in the  data  directory are examples of AMR meshes.", 
            "title": "MFEM mesh v1.1"
        }, 
        {
            "location": "/mesh-formats/#nurbs-meshes", 
            "text": "MFEM provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general  curvilinear meshes  where the NURBS nodes are specified as a grid function at the end of the mesh file.  For example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.)  MFEM NURBS mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# SEGMENT     = 1\n# SQUARE      = 3\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n4\n1 3 0 1 5 4\n1 3 1 2 6 5\n1 3 2 3 7 6\n1 3 3 0 4 7\n\nboundary\n8\n1 1 0 1\n1 1 1 2\n1 1 2 3\n1 1 3 0\n1 1 5 4\n1 1 6 5\n1 1 7 6\n1 1 4 7\n\nedges\n12\n0 0 1\n0 4 5\n1 1 2\n1 5 6\n2 2 3\n2 6 7\n3 3 0\n3 7 4\n4 0 4\n4 1 5\n4 2 6\n4 3 7\n\nvertices\n8\n\nknotvectors\n5\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n\nweights\n1\n1\n1\n1\n1\n1\n1\n1\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n1\n1\n1\n0.853553391\n0.853553391\n0.853553391\n0.853553391\n\nFiniteElementSpace\nFiniteElementCollection: NURBS2\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n1 1\n0 1\n0.358578644 0.358578644\n0.641421356 0.358578644\n0.641421356 0.641421356\n0.358578644 0.641421356\n0.5 0\n0.5 0.217157288\n1 0.5\n0.782842712 0.5\n0.5 1\n0.5 0.782842712\n0 0.5\n0.217157288 0.5\n0.15 0.15\n0.85 0.15\n0.85 0.85\n0.15 0.85\n0.5  0.108578644\n0.891421356 0.5\n0.5 0.891421356\n0.108578644 0.5  This above file, as well as other examples of NURBS meshes, can be found in  MFEM's data directory . It can be visualized directly with  glvis -m square-disc-nurbs.mesh  which after several refinements with the \" i \" key looks like   To explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the  elements  and  boundary  sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices.  In the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the  edges  section where the first index in each row refers to the knot vector id (from the following  knotvectors  section), while the remaining two indexes are the edge vertex numbers.  The position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding  weights  section.  Some examples of VTK meshes can be found in MFEM's  data directory . Here is one of the 3D NURBS meshes   The image above was produced with some refinement (key \" o \") and mouse manipulations from  glvis -m pipe-nurbs.mesh  Solutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh.  glvis -m square-disc-nurbs.mesh -g sol.gf", 
            "title": "NURBS meshes"
        }, 
        {
            "location": "/mesh-formats/#curvilinear-vtk-meshes", 
            "text": "MFEM also supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the  VTK file format documentation . The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the  vtkBiQuadraticQuad  and  vtkTriQuadraticHexahedron  classes. Currently VTK does not support cubic, and higher-order meshes.  As an example, consider a simple curved quadrilateral saved in a file  quad.vtk :  # vtk DataFile Version 3.0\nGenerated by MFEM\nASCII\nDATASET UNSTRUCTURED_GRID\nPOINTS 9 double\n0 0 0\n1 0 0\n1 1 0\n0.1 0.9 0\n0.5 -0.05 0\n0.9 0.5 0\n0.5 1 0\n0 0.5 0\n0.45 0.55 0\nCELLS 1 10\n9 0 1 2 3 4 5 6 7 8\nCELL_TYPES 1\n28\nCELL_DATA 1\nSCALARS material int\nLOOKUP_TABLE default\n1  Visualizing it with \" glvis -m quad.vtk \" and typing \" Aemiii \" in the GLVis window we get:   The \" i \" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g.,  glvis -m quad.vtk -k  AemIIiii    Here is a slightly more complicated  quadratic quadrilateral  mesh example (the different colors in the GLVis window are used to distinguish neighboring elements):  glvis -m star-q2.vtk -k  Am    MFEM and GLVis can also handle  quadratic triangular  meshes:  glvis -m square-disc-p2.vtk -k  Am    As well as  quadratic tetrahedral  and  quadratic hexahedral  VTK meshes:  glvis -m escher-p2.vtk -k  Aaaooooo**************    glvis -m fichera-q2.vtk -k  Aaaooooo******", 
            "title": "Curvilinear VTK meshes"
        }, 
        {
            "location": "/mesh-format-v1.x/", 
            "text": "General MFEM Mesh Format\n\n\nThe MFEM mesh v1.x format supports the general description of meshes based on a vector finite element grid function with degrees of freedom in the \nnodes\n of the mesh. For simplicity, in this document we refer to this version of the format as \nMFEM mesh v1.x\n. The legacy version for meshes with straight edges we will call \nMFEM linear mesh\n format.\n\n\nA mesh in the \nMFEM mesh v1.x\n format consists of two parts: Topology and Geometry. We illustrate these concepts by comparing with the \nbeam-quad.mesh\n from MFEM's \ndata/\n directory. This is just a simple quadrilateral beam mesh with 8 elements, 18 vertices (numbered 0 to 17) and 18 boundary segments:\n\n\n\n\nThe original linear mesh version of this file is given in \nListing 1\n.\n\n\nTopology\n\n\nThe topological part of the mesh describes the relations between the elements in the mesh, in terms of neighborhood implied by shared vertices. Actual coordinates do not play a role in this part, so the \nvertices\n are just labels used to imply which elements share a vertex, an edge or a face.\n\n\nSome examples:\n\n\nGeneral version of \ndata/beam-quad.mesh\n\n\nBelow is the annotated topological part of the \nMFEM mesh v1.x\n format for the beam mesh. The complete file is given in \nListing 2\n.\n\n\n...\n# BEGIN Topology Part\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n# Skipping the 18 boundary segments for simplicity\n\nvertices\n18\n\n# END Topology Part\n...\n\n\n\n\nThe element format above is: \nattribute\n \ntype\n \nvertex1\n ... \nvertexN\n. Type \n3\n is quadrilateral, which requires 4 vertex indices. The \nattribute\n identify e.g. material sub-domains (2 in this case).\n\n\nNOTE:\n The topology part of this mesh will be the same, irrespective of the order. Compare e.g. \nListing 2\n, \nListing 3\n and \nListing 4\n.\n\n\nWARNING:\n The vertices are used only to imply topology, and so there coordinates are not important. The mesh coordinates are implied by the mesh \nnodes\n not \nvertices\n. In particular, while the \nMesh\n object can return vertex coordinates, they are not used an may be incorrect for high-order mesh.\n\n\nPeriodic version of \ndata/beam-quad.mesh\n\n\nThe topology part can be used to describe more complicated mesh relations. For example we can identify the two vertical lines of the beam mesh, turning it topologically into a\ncylinder. The complete file is given in \nListing 5\n.\n\n\n...\n# BEGIN Topology Part\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 0 9 16   # Last element uses vertices 0 and 9\n\n# two vertical boundary have been removed\nboundary\n16\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 0\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 9 16\n\nvertices\n16\n\n# END Topology Part\n...\n\n\n\n\nCompared to the non-periodic version, e.g. \nListing 2\n, the main difference above is that we have fused vertices 8 and 0 and vertices 17 and 9.\n\n\nThe difference between the two topologies can be illustrated by solving a simple Laplace problem with homogeneous essential boundary conditions on the resulting mesh.\n\n\nIn the periodic case we get:\n\n\n\n\nwhile the solution on the non-periodic mesh looks like:\n\n\n\n\nNOTE:\n Meshes with periodic topology allow us to solve problems with periodic boundary conditions without modifying the application to impose them -- we simply run on a different mesh.\n\n\nGeometry\n\n\nThe geometry of the mesh, i.e. the actual position of mesh elements in physical space is described by specifying the mesh \nnodes\n as a general finite element (vector) function.\n\n\nIn MFEM, finite element functions are objects of type \nGridFunction\n which belong to discrete finite element spaces specified by objects \nFiniteElementSpace\n and \nFiniteElementCollection\n.\n\n\nThe actual geometry of each element is obtained by extracting the local degrees of freedom from the global \nnodes\n, expanding them in the corresponding (reference element) finite element basis, and using the resulting polynomial vector field to map the reference element.\n\n\nAn example of a first order geometry is given in \nListing 2\n:\n\n\n...\n# BEGIN Geometry Part\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: H1_2D_P1\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n# END Geometry Part\n\n\n\n\nHere \nVDim: 2\n means that the \nnodes\n grid function is a vector field with two components (i.e. the mesh is embedded in R^2); \nH1_2D_P1\n describes the finite element space (H1/continuous finite elements in 2D of order 1); \nOrdering\n refers to how the vector field values are serialized (in this case x,y,x,y,...); and the rest is just the global degrees of freedom representing in this case the vertex coordinates.\n\n\nCompare the above with the linear mesh vertex coordinates from \nListing 1\n:\n\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\n\n\n\nIn the MFEM mesh v1.x format, the \nnodes\n are a regular grid function, just like an other discretized field in a simulation, which has several advantages:\n\n\n\n\nThe \nnodes\n can be part of the discretization, and be evolved directly e.g. in a Lagrangian/ALE simulation.\n\n\nMesh optimization problems can be posed directly for the \nnodes\n variable.\n\n\nSince the \nnodes\n can be any finite element function, a wide variety of meshes are easily supported.\n\n\n\n\nAs an illustration of the last point, consider the geometry of the periodic version of the mesh in \nListing 5\n\n\n...\n# BEGIN Geometry Part\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: L2_T1_2D_P1\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n0 1\n1 1\n\n1 0\n2 0\n1 1\n2 1\n\n2 0\n3 0\n2 1\n3 1\n\n3 0\n4 0\n3 1\n4 1\n\n4 0\n5 0\n4 1\n5 1\n\n5 0\n6 0\n5 1\n6 1\n\n6 0\n7 0\n6 1\n7 1\n\n7 0\n8 0\n7 1\n8 1\n\n8 0\n9 0\n8 1\n9 1\n\n9 0\n10 0\n9 1\n10 1\n# END Geometry Part\n...\n\n\n\n\nNote that the space here is \nL2\n, which means a discontinuous linear vector field, where four vertex coordinates are specified on each element. This allows us to plot the periodic mesh as a regular beam, which is what you'd expect for periodic boundary conditions.\n\n\nFinite Element Spaces\n\n\nTo fully specify the  MFEM mesh v1.x format, we need to describe the degrees of freedom of the \nnodes\n finite element space and their global numbering.\n\n\nThis is something that the MFEM team is very interested to discuss and standardize with other high-order projects and applications. Below is a description of our current approach...\n\n\nFinite element spaces have degrees of freedom (dofs) that are associated with the (interiors of the) mesh vertices, edges, faces and elements.\nThere may be multiple dofs associated with the same geometric entity (e.g. vector fields), and different spaces have different sets of degrees of freedom.\nFor example H1/continuous spaces can have degrees of freedom associated with the Gauss-Lobatto points in a quadrilateral, while L2/discontinuous spaces can have degrees of freedom associated with the Gauss-Legendre points.\nThese are just examples, many choices for the basis are actually possible to be encoded in the \nFiniteElementCollection\n string above.\n\n\nIn general, based just on the mesh topology and the type of the space, the \nFiniteElementSpace\n object can determine a global set of dofs, that will be the values listed for the mesh \nnodes\n.\n\n\nThe algorithm starts with the given numbering of the elements and the vertices, from which a numbering of the edges and the faces is derived as follows:\n\n\nloop over elements\n  loop over edges and faces inside each element (clock-wise)\n    number currently the edges and faces that have not been numbered yet\n\n\n\n\nHere is the result of this numbering for the beam mesh\n\n\n\n\nIn addition to a number, each edges and face is also given a global orientation.\n\n\nIn 2D and 3D, an edge is oriented from the vertex with the lower vertex id to the vertex with the higher vertex id.\n\n\nIn 3D, a face is oriented according to the face-to-vertex mappings in the first element in which the face is enumerated. See the \nfem/geom.cpp\n for the definitions of the \ntetrahedral\n and \nhexahedral\n mappings on the reference element, as well as the \nMesh::GenerateFaces\n method in \nmesh/mesh.cpp\n. In particular, the normal of the face between two elements points from the element with lower number to the element with higher number. Face orientation however includes not just the normal direction, but also any rotation of the vertices compared to the base, i.e. \norientation\n here means permutation of vertices.\n\n\nThe global numbering of degrees of freedom is now performed as follows:\n\n\nloop over vertices\n  list the dofs associated with each vertex\n\nloop over edges\n  list the dofs associated with the interior of the edge,\n  lexicographically with respect to the edge orientation\n\nloop over faces\n  list the dofs associated with the interior of the face,\n  lexicographically with respect to the face orientation\n\nloop over elements\n  list the dofs associated with the interior of the element\n\n\n\n\nAn example of this is the quadratic mesh in  \nListing 3\n\n\n...\n# BEGIN Geometry Part\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: H1_2D_P2\nVDim: 2\nOrdering: 1\n\n# 18 vertex dofs\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n# 25 edge dofs\n0.5 0\n1 0.5\n0.5 1\n0 0.5\n1.5 0\n2 0.5\n1.5 1\n2.5 0\n3 0.5\n2.5 1\n3.5 0\n4 0.5\n3.5 1\n4.5 0\n5 0.5\n4.5 1\n5.5 0\n6 0.5\n5.5 1\n6.5 0\n7 0.5\n6.5 1\n7.5 0\n8 0.5\n7.5 1\n\n# 8 element dofs\n0.5 0.5\n1.5 0.5\n2.5 0.5\n3.5 0.5\n4.5 0.5\n5.5 0.5\n6.5 0.5\n7.5 0.5\n\n# END Geometry Part\n...\n\n\n\n\nListings\n\n\nListing 1\n\n\nThis is the original version of the \nbeam-quad.mesh\n using the linear mesh format.\n\n\nMFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 8\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 17 16\n1 1 9 0\n2 1 8 17\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\n\n\n\nListing 2\n\n\nThis is a \nMFEM mesh v1.x\n version of the \nbeam-quad.mesh\n which is first order. The mesh is identical to the one of \nListing 1\n, it is just described in a different format.\n\n\nMFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 8\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 17 16\n1 1 9 0\n2 1 8 17\n\nvertices\n18\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: H1_2D_P1\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\n\n\nListing 3\n\n\nThis is a second order version of the \nbeam-quad.mesh\n.\n\n\nMFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 8\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 17 16\n1 1 9 0\n2 1 8 17\n\nvertices\n18\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: H1_2D_P2\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n0.5 0\n1 0.5\n0.5 1\n0 0.5\n1.5 0\n2 0.5\n1.5 1\n2.5 0\n3 0.5\n2.5 1\n3.5 0\n4 0.5\n3.5 1\n4.5 0\n5 0.5\n4.5 1\n5.5 0\n6 0.5\n5.5 1\n6.5 0\n7 0.5\n6.5 1\n7.5 0\n8 0.5\n7.5 1\n0.5 0.5\n1.5 0.5\n2.5 0.5\n3.5 0.5\n4.5 0.5\n5.5 0.5\n6.5 0.5\n7.5 0.5\n\n\n\n\nListing 4\n\n\nThis is a third order version of the \nbeam-quad.mesh\n.\n\n\nMFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 8\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 17 16\n1 1 9 0\n2 1 8 17\n\nvertices\n18\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: H1_2D_P3\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n0.27639320225002 0\n0.72360679774998 0\n1 0.27639320225002\n1 0.72360679774998\n0.27639320225002 1\n0.72360679774998 1\n0 0.27639320225002\n0 0.72360679774998\n1.27639320225 0\n1.72360679775 0\n2 0.27639320225002\n2 0.72360679774998\n1.27639320225 1\n1.72360679775 1\n2.27639320225 0\n2.72360679775 0\n3 0.27639320225002\n3 0.72360679774998\n2.27639320225 1\n2.72360679775 1\n3.27639320225 0\n3.72360679775 0\n4 0.27639320225002\n4 0.72360679774998\n3.27639320225 1\n3.72360679775 1\n4.27639320225 0\n4.72360679775 0\n5 0.27639320225002\n5 0.72360679774998\n4.27639320225 1\n4.72360679775 1\n5.27639320225 0\n5.72360679775 0\n6 0.27639320225002\n6 0.72360679774998\n5.27639320225 1\n5.72360679775 1\n6.27639320225 0\n6.72360679775 0\n7 0.27639320225002\n7 0.72360679774998\n6.27639320225 1\n6.72360679775 1\n7.27639320225 0\n7.72360679775 0\n8 0.27639320225002\n8 0.72360679774998\n7.27639320225 1\n7.72360679775 1\n0.27639320225002 0.27639320225002\n0.72360679774998 0.27639320225002\n0.27639320225002 0.72360679774998\n0.72360679774998 0.72360679774998\n1.27639320225 0.27639320225002\n1.72360679775 0.27639320225002\n1.27639320225 0.72360679774998\n1.72360679775 0.72360679774998\n2.27639320225 0.27639320225002\n2.72360679775 0.27639320225002\n2.27639320225 0.72360679774998\n2.72360679775 0.72360679774998\n3.27639320225 0.27639320225002\n3.72360679775 0.27639320225002\n3.27639320225 0.72360679774998\n3.72360679775 0.72360679774998\n4.27639320225 0.27639320225002\n4.72360679775 0.27639320225002\n4.27639320225 0.72360679774998\n4.72360679775 0.72360679774998\n5.27639320225 0.27639320225002\n5.72360679775 0.27639320225002\n5.27639320225 0.72360679774998\n5.72360679775 0.72360679774998\n6.27639320225 0.27639320225002\n6.72360679775 0.27639320225002\n6.27639320225 0.72360679774998\n6.72360679775 0.72360679774998\n7.27639320225 0.27639320225002\n7.72360679775 0.27639320225002\n7.27639320225 0.72360679774998\n7.72360679775 0.72360679774998\n\n\n\n\nListing 5\n\n\nPeriodic version of the first-order mesh from \nListing 1\n.\n\n\nMFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 0 9 16\n\nboundary\n16\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 0\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 9 16\n\nvertices\n16\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: L2_T1_2D_P1\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n0 1\n1 1\n\n1 0\n2 0\n1 1\n2 1\n\n2 0\n3 0\n2 1\n3 1\n\n3 0\n4 0\n3 1\n4 1\n\n4 0\n5 0\n4 1\n5 1\n\n5 0\n6 0\n5 1\n6 1\n\n6 0\n7 0\n6 1\n7 1\n\n7 0\n8 0\n7 1\n8 1\n\n8 0\n9 0\n8 1\n9 1\n\n9 0\n10 0\n9 1\n10 1", 
            "title": "_Mesh Format v1.x"
        }, 
        {
            "location": "/mesh-format-v1.x/#general-mfem-mesh-format", 
            "text": "The MFEM mesh v1.x format supports the general description of meshes based on a vector finite element grid function with degrees of freedom in the  nodes  of the mesh. For simplicity, in this document we refer to this version of the format as  MFEM mesh v1.x . The legacy version for meshes with straight edges we will call  MFEM linear mesh  format.  A mesh in the  MFEM mesh v1.x  format consists of two parts: Topology and Geometry. We illustrate these concepts by comparing with the  beam-quad.mesh  from MFEM's  data/  directory. This is just a simple quadrilateral beam mesh with 8 elements, 18 vertices (numbered 0 to 17) and 18 boundary segments:   The original linear mesh version of this file is given in  Listing 1 .", 
            "title": "General MFEM Mesh Format"
        }, 
        {
            "location": "/mesh-format-v1.x/#topology", 
            "text": "The topological part of the mesh describes the relations between the elements in the mesh, in terms of neighborhood implied by shared vertices. Actual coordinates do not play a role in this part, so the  vertices  are just labels used to imply which elements share a vertex, an edge or a face.  Some examples:", 
            "title": "Topology"
        }, 
        {
            "location": "/mesh-format-v1.x/#general-version-of-databeam-quadmesh", 
            "text": "Below is the annotated topological part of the  MFEM mesh v1.x  format for the beam mesh. The complete file is given in  Listing 2 .  ...\n# BEGIN Topology Part\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n# Skipping the 18 boundary segments for simplicity\n\nvertices\n18\n\n# END Topology Part\n...  The element format above is:  attribute   type   vertex1  ...  vertexN . Type  3  is quadrilateral, which requires 4 vertex indices. The  attribute  identify e.g. material sub-domains (2 in this case).  NOTE:  The topology part of this mesh will be the same, irrespective of the order. Compare e.g.  Listing 2 ,  Listing 3  and  Listing 4 .  WARNING:  The vertices are used only to imply topology, and so there coordinates are not important. The mesh coordinates are implied by the mesh  nodes  not  vertices . In particular, while the  Mesh  object can return vertex coordinates, they are not used an may be incorrect for high-order mesh.", 
            "title": "General version of data/beam-quad.mesh"
        }, 
        {
            "location": "/mesh-format-v1.x/#periodic-version-of-databeam-quadmesh", 
            "text": "The topology part can be used to describe more complicated mesh relations. For example we can identify the two vertical lines of the beam mesh, turning it topologically into a\ncylinder. The complete file is given in  Listing 5 .  ...\n# BEGIN Topology Part\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 0 9 16   # Last element uses vertices 0 and 9\n\n# two vertical boundary have been removed\nboundary\n16\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 0\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 9 16\n\nvertices\n16\n\n# END Topology Part\n...  Compared to the non-periodic version, e.g.  Listing 2 , the main difference above is that we have fused vertices 8 and 0 and vertices 17 and 9.  The difference between the two topologies can be illustrated by solving a simple Laplace problem with homogeneous essential boundary conditions on the resulting mesh.  In the periodic case we get:   while the solution on the non-periodic mesh looks like:   NOTE:  Meshes with periodic topology allow us to solve problems with periodic boundary conditions without modifying the application to impose them -- we simply run on a different mesh.", 
            "title": "Periodic version of data/beam-quad.mesh"
        }, 
        {
            "location": "/mesh-format-v1.x/#geometry", 
            "text": "The geometry of the mesh, i.e. the actual position of mesh elements in physical space is described by specifying the mesh  nodes  as a general finite element (vector) function.  In MFEM, finite element functions are objects of type  GridFunction  which belong to discrete finite element spaces specified by objects  FiniteElementSpace  and  FiniteElementCollection .  The actual geometry of each element is obtained by extracting the local degrees of freedom from the global  nodes , expanding them in the corresponding (reference element) finite element basis, and using the resulting polynomial vector field to map the reference element.  An example of a first order geometry is given in  Listing 2 :  ...\n# BEGIN Geometry Part\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: H1_2D_P1\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n# END Geometry Part  Here  VDim: 2  means that the  nodes  grid function is a vector field with two components (i.e. the mesh is embedded in R^2);  H1_2D_P1  describes the finite element space (H1/continuous finite elements in 2D of order 1);  Ordering  refers to how the vector field values are serialized (in this case x,y,x,y,...); and the rest is just the global degrees of freedom representing in this case the vertex coordinates.  Compare the above with the linear mesh vertex coordinates from  Listing 1 :  vertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1  In the MFEM mesh v1.x format, the  nodes  are a regular grid function, just like an other discretized field in a simulation, which has several advantages:   The  nodes  can be part of the discretization, and be evolved directly e.g. in a Lagrangian/ALE simulation.  Mesh optimization problems can be posed directly for the  nodes  variable.  Since the  nodes  can be any finite element function, a wide variety of meshes are easily supported.   As an illustration of the last point, consider the geometry of the periodic version of the mesh in  Listing 5  ...\n# BEGIN Geometry Part\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: L2_T1_2D_P1\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n0 1\n1 1\n\n1 0\n2 0\n1 1\n2 1\n\n2 0\n3 0\n2 1\n3 1\n\n3 0\n4 0\n3 1\n4 1\n\n4 0\n5 0\n4 1\n5 1\n\n5 0\n6 0\n5 1\n6 1\n\n6 0\n7 0\n6 1\n7 1\n\n7 0\n8 0\n7 1\n8 1\n\n8 0\n9 0\n8 1\n9 1\n\n9 0\n10 0\n9 1\n10 1\n# END Geometry Part\n...  Note that the space here is  L2 , which means a discontinuous linear vector field, where four vertex coordinates are specified on each element. This allows us to plot the periodic mesh as a regular beam, which is what you'd expect for periodic boundary conditions.", 
            "title": "Geometry"
        }, 
        {
            "location": "/mesh-format-v1.x/#finite-element-spaces", 
            "text": "To fully specify the  MFEM mesh v1.x format, we need to describe the degrees of freedom of the  nodes  finite element space and their global numbering.  This is something that the MFEM team is very interested to discuss and standardize with other high-order projects and applications. Below is a description of our current approach...  Finite element spaces have degrees of freedom (dofs) that are associated with the (interiors of the) mesh vertices, edges, faces and elements.\nThere may be multiple dofs associated with the same geometric entity (e.g. vector fields), and different spaces have different sets of degrees of freedom.\nFor example H1/continuous spaces can have degrees of freedom associated with the Gauss-Lobatto points in a quadrilateral, while L2/discontinuous spaces can have degrees of freedom associated with the Gauss-Legendre points.\nThese are just examples, many choices for the basis are actually possible to be encoded in the  FiniteElementCollection  string above.  In general, based just on the mesh topology and the type of the space, the  FiniteElementSpace  object can determine a global set of dofs, that will be the values listed for the mesh  nodes .  The algorithm starts with the given numbering of the elements and the vertices, from which a numbering of the edges and the faces is derived as follows:  loop over elements\n  loop over edges and faces inside each element (clock-wise)\n    number currently the edges and faces that have not been numbered yet  Here is the result of this numbering for the beam mesh   In addition to a number, each edges and face is also given a global orientation.  In 2D and 3D, an edge is oriented from the vertex with the lower vertex id to the vertex with the higher vertex id.  In 3D, a face is oriented according to the face-to-vertex mappings in the first element in which the face is enumerated. See the  fem/geom.cpp  for the definitions of the  tetrahedral  and  hexahedral  mappings on the reference element, as well as the  Mesh::GenerateFaces  method in  mesh/mesh.cpp . In particular, the normal of the face between two elements points from the element with lower number to the element with higher number. Face orientation however includes not just the normal direction, but also any rotation of the vertices compared to the base, i.e.  orientation  here means permutation of vertices.  The global numbering of degrees of freedom is now performed as follows:  loop over vertices\n  list the dofs associated with each vertex\n\nloop over edges\n  list the dofs associated with the interior of the edge,\n  lexicographically with respect to the edge orientation\n\nloop over faces\n  list the dofs associated with the interior of the face,\n  lexicographically with respect to the face orientation\n\nloop over elements\n  list the dofs associated with the interior of the element  An example of this is the quadratic mesh in   Listing 3  ...\n# BEGIN Geometry Part\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: H1_2D_P2\nVDim: 2\nOrdering: 1\n\n# 18 vertex dofs\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n# 25 edge dofs\n0.5 0\n1 0.5\n0.5 1\n0 0.5\n1.5 0\n2 0.5\n1.5 1\n2.5 0\n3 0.5\n2.5 1\n3.5 0\n4 0.5\n3.5 1\n4.5 0\n5 0.5\n4.5 1\n5.5 0\n6 0.5\n5.5 1\n6.5 0\n7 0.5\n6.5 1\n7.5 0\n8 0.5\n7.5 1\n\n# 8 element dofs\n0.5 0.5\n1.5 0.5\n2.5 0.5\n3.5 0.5\n4.5 0.5\n5.5 0.5\n6.5 0.5\n7.5 0.5\n\n# END Geometry Part\n...", 
            "title": "Finite Element Spaces"
        }, 
        {
            "location": "/mesh-format-v1.x/#listings", 
            "text": "", 
            "title": "Listings"
        }, 
        {
            "location": "/mesh-format-v1.x/#listing-1", 
            "text": "This is the original version of the  beam-quad.mesh  using the linear mesh format.  MFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 8\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 17 16\n1 1 9 0\n2 1 8 17\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1", 
            "title": "Listing 1"
        }, 
        {
            "location": "/mesh-format-v1.x/#listing-2", 
            "text": "This is a  MFEM mesh v1.x  version of the  beam-quad.mesh  which is first order. The mesh is identical to the one of  Listing 1 , it is just described in a different format.  MFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 8\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 17 16\n1 1 9 0\n2 1 8 17\n\nvertices\n18\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: H1_2D_P1\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1", 
            "title": "Listing 2"
        }, 
        {
            "location": "/mesh-format-v1.x/#listing-3", 
            "text": "This is a second order version of the  beam-quad.mesh .  MFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 8\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 17 16\n1 1 9 0\n2 1 8 17\n\nvertices\n18\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: H1_2D_P2\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n0.5 0\n1 0.5\n0.5 1\n0 0.5\n1.5 0\n2 0.5\n1.5 1\n2.5 0\n3 0.5\n2.5 1\n3.5 0\n4 0.5\n3.5 1\n4.5 0\n5 0.5\n4.5 1\n5.5 0\n6 0.5\n5.5 1\n6.5 0\n7 0.5\n6.5 1\n7.5 0\n8 0.5\n7.5 1\n0.5 0.5\n1.5 0.5\n2.5 0.5\n3.5 0.5\n4.5 0.5\n5.5 0.5\n6.5 0.5\n7.5 0.5", 
            "title": "Listing 3"
        }, 
        {
            "location": "/mesh-format-v1.x/#listing-4", 
            "text": "This is a third order version of the  beam-quad.mesh .  MFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 8\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 17 16\n1 1 9 0\n2 1 8 17\n\nvertices\n18\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: H1_2D_P3\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n0.27639320225002 0\n0.72360679774998 0\n1 0.27639320225002\n1 0.72360679774998\n0.27639320225002 1\n0.72360679774998 1\n0 0.27639320225002\n0 0.72360679774998\n1.27639320225 0\n1.72360679775 0\n2 0.27639320225002\n2 0.72360679774998\n1.27639320225 1\n1.72360679775 1\n2.27639320225 0\n2.72360679775 0\n3 0.27639320225002\n3 0.72360679774998\n2.27639320225 1\n2.72360679775 1\n3.27639320225 0\n3.72360679775 0\n4 0.27639320225002\n4 0.72360679774998\n3.27639320225 1\n3.72360679775 1\n4.27639320225 0\n4.72360679775 0\n5 0.27639320225002\n5 0.72360679774998\n4.27639320225 1\n4.72360679775 1\n5.27639320225 0\n5.72360679775 0\n6 0.27639320225002\n6 0.72360679774998\n5.27639320225 1\n5.72360679775 1\n6.27639320225 0\n6.72360679775 0\n7 0.27639320225002\n7 0.72360679774998\n6.27639320225 1\n6.72360679775 1\n7.27639320225 0\n7.72360679775 0\n8 0.27639320225002\n8 0.72360679774998\n7.27639320225 1\n7.72360679775 1\n0.27639320225002 0.27639320225002\n0.72360679774998 0.27639320225002\n0.27639320225002 0.72360679774998\n0.72360679774998 0.72360679774998\n1.27639320225 0.27639320225002\n1.72360679775 0.27639320225002\n1.27639320225 0.72360679774998\n1.72360679775 0.72360679774998\n2.27639320225 0.27639320225002\n2.72360679775 0.27639320225002\n2.27639320225 0.72360679774998\n2.72360679775 0.72360679774998\n3.27639320225 0.27639320225002\n3.72360679775 0.27639320225002\n3.27639320225 0.72360679774998\n3.72360679775 0.72360679774998\n4.27639320225 0.27639320225002\n4.72360679775 0.27639320225002\n4.27639320225 0.72360679774998\n4.72360679775 0.72360679774998\n5.27639320225 0.27639320225002\n5.72360679775 0.27639320225002\n5.27639320225 0.72360679774998\n5.72360679775 0.72360679774998\n6.27639320225 0.27639320225002\n6.72360679775 0.27639320225002\n6.27639320225 0.72360679774998\n6.72360679775 0.72360679774998\n7.27639320225 0.27639320225002\n7.72360679775 0.27639320225002\n7.27639320225 0.72360679774998\n7.72360679775 0.72360679774998", 
            "title": "Listing 4"
        }, 
        {
            "location": "/mesh-format-v1.x/#listing-5", 
            "text": "Periodic version of the first-order mesh from  Listing 1 .  MFEM mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# POINT       = 0\n# SEGMENT     = 1\n# TRIANGLE    = 2\n# SQUARE      = 3\n# TETRAHEDRON = 4\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 0 9 16\n\nboundary\n16\n3 1 0 1\n3 1 1 2\n3 1 2 3\n3 1 3 4\n3 1 4 5\n3 1 5 6\n3 1 6 7\n3 1 7 0\n3 1 10 9\n3 1 11 10\n3 1 12 11\n3 1 13 12\n3 1 14 13\n3 1 15 14\n3 1 16 15\n3 1 9 16\n\nvertices\n16\n\nnodes\nFiniteElementSpace\nFiniteElementCollection: L2_T1_2D_P1\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n0 1\n1 1\n\n1 0\n2 0\n1 1\n2 1\n\n2 0\n3 0\n2 1\n3 1\n\n3 0\n4 0\n3 1\n4 1\n\n4 0\n5 0\n4 1\n5 1\n\n5 0\n6 0\n5 1\n6 1\n\n6 0\n7 0\n6 1\n7 1\n\n7 0\n8 0\n7 1\n8 1\n\n8 0\n9 0\n8 1\n9 1\n\n9 0\n10 0\n9 1\n10 1", 
            "title": "Listing 5"
        }, 
        {
            "location": "/performance/", 
            "text": "Tensor-Based Operator Assembly and Evaluation\n\n\nOverview\n\n\nThe high performance (HPC) versions of the example codes in the \nminiapps/performance\n directory\nuse a set of templated classes to efficiently implement the inner-most portion\n($B^T D B$) of the fundamental finite element (FE) operator decomposition:\n\n\n\n\nWe take advantage of the tensor-product structure of both the finite element\nbasis and the quadrature rule to efficiently apply the action of $B$ without\nnecessarily computing its entries. This is generally know as \nsum\nfactorization\n.\nIn the case where we pre-compute and store the $D$ matrix, we call the algorithm\n\npartial assembly\n.\n\n\nTemplate implementation\n\n\nBelow is a short description of the header files that are part of the initial\nreference implementation of the tensor-based finite element assembly and\nevaluation algorithms.\n\n\nconfig/tconfig.hpp\n\n\nConfiguration macros including the specification of the template blocking\n   size (currently used in the matrix-matrix multiply).\n\n\ngeneral/tassign.hpp\n\n\nHelper templated function to allow single implementation of multiple\n   assignment operations on tensor entries.\n\n\nlinalg/tlayout.hpp\n\n\nClasses describing fixed size tensor layouts. Implemented are standard\n   strided layouts for 1D/2D/3D/4D tensors. Layouts support reshape and\n   sub-tensor operations independent of the actual data storage.\n\n\nThis header also contains another set of \"vector layout\" classes for\n   converting scalar data indices into multi-component (vector) data indices.\n   They are used to describe the layout of vector \nGridFunctions\n on global\n   degrees of freedom (similar to the \nOrdering\n class). In the FE operator\n   decomposition, these classes are used by the templated \n*_FiniteElementSpace\n\n   classes (see \nfem/tfespace.hpp\n below) to implement the actions of $G$ and\n   $G^T$ in the case of vector (multi-component) input and/or output fields.\n\n\nlinalg/tmatrix.hpp\n\n\nSmall matrix operations, defined by specializations: determinant, adjugate,\n   etc. Matrix-matrix multiply, \nC = A.B\n, simple and blocked version.\n\n\nlinalg/ttensor.hpp\n\n\nFixed-size container classes \nTVector\n, \nTMatrix\n, \nTTensor3\n, \nTTensor4\n for\n   1D/2D/3D/4D tensors stored in column-major layout.\n   Element-wise tensor operations: \nA {=,+=,*=} scalar\n; \nA {=,+=,*=} B\n.  The\n   latter allows different input and output layouts. With suitable layouts this\n   can be used to permute (transpose) tensors, extract sub-tensors, etc.\n   The tensor contraction/product operations:\n\n\n\n\nMult_1_2\n: $C_{i,j,k} = \\sum_s A_{s,j} B_{i,s,k}$\n\n\nMult_2_1\n: $C_{i,j,k} = \\sum_s A_{i,s} B_{s,j,k}$\n\n\nTensorAssemble\n: $C_{i,k,j,l} = \\sum_s A_{s,i} A_{s,j} B_{k,s,l}~~$ and\n     $~~D_{i,k,j,l} = \\sum_s A_{i,s} B_{s,j} C_{k,s,l}$\n\n\nTensorProduct\n: $C_{i,j,k,l} = A_{i,j,k} B_{j,l}$\n\n\n\n\nmesh/tmesh.hpp\n\n\nThe Mesh object templated by the finite element space and layout of the\n   nodes. Provides \nMatchesGeometry()\n and \nMatchesNodes()\n functions to verify\n   if compiled and runtime mesh agree.\n\n\nfem/tintrules.hpp\n\n\nQuadrature rules templated by geometry (triangles, quads, etc.) and\n   integration order.\n\n\nfem/tfe.hpp\n\n\nH1 and L2 finite elements templated by geometry and polynomial order.\n\n\nfem/tfespace.hpp\n\n\nTemplate \n*_FiniteElementSpace\n classes providing the mappings between global\n   and local (element) degrees of freedom for H1 continuous and L2 discontinuous\n   spaces. In the FE operator decomposition, these classes provide the element\n   local action of $G$ (\nExtract\n methods) and $G^T$ (\nAssemble\n methods).\n\n\nfem/tcoefficient.hpp\n\n\nTemplated versions of classes derived from the abstract class \nCoefficient\n.\n   It encapsulates physical quantities like material properties, sources,\n   boundary/initial conditions, etc. Its main functionality is to evaluate the\n   coefficient at all quadrature points in an element, which is then used in the\n   evaluation of the $D$ matrix.\n\n\nfem/teltrans.hpp\n\n\nElement transformation class, templated on a mesh type and an integration\n   rule. It is constructed from a mesh (e.g. class \nTMesh\n) and shape evaluator\n   (e.g. class \nShapeEvaluator\n) objects. Allows computation of physical\n   coordinates and Jacobian matrices corresponding to the reference integration\n   points. The desired result (a combination of coordinates and/or Jacobian\n   matrices at quadrature points, element attribute and/or element index) is\n   specified through the template sub-class \nResult\n and stored in an object of\n   the same type. The idea of this approach is to eliminate unnecessary\n   evaluations if they are not needed. The need is determined based on what the\n   particular \"users\" need. The \"users\" are the templated \nCoefficient\n and\n   \nKernel\n (see \nfem/tbilininteg.hpp\n below) classes which specify what they\n   need through static constant boolean variables, e.g. \nuses_coordinates\n,\n   \nuses_Jacobians\n, etc.\n\n\nfem/tevaluator.hpp\n\n\nClasses for evaluating FE basis, \nShapeEvaluator\n, and finite element\n   functions, \nFieldEvaluator\n, and their derivatives at quadrature points,\n   templated by a finite element class and an integration rule class. These\n   correspond to the $B$ and $BG$ matrices above. Quads and hexes use the\n   tensor-product structure for fast evaluation.\n\n\nfem/tbilininteg.hpp\n\n\nKernel\n classes (e.g. mass, diffusion) that represent the matrix $D$ from\n   the above FE operator decomposition. These classes also specify the \ntype\n of\n   the local operator that needs to be applied before and after the $D$ matrix -\n   these are the $B_{in}$ and $B^T_{out}$ matrices, respectively. The product\n   $B^T_{out} D B_{in}$ is the local element matrix, which is the result when\n   using the \nBilinearFormIntegrator\n classes. This specifications of the types\n   are given by static constant boolean variables, e.g. \nin_values\n and\n   \nout_values\n. The \nKernel\n classes provide the following methods:\n\n\n\n\nAction\n: evaluate the action of $D$ \nwithout\n explicitly storing the\n     partially assembled data; this is needed for matrix-free action.\n\n\nAssemble\n: evaluate the partially assembled data, $D$, which is\n     kernel-specific: e.g., for mass, the data is one scalar per quadrature\n     point; for diffusion, the data is one $d\\times d$ matrix (in $d$-dimensions)\n     per quadrature point.\n\n\nMultAssembled\n: perform the action of $D$ using the pre-computed partially\n     assembled data.\n\n\n\n\nfem/tbilinearform.hpp\n\n\nBilinear form operator, templated on the mesh, finite element space,\n   integration rule and bilinear form integrator. Corresponds to the $A$ matrix\n   above. Provides various assembly and evaluation schemes:\n\n\n\n\nMultUnassembled\n: matrix-free action using the mesh nodes and the input\n     vector.\n\n\nAssemble\n, \nMultAssembled\n: partial assembly and operator action using the\n     partially assembled data at quadrature points and the input vector.\n\n\nAssembleMatrix(DenseTensor \n)\n: assemble the local element matrices and\n     store them as \nDenseTensor\n.\n\n\nAssembleMatrix(SparseMatrix \n)\n: assemble the operator in a global (CSR)\n     \nSparseMatrix\n.\n\n\nAssembleBilinearForm(BilinearForm \n)\n: assemble element matrices and add\n     them to the bilinear form.\n\n\n\n\nminiapps/performance/makefile\n\n\nBy default \nmake\n builds the example drivers with the compiler used to\n   compile MFEM. If \ng++\n was used, a pseudo-code dump file with the optimized\n   code will be generated (option \n-fdump-tree-optimized-blocks\n). The \ng++\n\n   option \n--param max-completely-peel-times=3\n prevents the compiler from\n   unrolling innermost loops (of size greater than 3), allowing the compiler to\n   vectorize them. Some options for optimization/vectorization with the clang\n   compiler are also included.\n\n\nminiapps/performance/ex*.cpp\n\n\nHigh-performance templated versions of the corresponding \nexamples/ex*.cpp\n\n   example codes.\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Performance"
        }, 
        {
            "location": "/performance/#tensor-based-operator-assembly-and-evaluation", 
            "text": "", 
            "title": "Tensor-Based Operator Assembly and Evaluation"
        }, 
        {
            "location": "/performance/#overview", 
            "text": "The high performance (HPC) versions of the example codes in the  miniapps/performance  directory\nuse a set of templated classes to efficiently implement the inner-most portion\n($B^T D B$) of the fundamental finite element (FE) operator decomposition:   We take advantage of the tensor-product structure of both the finite element\nbasis and the quadrature rule to efficiently apply the action of $B$ without\nnecessarily computing its entries. This is generally know as  sum\nfactorization .\nIn the case where we pre-compute and store the $D$ matrix, we call the algorithm partial assembly .", 
            "title": "Overview"
        }, 
        {
            "location": "/performance/#template-implementation", 
            "text": "Below is a short description of the header files that are part of the initial\nreference implementation of the tensor-based finite element assembly and\nevaluation algorithms.", 
            "title": "Template implementation"
        }, 
        {
            "location": "/performance/#configtconfighpp", 
            "text": "Configuration macros including the specification of the template blocking\n   size (currently used in the matrix-matrix multiply).", 
            "title": "config/tconfig.hpp"
        }, 
        {
            "location": "/performance/#generaltassignhpp", 
            "text": "Helper templated function to allow single implementation of multiple\n   assignment operations on tensor entries.", 
            "title": "general/tassign.hpp"
        }, 
        {
            "location": "/performance/#linalgtlayouthpp", 
            "text": "Classes describing fixed size tensor layouts. Implemented are standard\n   strided layouts for 1D/2D/3D/4D tensors. Layouts support reshape and\n   sub-tensor operations independent of the actual data storage.  This header also contains another set of \"vector layout\" classes for\n   converting scalar data indices into multi-component (vector) data indices.\n   They are used to describe the layout of vector  GridFunctions  on global\n   degrees of freedom (similar to the  Ordering  class). In the FE operator\n   decomposition, these classes are used by the templated  *_FiniteElementSpace \n   classes (see  fem/tfespace.hpp  below) to implement the actions of $G$ and\n   $G^T$ in the case of vector (multi-component) input and/or output fields.", 
            "title": "linalg/tlayout.hpp"
        }, 
        {
            "location": "/performance/#linalgtmatrixhpp", 
            "text": "Small matrix operations, defined by specializations: determinant, adjugate,\n   etc. Matrix-matrix multiply,  C = A.B , simple and blocked version.", 
            "title": "linalg/tmatrix.hpp"
        }, 
        {
            "location": "/performance/#linalgttensorhpp", 
            "text": "Fixed-size container classes  TVector ,  TMatrix ,  TTensor3 ,  TTensor4  for\n   1D/2D/3D/4D tensors stored in column-major layout.\n   Element-wise tensor operations:  A {=,+=,*=} scalar ;  A {=,+=,*=} B .  The\n   latter allows different input and output layouts. With suitable layouts this\n   can be used to permute (transpose) tensors, extract sub-tensors, etc.\n   The tensor contraction/product operations:   Mult_1_2 : $C_{i,j,k} = \\sum_s A_{s,j} B_{i,s,k}$  Mult_2_1 : $C_{i,j,k} = \\sum_s A_{i,s} B_{s,j,k}$  TensorAssemble : $C_{i,k,j,l} = \\sum_s A_{s,i} A_{s,j} B_{k,s,l}~~$ and\n     $~~D_{i,k,j,l} = \\sum_s A_{i,s} B_{s,j} C_{k,s,l}$  TensorProduct : $C_{i,j,k,l} = A_{i,j,k} B_{j,l}$", 
            "title": "linalg/ttensor.hpp"
        }, 
        {
            "location": "/performance/#meshtmeshhpp", 
            "text": "The Mesh object templated by the finite element space and layout of the\n   nodes. Provides  MatchesGeometry()  and  MatchesNodes()  functions to verify\n   if compiled and runtime mesh agree.", 
            "title": "mesh/tmesh.hpp"
        }, 
        {
            "location": "/performance/#femtintruleshpp", 
            "text": "Quadrature rules templated by geometry (triangles, quads, etc.) and\n   integration order.", 
            "title": "fem/tintrules.hpp"
        }, 
        {
            "location": "/performance/#femtfehpp", 
            "text": "H1 and L2 finite elements templated by geometry and polynomial order.", 
            "title": "fem/tfe.hpp"
        }, 
        {
            "location": "/performance/#femtfespacehpp", 
            "text": "Template  *_FiniteElementSpace  classes providing the mappings between global\n   and local (element) degrees of freedom for H1 continuous and L2 discontinuous\n   spaces. In the FE operator decomposition, these classes provide the element\n   local action of $G$ ( Extract  methods) and $G^T$ ( Assemble  methods).", 
            "title": "fem/tfespace.hpp"
        }, 
        {
            "location": "/performance/#femtcoefficienthpp", 
            "text": "Templated versions of classes derived from the abstract class  Coefficient .\n   It encapsulates physical quantities like material properties, sources,\n   boundary/initial conditions, etc. Its main functionality is to evaluate the\n   coefficient at all quadrature points in an element, which is then used in the\n   evaluation of the $D$ matrix.", 
            "title": "fem/tcoefficient.hpp"
        }, 
        {
            "location": "/performance/#femteltranshpp", 
            "text": "Element transformation class, templated on a mesh type and an integration\n   rule. It is constructed from a mesh (e.g. class  TMesh ) and shape evaluator\n   (e.g. class  ShapeEvaluator ) objects. Allows computation of physical\n   coordinates and Jacobian matrices corresponding to the reference integration\n   points. The desired result (a combination of coordinates and/or Jacobian\n   matrices at quadrature points, element attribute and/or element index) is\n   specified through the template sub-class  Result  and stored in an object of\n   the same type. The idea of this approach is to eliminate unnecessary\n   evaluations if they are not needed. The need is determined based on what the\n   particular \"users\" need. The \"users\" are the templated  Coefficient  and\n    Kernel  (see  fem/tbilininteg.hpp  below) classes which specify what they\n   need through static constant boolean variables, e.g.  uses_coordinates ,\n    uses_Jacobians , etc.", 
            "title": "fem/teltrans.hpp"
        }, 
        {
            "location": "/performance/#femtevaluatorhpp", 
            "text": "Classes for evaluating FE basis,  ShapeEvaluator , and finite element\n   functions,  FieldEvaluator , and their derivatives at quadrature points,\n   templated by a finite element class and an integration rule class. These\n   correspond to the $B$ and $BG$ matrices above. Quads and hexes use the\n   tensor-product structure for fast evaluation.", 
            "title": "fem/tevaluator.hpp"
        }, 
        {
            "location": "/performance/#femtbilininteghpp", 
            "text": "Kernel  classes (e.g. mass, diffusion) that represent the matrix $D$ from\n   the above FE operator decomposition. These classes also specify the  type  of\n   the local operator that needs to be applied before and after the $D$ matrix -\n   these are the $B_{in}$ and $B^T_{out}$ matrices, respectively. The product\n   $B^T_{out} D B_{in}$ is the local element matrix, which is the result when\n   using the  BilinearFormIntegrator  classes. This specifications of the types\n   are given by static constant boolean variables, e.g.  in_values  and\n    out_values . The  Kernel  classes provide the following methods:   Action : evaluate the action of $D$  without  explicitly storing the\n     partially assembled data; this is needed for matrix-free action.  Assemble : evaluate the partially assembled data, $D$, which is\n     kernel-specific: e.g., for mass, the data is one scalar per quadrature\n     point; for diffusion, the data is one $d\\times d$ matrix (in $d$-dimensions)\n     per quadrature point.  MultAssembled : perform the action of $D$ using the pre-computed partially\n     assembled data.", 
            "title": "fem/tbilininteg.hpp"
        }, 
        {
            "location": "/performance/#femtbilinearformhpp", 
            "text": "Bilinear form operator, templated on the mesh, finite element space,\n   integration rule and bilinear form integrator. Corresponds to the $A$ matrix\n   above. Provides various assembly and evaluation schemes:   MultUnassembled : matrix-free action using the mesh nodes and the input\n     vector.  Assemble ,  MultAssembled : partial assembly and operator action using the\n     partially assembled data at quadrature points and the input vector.  AssembleMatrix(DenseTensor  ) : assemble the local element matrices and\n     store them as  DenseTensor .  AssembleMatrix(SparseMatrix  ) : assemble the operator in a global (CSR)\n      SparseMatrix .  AssembleBilinearForm(BilinearForm  ) : assemble element matrices and add\n     them to the bilinear form.", 
            "title": "fem/tbilinearform.hpp"
        }, 
        {
            "location": "/performance/#miniappsperformancemakefile", 
            "text": "By default  make  builds the example drivers with the compiler used to\n   compile MFEM. If  g++  was used, a pseudo-code dump file with the optimized\n   code will be generated (option  -fdump-tree-optimized-blocks ). The  g++ \n   option  --param max-completely-peel-times=3  prevents the compiler from\n   unrolling innermost loops (of size greater than 3), allowing the compiler to\n   vectorize them. Some options for optimization/vectorization with the clang\n   compiler are also included.", 
            "title": "miniapps/performance/makefile"
        }, 
        {
            "location": "/performance/#miniappsperformanceexcpp", 
            "text": "High-performance templated versions of the corresponding  examples/ex*.cpp \n   example codes.  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "miniapps/performance/ex*.cpp"
        }, 
        {
            "location": "/code-overview/", 
            "text": "Code Overview\n\n\nMFEM consists of the following closely interconnected modules:\n\n\n\n\nGeneral\n - general data structures and algorithms.\n\n\nLinear Algebra\n - linear algebra, linear and nonlinear solvers,\n  time steppers.\n\n\nMesh\n - mesh class, mesh readers, mesh manipulation.\n\n\nFEM\n - finite elements, spaces, linear and bilinear forms, etc.\n\n\n\n\n\n\nGeneral\n\n\nArray\n\n\n\n\nClass \nArray\nT\n.\n\n\nSimilar to \nstd::vector\nT\n in many respects.\n\n\nCan allocate and manage data or hold \nexternal\n data.\n\n\n\n\nHash table\n\n\n\n\nClass \nHashTable\nT\n.\n\n\nUsed in the \nNCMesh\n class.\n\n\n\n\nTable\n\n\n\n\nClass \nTable\n.\n\n\nMaps each row, \n{0,1,..,n-1}\n, to a \nlist\n of integers (columns).\n\n\nThis is CSR-like data structure without data, only the '\nI\n' and '\nJ\n' arrays.\n\n\nRepresents relations like \nvertex-to-element\n, \nelement-to-dof\n, etc.\n\n\n\n\nDynamic symmetric table\n\n\n\n\nClass \nDSTable\n is a dynamic symmetric version of the \nTable\n class.\n\n\nUsed for building relations like \nvertex-to-vertex\n - mesh edges.\n\n\n\n\nDynamic symmetric 3D table\n\n\n\n\nClass \nSTable3D\n.\n\n\nUsed for building \nvertex-to-vertex-to-vertex\n relations - mesh faces in 3D.\n\n\n\n\nCommunication\n\n\n\n\nClasses \nGroupTopology\n, \nGroupCommunicator\n.\n\n\nGroups\n are sets of MPI ranks that need to exchange common data at processor\n  boundaries.\n\n\nReduce (gather) and broadcast (scatter) MPI communications within \ngroups\n.\n\n\n\n\nSocket stream\n\n\n\n\nClass \nsocketstream\n\n\nTwo-way TCP sockets as c++ streams.\n\n\nCan be compiled with GnuTLS for security.\n\n\nPrimarily used for sending data to GLVis.\n\n\n\n\nTimers\n\n\n\n\nClass \nStopWatch\n.\n\n\nHas various \"backends\" - \nstd::clock\n, POSIX clocks, Windows'\n  \nQueryPerformanceCounter\n etc.\n\n\n\n\nOptions parser\n\n\n\n\nClass \nOptionsParser\n.\n\n\nMakes it easy to define and parse command line parameters.\n\n\nUsed in all examples and miniapps.\n\n\n\n\n\n\nLinear Algebra\n\n\nVector\n\n\n\n\nClass \nVector\n - a vector of \ndouble\ns.\n\n\nCan allocate and manage data or warp \nexternal\n data.\n\n\nDefines a number of vector operations on the data.\n\n\n\n\nOperator\n\n\n\n\nClass \nOperator\n\n\nAn abstract base class for all linear and non-linear operators.\n\n\nVirtual method \nMult(const Vector \n, Vector \n)\n.\n\n\nOptional virtual method \nOperator \nGetGradient(const Vector \nx)\n.\n\n\n\n\nDense matrix\n\n\n\n\nClass \nDenseMatrix\n - a matrix of \ndouble\ns.\n\n\nCan allocate and manage data or wrap \nexternal\n data.\n\n\nUses column-major storage.\n\n\nDefines a number of matrix operations, matrix-vector, etc.\n\n\nInherits from \nOperator\n.\n\n\n\n\nDense tensor\n\n\n\n\nClass \nDenseTensor\n\n\nCan be viewed as an array of \nDenseMatrix\n (of the same size).\n\n\nCan be used in \nbatched\n matrix operations.\n\n\n\n\nSparse matrix\n\n\n\n\nClass \nSparseMatrix\n - \nint\n indices, \ndouble\n data.\n\n\nCompressed sparse row (CSR) or linked list (LIL) storage.\n\n\nVarious operations: assembly, matrix-vector, smoothers, etc.\n\n\nInherits from \nOperator\n.\n\n\n\n\nParallel hypre vector\n\n\n\n\nClass \nHypreParVector\n - wraps hypre's data structure \n operations.\n\n\n\n\nParallel hypre matrix\n\n\n\n\nClass \nHypreParMatrix\n - wraps hypre's data structure \n operations.\n\n\n\n\nSolvers\n\n\n\n\nAbstract base class \nSolver\n - extends (inherits) class \nOperator\n.\n\n\nAdds virtual method \nvoid SetOperator(const Operator \n)\n.\n\n\n\n\nDirect dense solver\n\n\n\n\nClass \nDenseMatrixInverse\n - inherits \nSolver\n.\n\n\nInverts dense matrices, class \nDenseMatrix\n.\n\n\nUses standard LU factorization with pivoting.\n\n\n\n\nIterative solvers\n\n\n\n\nKrylov methods, Newton method.\n\n\n\n\nDirect sparse solvers\n\n\n\n\nClasses \nUMFPackSolver\n, \nKLUSolver\n - wraps UMFPACK and KLU from SuiteSparse;\n  can be used with \nSparseMatrix\n (serial).\n\n\nClass \nSuperLUSolver\n - wraps SuperLU_DIST; the parallel matrix needs to be\n  converted to \nSuperLURowLocMatrix\n.\n\n\nClass \nSTRUMPACKSolver\n - wraps STRUMPACK; the parallel matrix needs to be\n  converted to \nSTRUMPACKLURowLocMatrix\n.\n\n\n\n\nHypre preconditioners and solvers\n\n\n\n\nClasses \nHypreBoomerAMG\n, \nHypreAMS\n, ect.\n\n\nClasses \nHyprePCG\n, \nHypreGMRES\n.\n\n\n\n\nTime dependent operator\n\n\n\n\nClass \nTimeDependentOperator\n, inherits from \nOperator\n.\n\n\nImplements basic virtual methods \ndouble GetTime()\n and\n  \nvoid SetTime(const double)\n.\n\n\nOptional virtual method\n  \nvoid ImplicitSolve(const double dt, const Vector \nx, Vector \nk)\n - solve\n  backward Euler system; required for implicit time steppers.\n\n\n\n\nODE solvers\n\n\n\n\nAbstract base class \nODESolver\n.\n\n\nHas virtual method \nvoid Init(TimeDependentOperator \n)\n.\n\n\nHas pure virtual method \nvoid Step(Vector \nx, double \nt, double \ndt)\n.\n\n\nDerived classes for explicit Runge-Kutta and implicit (SDIRK) methods.\n\n\n\n\nSymplectic Integrators for Hamiltonian Systems\n\n\n\n\nAbstract base class 'SIASolver'.\n\n\nHas virtual method \nvoid Init(Operator \n, TimeDependentOperator \n)\n.\n\n\nHas pure virtual method \nvoid Step(Vector \nq, Vector \np, double \nt, double \ndt)\n.\n\n\nDerived classes for explicit first and second order integrators.\n\n\nDerived class supporting integration orders from 1 to 4.\n\n\n\n\nConstraint operator\n\n\n\n\nClass \nConstrainedOperator\n, inherits from \nOperator\n.\n\n\nImpose essential boundary conditions on any \nOperator\n (matrix-free).\n\n\nUsed by \nOperator::FormLinearSystem()\n.\n\n\n\n\nBlock vector\n\n\n\n\nClass \nBlockVector\n, inherits from \nVector\n.\n\n\nHolds a set of multiple contiguously allocated vectors.\n\n\nUseful for systems of equations with multiple components using different\n  finite element spaces.\n\n\n\n\nBlock operator\n\n\n\n\nClass \nBlockOperator\n, inherits from \nOperator\n.\n\n\nEach block is itself an \nOperator\n.\n\n\n\n\nBlock matrix\n\n\n\n\nClass \nBlockMatrix\n, inherits \nAbstractSparseMatrix\n.\n\n\nEach block is a \nSparseMatrix\n.\n\n\nSupports more operations than \nBlockOperator\n.\n\n\n\n\nBlock diagonal preconditioner\n\n\n\n\nClass \nBlockDiagonalPreconditioner\n, inherits \nSolver\n.\n\n\nSimilar to \nBlockOperator\n but with diagonal block structure and square\n  diagonal blocks.\n\n\n\n\n\n\nMesh\n\n\nMesh\n\n\n\n\nClass \nMesh\n.\n\n\nThe mesh topology/connectivity is given by \nelement-to-vertex\n relation.\n\n\nElements have type (triangle, quadrilateral, tetrahedron, hexahedron, etc) and\n  attribute (\nint\n).\n\n\nBoundary elements can be included allowing tagging of boundary subsets, e.g.\n  for boundary conditions, by the boundary element attribute.\n\n\nEdges, faces, and other connectivity are derived automatically based on the\n  element type.\n\n\nA high-order mesh uses a vector FE function, i.e. a vector\n  \nGridFunction\n, to represent its high-order \nnodes\n.\n\n\nHanging/slave vertices are regular vertices - the mesh is \n\"cut\"\n along\n  non-conforming edges and faces.\n\n\nConforming constraints and interpolation are added at the level of the\n  \nFiniteElementSpace\n based on additional\n  data from the \nMesh\n and \nNCMesh\n objects.\n\n\nLocal conforming refinement for triangles and tets.\n\n\nLocal non-conforming refinement for triangles, quads, and hexes.\n\n\nDe-refinement and parallel rebalancing for non-conforming meshes.\n\n\nSupports curve and surface meshes.\n\n\nPeriodic meshes: periodic topology with a DG \nGridFunction\n as nodes, cut\n  along the periodic edges/faces.\n\n\n\n\nNon-conforming mesh\n\n\n\n\nClass \nNCMesh\n.\n\n\nUsed through class \nMesh\n.\n\n\nSupports triangles, quads, and hexes including anisotropic refinement for\n  quads and hexes.\n\n\nArbitrary level of hanging nodes and full refinement hierarchy.\n\n\nGenerates the \"cut\" \nMesh\n from the leaf elements.\n\n\n\n\nNURBS mesh\n\n\n\n\nClass \nNURBSExtension\n.\n\n\nUsed through class \nMesh\n.\n\n\nThe NURBS patch connectivity is itself a quad/hex \nMesh\n.\n\n\nSupports knot insertion, degree elevation, (serial, uniform) h-refinement.\n\n\nGenerates a quad/hex \nMesh\n.\n\n\nEasy to convert to a polynomial high-order mesh.\n\n\n\n\nMesh readers and writers\n\n\n\n\nOwn formats, read and write, for: \nMFEM mesh v1.0\n, \nMFEM mesh v1.1\n\n  (extension for non-conforming meshes), \nMFEM NURBS mesh v1.0\n, and\n  \nMFEM INLINE mesh v1.0\n (boxes).\n\n\nReaders for (some) Netgen, TrueGrid, VTK, Gmsh, and CUBIT mesh files.\n\n\nWrite linear and quadratic VTK meshes.\n\n\n\n\nParallel mesh\n\n\n\n\nClasses \nParMesh\n, \nParNCMesh\n, \nParNURBSExtension\n.\n\n\nInherit and extend classes \nMesh\n, \nNCMesh\n, \nNURBSExtension\n.\n\n\nParMesh\n is constructed from a serial \nMesh\n available on all tasks.\n\n\nBuilt-in mesh partitioning is based on METIS.\n\n\nParallel conforming and non-conforming refinement.\n\n\n\n\nMesh operators\n\n\n\n\nClasses \nThresholdRefiner\n, \nThresholdDerefiner\n, \nRebalancer\n.\n\n\n\n\n\n\nFinite Elements\n\n\nQuadrature formulas\n\n\n\n\nClass \nIntegrationPoint\n - coordinates plus weights.\n\n\nClass \nIntegrationRule\n - an array of \nIntegrationPoint\ns.\n\n\nClass \nIntegrationRules\n - container for \nIntegrationRule\ns.\n\n\n\n\nElement transformation\n\n\n\n\nClass \nElementTransformation\n, \nIsoparametricTransformation\n.\n\n\nDefined through a \nFiniteElement\n\n\nTransforms reference \nIntegrationPoint\ns into physical \nVector\ns.\n\n\nOn demand, computes and stores Jacobian matrix, and weight.\n\n\n\n\nFinite elements\n\n\n\n\nAbstract base class \nFiniteElement\n.\n\n\nArbitrary order \nH1_*\n, \nL2_*\n, \nRT_*\n, and \nND_*\n elements on\n  segment, triangles, quads, tets, and hexes.\n\n\nAbstract method \nCalcShape\n, \nCalcDShape\n for scalar FE; \nCalcVShape\n,\n  \nCalcDivShape\n, \nCalcCurlShape\n for vector H(div)/H(curl) FE.\n\n\nOther interpolation and projection methods.\n\n\n\n\nFinite element collections\n\n\n\n\nBase class \nFiniteElementCollection\n.\n\n\nAssociates \nFiniteElement\ns with elements, faces, edges, vertices.\n\n\nDegrees of freedom on faces/edges/vertices are shared between adjacent\n  elements.\n\n\nDerived classes for arbitrary order \nH1_*\n, \nL2_*\n, \nRT_*\n, and \nND_*\n\n  collections.\n\n\n\n\nFinite element space\n\n\n\n\nClass \nFiniteElementSpace\n.\n\n\nConstructed from a \nMesh\n and a \nFiniteElementCollection\n.\n\n\nDefines the mappings \nelements-to-dofs\n, \nfaces-to-dofs\n, etc.\n\n\nDefines, when necessary, a prolongation, \nP\n, and a restriction, \nR\n,\n  matrices: \nR.P = I\n to constrain \n\"slave\"\n dofs.\n\n\nOn non-conforming meshes, the space is \n\"cut\"\n or \n\"partially conforming\"\n\n  (before applying \nP\n).\n\n\nThe domain of \nP\n defines the \n\"true\"\n or \n\"conforming\"\n dofs.\n\n\nThe range of \nP\n is a sub-set of the \n\"partially conforming\"\n dofs.\n\n\n\n\nGrid function\n\n\n\n\nClass \nGridFunction\n, extends class \nVector\n.\n\n\nA container \nVector\n on the \n\"partially conforming\"\n dofs.\n\n\nDefines a number of useful operations like computing values, gradient, etc\n  at quadrature points (\nIntegrationPoint\n or \nIntegrationRule\n).\n\n\nMethods for projecting (interpolating) \nCoefficient\n, \nVectorCoefficient\n.\n\n\nMethods for computing error norms with respect to a \nCoefficient\n.\n\n\n\n\nLinear form\n\n\n\n\nClass \nLinearForm\n, extends class \nVector\n.\n\n\nAssembles r.h.s. vector.\n\n\nUses a sum of local \nLinearFormIntegrator\ns.\n\n\n\n\nBilinear form\n\n\n\n\nClass \nBilinearForm\n.\n\n\nAssembles linear system matrix.\n\n\nUses a sum of local \nBilinearFormIntegrator\ns.\n\n\nMethod \nFormLinearSystem\n applies necessary transformations, e.g.\n  $P^T A P$.\n\n\n\n\nMixed bilinear form\n\n\n\n\nClass \nMixedBilinearForm\n.\n\n\n\n\nCoefficients\n\n\n\n\nAbstract base classes: \nCoefficient\n, \nVectorCoefficient\n, and\n  \nMatrixCoefficient\n.\n\n\nDerived classes include: \nConstantCoefficient\n, \nFunctionCoefficient\n,\n  \nGridFunctionCoefficient\n; \nVectorFunctionCoefficient\n,\n  \nVectorGridFunctionCoefficient\n, etc.\n\n\nEasy to derive new coefficient classes.\n\n\n\n\nParallel versions\n\n\n\n\nParFiniteElementSpace\n\n\nParGridFunction\n\n\nParLinearForm\n\n\nParBilinearForm\n\n\netc\n\n\n\n\nError estimators\n\n\n\n\nClasses \nZienkiewiczZhuEstimator\n, \nL2ZienkiewiczZhuEstimator\n.\n\n\n\n\n\n  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"AMS\"}},\n  tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "_Code Overview"
        }, 
        {
            "location": "/code-overview/#code-overview", 
            "text": "MFEM consists of the following closely interconnected modules:   General  - general data structures and algorithms.  Linear Algebra  - linear algebra, linear and nonlinear solvers,\n  time steppers.  Mesh  - mesh class, mesh readers, mesh manipulation.  FEM  - finite elements, spaces, linear and bilinear forms, etc.", 
            "title": "Code Overview"
        }, 
        {
            "location": "/code-overview/#general", 
            "text": "", 
            "title": "General"
        }, 
        {
            "location": "/code-overview/#array", 
            "text": "Class  Array T .  Similar to  std::vector T  in many respects.  Can allocate and manage data or hold  external  data.", 
            "title": "Array"
        }, 
        {
            "location": "/code-overview/#hash-table", 
            "text": "Class  HashTable T .  Used in the  NCMesh  class.", 
            "title": "Hash table"
        }, 
        {
            "location": "/code-overview/#table", 
            "text": "Class  Table .  Maps each row,  {0,1,..,n-1} , to a  list  of integers (columns).  This is CSR-like data structure without data, only the ' I ' and ' J ' arrays.  Represents relations like  vertex-to-element ,  element-to-dof , etc.", 
            "title": "Table"
        }, 
        {
            "location": "/code-overview/#dynamic-symmetric-table", 
            "text": "Class  DSTable  is a dynamic symmetric version of the  Table  class.  Used for building relations like  vertex-to-vertex  - mesh edges.", 
            "title": "Dynamic symmetric table"
        }, 
        {
            "location": "/code-overview/#dynamic-symmetric-3d-table", 
            "text": "Class  STable3D .  Used for building  vertex-to-vertex-to-vertex  relations - mesh faces in 3D.", 
            "title": "Dynamic symmetric 3D table"
        }, 
        {
            "location": "/code-overview/#communication", 
            "text": "Classes  GroupTopology ,  GroupCommunicator .  Groups  are sets of MPI ranks that need to exchange common data at processor\n  boundaries.  Reduce (gather) and broadcast (scatter) MPI communications within  groups .", 
            "title": "Communication"
        }, 
        {
            "location": "/code-overview/#socket-stream", 
            "text": "Class  socketstream  Two-way TCP sockets as c++ streams.  Can be compiled with GnuTLS for security.  Primarily used for sending data to GLVis.", 
            "title": "Socket stream"
        }, 
        {
            "location": "/code-overview/#timers", 
            "text": "Class  StopWatch .  Has various \"backends\" -  std::clock , POSIX clocks, Windows'\n   QueryPerformanceCounter  etc.", 
            "title": "Timers"
        }, 
        {
            "location": "/code-overview/#options-parser", 
            "text": "Class  OptionsParser .  Makes it easy to define and parse command line parameters.  Used in all examples and miniapps.", 
            "title": "Options parser"
        }, 
        {
            "location": "/code-overview/#linear-algebra", 
            "text": "", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/code-overview/#vector", 
            "text": "Class  Vector  - a vector of  double s.  Can allocate and manage data or warp  external  data.  Defines a number of vector operations on the data.", 
            "title": "Vector"
        }, 
        {
            "location": "/code-overview/#operator", 
            "text": "Class  Operator  An abstract base class for all linear and non-linear operators.  Virtual method  Mult(const Vector  , Vector  ) .  Optional virtual method  Operator  GetGradient(const Vector  x) .", 
            "title": "Operator"
        }, 
        {
            "location": "/code-overview/#dense-matrix", 
            "text": "Class  DenseMatrix  - a matrix of  double s.  Can allocate and manage data or wrap  external  data.  Uses column-major storage.  Defines a number of matrix operations, matrix-vector, etc.  Inherits from  Operator .", 
            "title": "Dense matrix"
        }, 
        {
            "location": "/code-overview/#dense-tensor", 
            "text": "Class  DenseTensor  Can be viewed as an array of  DenseMatrix  (of the same size).  Can be used in  batched  matrix operations.", 
            "title": "Dense tensor"
        }, 
        {
            "location": "/code-overview/#sparse-matrix", 
            "text": "Class  SparseMatrix  -  int  indices,  double  data.  Compressed sparse row (CSR) or linked list (LIL) storage.  Various operations: assembly, matrix-vector, smoothers, etc.  Inherits from  Operator .", 
            "title": "Sparse matrix"
        }, 
        {
            "location": "/code-overview/#parallel-hypre-vector", 
            "text": "Class  HypreParVector  - wraps hypre's data structure   operations.", 
            "title": "Parallel hypre vector"
        }, 
        {
            "location": "/code-overview/#parallel-hypre-matrix", 
            "text": "Class  HypreParMatrix  - wraps hypre's data structure   operations.", 
            "title": "Parallel hypre matrix"
        }, 
        {
            "location": "/code-overview/#solvers", 
            "text": "Abstract base class  Solver  - extends (inherits) class  Operator .  Adds virtual method  void SetOperator(const Operator  ) .", 
            "title": "Solvers"
        }, 
        {
            "location": "/code-overview/#direct-dense-solver", 
            "text": "Class  DenseMatrixInverse  - inherits  Solver .  Inverts dense matrices, class  DenseMatrix .  Uses standard LU factorization with pivoting.", 
            "title": "Direct dense solver"
        }, 
        {
            "location": "/code-overview/#iterative-solvers", 
            "text": "Krylov methods, Newton method.", 
            "title": "Iterative solvers"
        }, 
        {
            "location": "/code-overview/#direct-sparse-solvers", 
            "text": "Classes  UMFPackSolver ,  KLUSolver  - wraps UMFPACK and KLU from SuiteSparse;\n  can be used with  SparseMatrix  (serial).  Class  SuperLUSolver  - wraps SuperLU_DIST; the parallel matrix needs to be\n  converted to  SuperLURowLocMatrix .  Class  STRUMPACKSolver  - wraps STRUMPACK; the parallel matrix needs to be\n  converted to  STRUMPACKLURowLocMatrix .", 
            "title": "Direct sparse solvers"
        }, 
        {
            "location": "/code-overview/#hypre-preconditioners-and-solvers", 
            "text": "Classes  HypreBoomerAMG ,  HypreAMS , ect.  Classes  HyprePCG ,  HypreGMRES .", 
            "title": "Hypre preconditioners and solvers"
        }, 
        {
            "location": "/code-overview/#time-dependent-operator", 
            "text": "Class  TimeDependentOperator , inherits from  Operator .  Implements basic virtual methods  double GetTime()  and\n   void SetTime(const double) .  Optional virtual method\n   void ImplicitSolve(const double dt, const Vector  x, Vector  k)  - solve\n  backward Euler system; required for implicit time steppers.", 
            "title": "Time dependent operator"
        }, 
        {
            "location": "/code-overview/#ode-solvers", 
            "text": "Abstract base class  ODESolver .  Has virtual method  void Init(TimeDependentOperator  ) .  Has pure virtual method  void Step(Vector  x, double  t, double  dt) .  Derived classes for explicit Runge-Kutta and implicit (SDIRK) methods.", 
            "title": "ODE solvers"
        }, 
        {
            "location": "/code-overview/#symplectic-integrators-for-hamiltonian-systems", 
            "text": "Abstract base class 'SIASolver'.  Has virtual method  void Init(Operator  , TimeDependentOperator  ) .  Has pure virtual method  void Step(Vector  q, Vector  p, double  t, double  dt) .  Derived classes for explicit first and second order integrators.  Derived class supporting integration orders from 1 to 4.", 
            "title": "Symplectic Integrators for Hamiltonian Systems"
        }, 
        {
            "location": "/code-overview/#constraint-operator", 
            "text": "Class  ConstrainedOperator , inherits from  Operator .  Impose essential boundary conditions on any  Operator  (matrix-free).  Used by  Operator::FormLinearSystem() .", 
            "title": "Constraint operator"
        }, 
        {
            "location": "/code-overview/#block-vector", 
            "text": "Class  BlockVector , inherits from  Vector .  Holds a set of multiple contiguously allocated vectors.  Useful for systems of equations with multiple components using different\n  finite element spaces.", 
            "title": "Block vector"
        }, 
        {
            "location": "/code-overview/#block-operator", 
            "text": "Class  BlockOperator , inherits from  Operator .  Each block is itself an  Operator .", 
            "title": "Block operator"
        }, 
        {
            "location": "/code-overview/#block-matrix", 
            "text": "Class  BlockMatrix , inherits  AbstractSparseMatrix .  Each block is a  SparseMatrix .  Supports more operations than  BlockOperator .", 
            "title": "Block matrix"
        }, 
        {
            "location": "/code-overview/#block-diagonal-preconditioner", 
            "text": "Class  BlockDiagonalPreconditioner , inherits  Solver .  Similar to  BlockOperator  but with diagonal block structure and square\n  diagonal blocks.", 
            "title": "Block diagonal preconditioner"
        }, 
        {
            "location": "/code-overview/#mesh", 
            "text": "", 
            "title": "Mesh"
        }, 
        {
            "location": "/code-overview/#mesh_1", 
            "text": "Class  Mesh .  The mesh topology/connectivity is given by  element-to-vertex  relation.  Elements have type (triangle, quadrilateral, tetrahedron, hexahedron, etc) and\n  attribute ( int ).  Boundary elements can be included allowing tagging of boundary subsets, e.g.\n  for boundary conditions, by the boundary element attribute.  Edges, faces, and other connectivity are derived automatically based on the\n  element type.  A high-order mesh uses a vector FE function, i.e. a vector\n   GridFunction , to represent its high-order  nodes .  Hanging/slave vertices are regular vertices - the mesh is  \"cut\"  along\n  non-conforming edges and faces.  Conforming constraints and interpolation are added at the level of the\n   FiniteElementSpace  based on additional\n  data from the  Mesh  and  NCMesh  objects.  Local conforming refinement for triangles and tets.  Local non-conforming refinement for triangles, quads, and hexes.  De-refinement and parallel rebalancing for non-conforming meshes.  Supports curve and surface meshes.  Periodic meshes: periodic topology with a DG  GridFunction  as nodes, cut\n  along the periodic edges/faces.", 
            "title": "Mesh"
        }, 
        {
            "location": "/code-overview/#non-conforming-mesh", 
            "text": "Class  NCMesh .  Used through class  Mesh .  Supports triangles, quads, and hexes including anisotropic refinement for\n  quads and hexes.  Arbitrary level of hanging nodes and full refinement hierarchy.  Generates the \"cut\"  Mesh  from the leaf elements.", 
            "title": "Non-conforming mesh"
        }, 
        {
            "location": "/code-overview/#nurbs-mesh", 
            "text": "Class  NURBSExtension .  Used through class  Mesh .  The NURBS patch connectivity is itself a quad/hex  Mesh .  Supports knot insertion, degree elevation, (serial, uniform) h-refinement.  Generates a quad/hex  Mesh .  Easy to convert to a polynomial high-order mesh.", 
            "title": "NURBS mesh"
        }, 
        {
            "location": "/code-overview/#mesh-readers-and-writers", 
            "text": "Own formats, read and write, for:  MFEM mesh v1.0 ,  MFEM mesh v1.1 \n  (extension for non-conforming meshes),  MFEM NURBS mesh v1.0 , and\n   MFEM INLINE mesh v1.0  (boxes).  Readers for (some) Netgen, TrueGrid, VTK, Gmsh, and CUBIT mesh files.  Write linear and quadratic VTK meshes.", 
            "title": "Mesh readers and writers"
        }, 
        {
            "location": "/code-overview/#parallel-mesh", 
            "text": "Classes  ParMesh ,  ParNCMesh ,  ParNURBSExtension .  Inherit and extend classes  Mesh ,  NCMesh ,  NURBSExtension .  ParMesh  is constructed from a serial  Mesh  available on all tasks.  Built-in mesh partitioning is based on METIS.  Parallel conforming and non-conforming refinement.", 
            "title": "Parallel mesh"
        }, 
        {
            "location": "/code-overview/#mesh-operators", 
            "text": "Classes  ThresholdRefiner ,  ThresholdDerefiner ,  Rebalancer .", 
            "title": "Mesh operators"
        }, 
        {
            "location": "/code-overview/#finite-elements", 
            "text": "", 
            "title": "Finite Elements"
        }, 
        {
            "location": "/code-overview/#quadrature-formulas", 
            "text": "Class  IntegrationPoint  - coordinates plus weights.  Class  IntegrationRule  - an array of  IntegrationPoint s.  Class  IntegrationRules  - container for  IntegrationRule s.", 
            "title": "Quadrature formulas"
        }, 
        {
            "location": "/code-overview/#element-transformation", 
            "text": "Class  ElementTransformation ,  IsoparametricTransformation .  Defined through a  FiniteElement  Transforms reference  IntegrationPoint s into physical  Vector s.  On demand, computes and stores Jacobian matrix, and weight.", 
            "title": "Element transformation"
        }, 
        {
            "location": "/code-overview/#finite-elements_1", 
            "text": "Abstract base class  FiniteElement .  Arbitrary order  H1_* ,  L2_* ,  RT_* , and  ND_*  elements on\n  segment, triangles, quads, tets, and hexes.  Abstract method  CalcShape ,  CalcDShape  for scalar FE;  CalcVShape ,\n   CalcDivShape ,  CalcCurlShape  for vector H(div)/H(curl) FE.  Other interpolation and projection methods.", 
            "title": "Finite elements"
        }, 
        {
            "location": "/code-overview/#finite-element-collections", 
            "text": "Base class  FiniteElementCollection .  Associates  FiniteElement s with elements, faces, edges, vertices.  Degrees of freedom on faces/edges/vertices are shared between adjacent\n  elements.  Derived classes for arbitrary order  H1_* ,  L2_* ,  RT_* , and  ND_* \n  collections.", 
            "title": "Finite element collections"
        }, 
        {
            "location": "/code-overview/#finite-element-space", 
            "text": "Class  FiniteElementSpace .  Constructed from a  Mesh  and a  FiniteElementCollection .  Defines the mappings  elements-to-dofs ,  faces-to-dofs , etc.  Defines, when necessary, a prolongation,  P , and a restriction,  R ,\n  matrices:  R.P = I  to constrain  \"slave\"  dofs.  On non-conforming meshes, the space is  \"cut\"  or  \"partially conforming\" \n  (before applying  P ).  The domain of  P  defines the  \"true\"  or  \"conforming\"  dofs.  The range of  P  is a sub-set of the  \"partially conforming\"  dofs.", 
            "title": "Finite element space"
        }, 
        {
            "location": "/code-overview/#grid-function", 
            "text": "Class  GridFunction , extends class  Vector .  A container  Vector  on the  \"partially conforming\"  dofs.  Defines a number of useful operations like computing values, gradient, etc\n  at quadrature points ( IntegrationPoint  or  IntegrationRule ).  Methods for projecting (interpolating)  Coefficient ,  VectorCoefficient .  Methods for computing error norms with respect to a  Coefficient .", 
            "title": "Grid function"
        }, 
        {
            "location": "/code-overview/#linear-form", 
            "text": "Class  LinearForm , extends class  Vector .  Assembles r.h.s. vector.  Uses a sum of local  LinearFormIntegrator s.", 
            "title": "Linear form"
        }, 
        {
            "location": "/code-overview/#bilinear-form", 
            "text": "Class  BilinearForm .  Assembles linear system matrix.  Uses a sum of local  BilinearFormIntegrator s.  Method  FormLinearSystem  applies necessary transformations, e.g.\n  $P^T A P$.", 
            "title": "Bilinear form"
        }, 
        {
            "location": "/code-overview/#mixed-bilinear-form", 
            "text": "Class  MixedBilinearForm .", 
            "title": "Mixed bilinear form"
        }, 
        {
            "location": "/code-overview/#coefficients", 
            "text": "Abstract base classes:  Coefficient ,  VectorCoefficient , and\n   MatrixCoefficient .  Derived classes include:  ConstantCoefficient ,  FunctionCoefficient ,\n   GridFunctionCoefficient ;  VectorFunctionCoefficient ,\n   VectorGridFunctionCoefficient , etc.  Easy to derive new coefficient classes.", 
            "title": "Coefficients"
        }, 
        {
            "location": "/code-overview/#parallel-versions", 
            "text": "ParFiniteElementSpace  ParGridFunction  ParLinearForm  ParBilinearForm  etc", 
            "title": "Parallel versions"
        }, 
        {
            "location": "/code-overview/#error-estimators", 
            "text": "Classes  ZienkiewiczZhuEstimator ,  L2ZienkiewiczZhuEstimator .   \n  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"AMS\"}},\n  tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Error estimators"
        }, 
        {
            "location": "/publications/", 
            "text": "Publications\n\n\nGoogle Scholar Citations\n\n\n\n\nRecent\n\n\nAll time\n\n\n\n\nSelected Publications\n\n\n\n\nR. Anderson, J. Andrej, A. Barker, J. Bramwell, J.-S. Camier, J. Cerverny, J. Dahm, V. Dobrev, Y. Dudouit, A. Fisher, Tz. Kolev, D. Medina, W. Pazner, M. Stowell, V. Tomov, and S. Zampini, \nMFEM: A Modular Finite Element Library\n, in preparation, \n2019\n.\n\n\nP. Fischer, M. Min, T. Rathanayake, S. Dutta, Tz. Kolev, V. Dobrev, J.S. Camier, M. Kronbichler, T. Warburton, K. Swirydowicz, and J. Brown, \nRunning Faster in HPC Applications\n,  submitted, \n2019\n.\n\n\nH. Hajduk, D. Kuzmin, Tz. Kolev, and R. Abgrall, \nMatrix-free subcell residual distribution for Bernstein finite elements: Low-order schemes and FCT\n, \nComp. Meth. Appl. Mech. Eng.\n, in press, \n2019\n.\n\n\nD. White, Y. Choit, and J. Kudo, \nA dual mesh method with adaptivity for stress constrained topology optimization\n, \nStructural and Multidisciplinary Optimization\n, in press, \n2019\n.\n\n\nS. Watts, W. Arrighi, J. Kudo, D. A. Tortorelli, and D. A. White, \nSimple, accurate surrogate models of the elastic response of three-dimensional open truss micro-architectures with applications to multiscale topology design\n, \nStructural and Multidisciplinary Optimization\n, in press, \n2019\n.\n\n\nV. Dobrev, P. Knupp, Tz. Kolev, and V. Tomov, \nTowards Simulation-Driven Optimization of High-Order Meshes by the Target-Matrix Optimization Paradigm\n, \n27th International Meshing Roundtable, Oct 1-8, 2018, Albuquerque\n, Lecture Notes in Computational Science and Engineering, vol 127., pp. 285-302, \n2019\n.\n\n\nJ. Cerverny, V. Dobrev, and Tz. Kolev, \nNon-Conforming Mesh Refinement For High-Order Finite Elements\n, \nSIAM Journal on Scientific Computing\n, 41(4):C367\u2013C392, \n2019\n.\n\n\nD. White, W. Arrighi, J. Kudo, and S. Watts, \nMultiscale topology optimization using neural network surrogate models\n, \nComp. Meth. Appl. Mech. Eng.\n,  346, pp.1118-1135, \n2019\n.\n\n\nV. A. Dobrev, T. V. Kolev, C. S. Lee, V. Z. Tomov, and P. S. Vassilevski, \nAlgebraic Hybridization and Static Condensation with Application to Scalable H(div) Preconditioning\n, \nSIAM Journal on Scientific Computing\n, 41(3):B425\u2013B447, \n2019\n.\n\n\nD. White, and A. Voronin, \nA computational study of symmetry and well-posedness of structural topology optimization\n, \nStructural and Multidisciplinary Optimization\n, 59(3), pp. 759-766, \n2019\n.\n\n\nT. Haut, P. Maginot, V. Tomov, B. Southworth, T. Brunner and T. Bailey, \nAn Efficient Sweep-Based Solver for the SN Equations on High-Order Meshes\n, \nNuclear Science and Engineering\n, \n2019\n.\n\n\nV. Dobrev, P. Knupp, Tz. Kolev, K. Mittal, and V. Tomov, \nThe Target-Matrix Optimization Paradigm For High-Order Meshes\n, \nSIAM Journal on Scientific Computing\n, 41(1):B50-B68, \n2019\n.\n\n\nT. L. Horvath and S. Rhebergen, \nA locally conservative and energy-stable finite element method for the Navier-Stokes problem on time-dependent domains\n, \nInternational Journal for Numerical Methods in Fluids\n, pp. 1-14, \n2019\n.\n\n\nK. L. A. Kirk, T. L. Horvath, A. Cesmelioglu and S. Rhebergen, \nAnalysis of a space-time hybridizable discontinuous Galerkin method for the advection-diffusion problem on time-dependent domains\n, \narXiv:1812.00216\n, \n2018\n.\n\n\nS. Rhebergen and G. N. Wells, \nAn embedded-hybridized discontinuous Galerkin finite element method for the Stokes equations\n, \narXiv:1811.09194\n, \n2018\n.\n\n\nH. Auten, \nThe High Value of Open Source Software\n, \nScience \n Technology Review\n, January/February 2018, pp. 5-11, \n2018\n.\n\n\nR. W. Anderson, V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov, \nHigh-Order Multi-Material ALE Hydrodynamics\n, \nSIAM Journal on Scientific Computing\n, 40(1), pp. B32-B58, \n2018\n.\n\n\nA. T. Barker, V. Dobrev, J. Gopalakrishnan, and Tz. Kolev, \nA scalable preconditioner for a primal discontinuous Petrov-Galerkin method\n, \nSIAM Journal on Scientific Computing\n, 40(2), pp. A1187\u2013A1203, \n2018\n.\n\n\nV. Dobrev, T. Kolev, D. Kuzmin, R. Rieben, and V. Tomov, \nSequential limiting in continuous and discontinuous Galerkin methods for the Euler equations\n, \nJournal of Computational Physics\n, 356, pp. 372 - 390, \n2018\n.\n\n\nM. Reberol and B. L\nvy, \nComputing the Distance between Two Finite Element Solutions Defined on Different 3D Meshes on a GPU\n, \nSIAM Journal on Scientific Computing\n, 40(1), pp. C131-C155, \n2018\n.\n\n\nA. Mazuyer, P. Cupillard, R. Giot, M. Conin, Y. Leroy, and P. Thore, \nStress estimation in reservoirs using an integrated inverse method\n, \nComputers \n Geosciences\n, 114, pp. 30 - 40, \n2018\n.\n\n\nD. A. White, M. Stowell, and D. A. Tortorelli, \nTopological optimization of structures using Fourier representations\n, \nStructural and Multidisciplinary Optimization\n, pp. 1-16, \nApr. 2018\n.\n\n\nR. Li, Y. Xi, L. Erlandson, and Y. Saad, \nThe Eigenvalues Slicing Library (EVSL): Algorithms, Implementation, and Software\n, \narXiv:1802.05215\n, \nFeb. 2018\n.\n\n\nS. Rhebergen and G. N. Wells, \nPreconditioning of a hybridized discontinuous Galerkin finite element method for the Stokes equations\n, \nJournal of Scientific Computing\n, 77(3), pp. 1936-1501, \n2018\n.\n\n\nT. S. Haut, P. G. Maginot, V. Z. Tomov, T. A. Brunner, and T. S. Bailey, \nAn Efficient Sweep-based Solver for the $S_N$ Equations on High-Order Meshes\n, \nAmerican Nuclear Society 2018 Annual Meeting, June 14-21, Philadelphia, PA\n, \n2018\n.\n\n\nA. S\nnchez-Villar and M. Merino, \nAdvances in Wave-Plasma Modelling in ECR Thrusters\n, \n2018 Space Propulsion Conference, May 14-18, Seville, Spain\n, \n2018\n.\n\n\nS. Osborn, P. S. Vassilevski, and U. Villa, \nA Multilevel, Hierarchical Sampling Technique for Spatially Correlated Random Fields\n, \nSIAM Journal on Scientific Computing\n, 39(5), pp. S543-S562, \nOct. 2017\n.\n\n\nR. D. Falgout, T. A. Manteuffel, B. O'Neill, and J. B. Schroder, \nMultigrid Reduction In Time For Nonlinear Parabolic Problems: A Case Study\n, \nSIAM Journal on Scientific Computing\n, 39(5), pp. S298-S322, \nOct. 2017\n.\n\n\nT. A. Manteuffel, L. N. Olson, J. B. Schroder, and B. S. Southworth, \nA Root-Node Based Algebraic Multigrid Method\n, \nSIAM Journal on Scientific Computing\n, 39(5), pp. S723-S756, \nOct. 2017\n.\n\n\nA. T. Barker, C. S. Lee, and P. S. Vassilevski, \nSpectral Upscaling for Graph Laplacian Problems with Application to Reservoir Simulation\n, \nSIAM Journal on Scientific Computing\n, 39(5), pp. S323-S346, \nOct. 2017\n.\n\n\nV. A. Dobrev, Tz. Kolev, N. A. Peterson, and J. B. Schroder, \nTwo-level Convergence Theory For Multigrid Reduction In Time (MGRIT)\n, \nSIAM Journal on Scientific Computing\n, 39(5), pp. S501-S527, \nOct. 2017\n.\n\n\nR. E. Bank, P. S. Vassilevski, and L. T. Zikatanov, \nArbitrary Dimension Convection-Diffusion Schemes For Space-Time Discretizations\n, \nJournal of Computational and Applied Mathematics\n, 310, pp. 19-31, \n2017\n.\n\n\nS. Osborn, P. Zulian, T. Benson, U. Villa, R. Krause, and P. S. Vassilevski, \nScalable hierarchical PDE sampler for generating spatially correlated random fields using non-matching meshes\n, \nNumerical Linear Algebra with Applications\n, 25, pp. e2146, \nDec. 2017\n.\n\n\nJ. H. Adler, I. Lashuk, and S. P. MacLachlan, \nComposite-grid multigrid for diffusion on the sphere\n, \nNumerical Linear Algebra with Applications\n, 25(1), pp. e2115, \n2017\n.\n\n\nJ. Gopalakrishnan, M. Neum\u00fcller, and P. Vassilevski, \nThe auxiliary space preconditioner for the de Rham complex\n, \narXiv:1710.07840\n, \nOct. 2017\n.\n\n\nS. Zampini, P. S. Vassilevski, V. Dobrev, and T. Kolev, \nBalancing Domain Decomposition by Constraints Algorithms for Curl-conforming Spaces of Arbitrary Order\n, \nDomain Decomposition Methods in Science and Engineering XXIV\n, \n2017\n.\n\n\nM. Larsen, J. Ahrens, U. Ayachit, E. Brugger, H. Childs, B. Geveci, and C. Harrison, \nThe ALPINE In Situ Infrastructure: Ascending from the Ashes of Strawman\n, \nISAV 2017: In Situ Infrastructures for Enabling Extreme-scale Analysis and Visualization\n, \nNov. 2017\n.\n\n\nJ. Wright and S. Shiraiwa, \nAntenna to Core: A New Approach to RF Modelling\n, \n22 Topical Conference on Radio-Frequency Power in Plasmas\n, \n2017\n.\n\n\nS. Shiraiwa,  J. C. Wright,  P. T. Bonoli,  Tz. Kolev, and  M. Stowell, \nRF wave simulation for cold edge plasmas using the MFEM library\n, \n22 Topical Conference on Radio-Frequency Power in Plasmas\n, \n2017\n.\n\n\nC. Hofer, U. Langer, M. Neum\nller, and I. Toulopoulos, \nTime-Multipatch Discontinuous Galerkin Space-Time Isogeometric Analysis of Parabolic Evolution Problems\n, \nRICAM-Report 2017-26\n, \n2017\n.\n\n\nJ. Billings, A. McCaskey, G. Vallee, and G. Watson, \nWill humans even write code in 2040 and what would that mean for extreme heterogeneity in computing?\n, \narXiv:1712.00676\n, \nDec. 2017\n.\n\n\nM. L. C. Christensen, U. Villa, A. Engsig-Karup, and P. S. Vassilevski, \nNumerical Multilevel Upscaling For Incompressible Flow in Reservoir Simulation: An Element-Based Algebraic Multigrid (AMGe) Approach\n, \nSIAM Journal on Scientific Computing\n, 39(1), pp. B102-B137, \nFeb. 2017\n.\n\n\nR. Anderson, V. Dobrev, Tz. Kolev, D. Kuzmin, M. Q. de Luna, R. Rieben, and V. Tomov, \nHigh-order local maximum principle preserving (MPP) discontinuous Galerkin finite element method for the transport equation\n, \nJournal of Computational Physics\n, 334, pp. 102-124, \nApr. 2017\n.\n\n\nR. Li and Y. Saad, \nLow-Rank Correction Methods for Algebraic Domain Decomposition Preconditioners\n, \nSIAM Journal on Matrix Analysis and Applications\n, 38(3), pp. 807-828, \nAug. 2017\n.\n\n\nD. Z. Kalchev, C. S. Lee, U. Villa, Y. Efendiev, and P. S. Vassilevski, \nUpscaling of Mixed Finite Element Discretization Problems by the Spectral AMGe Method\n, \nSIAM Journal on Scientific Computing\n, 38(5), pp. A2912\u2013A2933, \nSep. 2016\n.\n\n\nV. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov, \nMulti-material closure model for high-order finite element Lagrangian hydrodynamics\n, \nInternational Journal for Numerical Methods in Fluids\n, 82(10), pp. 689-706, \n2016\n.\n\n\nJ. Guermond, B. Popov, and V. Tomov, \nEntropy-viscosity method for the single material Euler equations in Lagrangian frame\n, \nComputer Methods in Applied Mechanics and Engineering\n, 300, pp. 402 - 426, \nMar. 2016\n.\n\n\nM. Holec, J. Limpouch, R. Liska, and S. Weber, \nHigh-order discontinuous Galerkin nonlocal transport and energy equations scheme for radiation hydrodynamics\n, \nInternational Journal for Numerical Methods in Fluids\n, 83(10), pp. 779-797, \n2016\n.\n\n\nTz. V. Kolev, J. Xu, and Y. Zhu, \nMultilevel Preconditioners for Reaction-Diffusion Problems with Discontinuous Coefficients\n, \nJournal of Scientific Computing\n, 67(1), pp. 324--350, \nApr. 2016\n.\n\n\nM. Reberol and B. L\nvy, \nLow-order continuous finite element spaces on hybrid non-conforming hexahedral-tetrahedral meshes\n, \nCoRR\n, abs/1605.02626, \n2016\n.\n\n\nO. Marques, A. Druinsky, X. S. Li, A. T. Barker, P. Vassilevski, and D. Kalchev, \nTuning the Coarse Space Construction in a Spectral AMG Solver\n, \nProcedia Computer Science\n, 80, pp. 212 - 221, International Conference on Computational Science 2016, ICCS 2016, 6-8 June 2016, San Diego, California, USA, \n2016\n.\n\n\nJ. S. Yeom, J. J. Thiagarajan, A. Bhatele, G. Bronevetsky, and T. Kolev, \nData-Driven Performance Modeling of Linear Solvers for Sparse Matrices\n, \n2016 7th International Workshop on Performance Modeling, Benchmarking and Simulation of High Performance Computer Systems (PMBS)\n, \nNov. 2016\n.\n\n\nD. Osei-Kuffuor, R. Li, and Y. Saad, \nMatrix Reordering Using Multilevel Graph Coarsening for ILU Preconditioning\n, \nSIAM Journal on Scientific Computing\n, 37(1), pp. A391-A419, \nFeb. 2015\n.\n\n\nR. Anderson, V. Dobrev, Tz. Kolev, and R. Rieben, \nMonotonicity in high-order curvilinear finite element ALE remap\n, \nInt. J. Numer. Meth. Fluids\n, 77(5), pp. 249\u2013273, \n2014\n.\n\n\nV. Dobrev, Tz. Kolev, and R. Rieben, \nHigh-order curvilinear finite element methods for elastic-plastic Lagrangian dynamics\n, \nJ. Comp. Phys.\n, (257B), pp. 1062\u20131080, \n2014\n.\n\n\nP. Vassilevski and U. Villa, \nA mixed formulation for the Brinkman problem\n, \nSIAM Journal on Numerical Analysis\n, 52-1, pp. 258-281, \n2014\n.\n\n\nJ. H. Adler and P. S. Vassilevski, \nError Analysis for Constrained First-Order System Least-Squares Finite-Element Methods\n, \nSIAM Journal on Scientific Computing\n, 36(3), pp. A1071-A1088, \n2014\n.\n\n\nA. Aposporidis, P. S. Vassilevski, and A. Veneziani, \nMultigrid preconditioning of the non-regularized augmented Bingham fluid problem\n, \nETNA. Electronic Transactions on Numerical Analysis\n, 41, \nJan. 2014\n.\n\n\nP. S. Vassilevski and U. M. Yang, \nReducing communication in algebraic multigrid using additive variants\n, \nNumerical Linear Algebra with Applications\n, 21(2), pp. 275-296, \n2014\n.\n\n\nT. Dong, V. Dobrev, T. Kolev, R. Rieben, S. Tomov, and J. Dongarra, \nA Step towards Energy Efficient Computing: Redesigning a Hydrodynamic Application on CPU-GPU\n, \n2014 IEEE 28th International Parallel and Distributed Processing Symposium\n, \nMay 2014\n.\n\n\nP. Vassilevski and U. Villa, \nA block-diagonal algebraic multigrid preconditioner for the Brinkman problem\n, \nSIAM Journal on Scientific Computing\n, 35-5, pp. S3-S17, \n2013\n.\n\n\nV. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben, \nHigh-order curvilinear finite elements for axisymmetric Lagrangian hydrodynamics\n, \nComputers and Fluids\n, pp. 58-69, \n2013\n.\n\n\nD. Kalchev, C. Ketelsen, and P. S. Vassilevski, \nTwo-level adaptive algebraic multigrid for sequence of problems with slowly varying random coefficients\n, \nSIAM Journal on Scientific Computing\n, 35(6), pp. B1215-B1234, \nNov. 2013\n.\n\n\nP. D'Ambra and P. S. Vassilevski, \nAdaptive AMG with coarsening based on compatible weighted matching\n, \nComputing and Visualization in Science\n, 16(2), pp. 59--76, \nApr. 2013\n.\n\n\nT. A. Brunner, T. V. Kolev, T. S. Bailey, and A. T. Till, \nPreserving Spherical Symmetry in Axisymmetric Coordinates for Diffusion\n, \nInternational Conference on Mathematics and Computational Methods Applied to Nuclear Science \n Engineering\n, \n2013\n.\n\n\nTz. Kolev and P. Vassilevski, \nParallel auxiliary space AMG solver for H(div) problems\n,  \nSIAM Journal on Scientific Computing\n, 34, pp. A3079\u2013A3098, \n2012\n.\n\n\nV. Dobrev, Tz. Kolev, and R. Rieben, \nHigh-order curvilinear finite element methods for Lagrangian hydrodynamics\n, \nSIAM Journal on Scientific Computing\n, 34, pp. B606\u2013B641, \n2012\n.\n\n\nI. Lashuk and  P.Vassilevski, \nElement agglomeration coarse Raviart-Thomas spaces with improved approximation properties\n, \nNumerical Linear Algebra with Applications\n, 19, pp. 414-426, \n2012\n.\n\n\nD. Kalchev, \nAdaptive algebraic multigrid for \ufb01nite element elliptic equations with random coe\ufb03cients\n, \nLLNL Tech. Report\n, LLNL-TR-553254, \n2012\n.\n\n\nA. Aposporidis, P. Vassilevski, and A. Veneziani, \nA geometric nonlinear AMLI preconditioner for the Bingham fluid flow in mixed variables\n, \nLLNL Tech. Report\n, LLNL-JRNL-600372, \n2012\n.\n\n\nP. Knupp, \nIntroducing the target-matrix paradigm for mesh optimization by node movement\n, \nEngineering with Computers\n, 28(4), pp. 419--429, \n2012\n.\n\n\nT. A. Brunner, \nMulard: A Multigroup Thermal Radiation Diffusion Mini-Application\n, \nDOE Exascale Research Conference, Portland, Oregon\n, \n2012\n.\n\n\nA. Baker, R. Falgout, T. Kolev, and U. Yang, \nMultigrid smoothers for ultra-parallel computing\n, \nSIAM Journal on Scientific Computing\n, 33(5), pp. 2864-2887, \nOct. 2011\n.\n\n\nV. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben, \nCurvilinear finite elements for Lagrangian hydrodynamics\n, \nInt. J. Numer. Meth. Fluids\n, 65, pp. 1295\u20131310, \n2011\n.\n\n\nV. Dobrev, J.-L. Guermond, and B. Popov, \nSurface reconstruction and image enhancement via L1-minimization\n, \nSIAM Journal on Scientific Computing\n, 32 (3), pp. 1591-1616, \n2010\n.\n\n\nJ. Brannick and R. Falgout, \nCompatible relaxation and coarsening in algebraic multigrid\n, \nSIAM Journal on Scientific Computing\n, 32, pp. 1393-1416, \n2010\n.\n\n\nA. Baker, Tz. Kolev, and U. M. Yang, \nImproving algebraic multigrid interpolation operators for linear elasticity problems\n, \nNumerical Linear Algebra with Applications\n, 17, pp. 495-517, \n2010\n.\n\n\nU. M. Yang, \nOn long-range interpolation operators for aggressive coarsening\n, \nNumerical Linear Algebra with Applications\n, 17, pp. 453\u2013472, \n2010\n.\n\n\nTz. Kolev and P. Vassilevski, \nParallel auxiliary space AMG for H(curl) problems\n, \nJournal of Computational Mathematics\n, 27, pp. 604-623, \n2009\n.\n\n\nTz. V. Kolev and R. N. Rieben, \nA tensor artificial viscosity using a finite element approach\n, \nJournal of Computational Physics\n, 228(22), pp. 8336 - 8366, \n2009\n.\n\n\nA. Baker, E. Jessup, and Tz. Kolev, \nA simple strategy for varying the restart parameter in GMRES(m)\n, \nJ. Comp. Appl. Math.\n, 230, pp. 751-761, \n2009\n.\n\n\nTz. Kolev, J. Pasciak, and P. Vassilevski, \nH(curl) auxiliary mesh preconditioning\n, \nNumerical Linear Algebra with Applications\n, 15, pp. 455\u2013471, \n2008\n.\n\n\nH. De Sterck, R. Falgout, J. Nolting, and U. M. Yang, \nDistance-two interpolation for parallel algebraic multigrid\n, \nNumerical Linear Algebra with Applications\n, 15, pp. 115\u2013139, \nApr. 2008\n.\n\n\nV. Dobrev, R. Lazarov, and L. Zikatanov, \nPreconditioning of symmetric interior penalty discontinuous Galerkin FEM for second order elliptic problems\n, in Domain Decomposition Methods in Science and Engineering XVII, Lecture Notes in Computational Science and Engineering, vol. 60, U. Langer et al. eds, Springer-Verlag, Berlin, Heidelberg, pp. 33-44, \n2008\n.\n\n\nD. Alber and L. Olson, \nParallel coarse grid selection\n, \nNumerical Linear Algebra with Applications\n, 14, pp. 611-643, \n2007\n.\n\n\nV. Dobrev, R. Lazarov, P. Vassilevski, and L. Zikatanov, \nTwo-level preconditioning of discontinuous Galerkin approximations of second-order elliptic equations\n, \nNumerical Linear Algebra with Applications\n, 13 (9), pp. 753-770, \n2006\n.\n\n\nTz. Kolev and P. Vassilevski, \nAMG by element agglomeration and constrained energy minimization interpolation\n, \nNumerical Linear Algebra with Applications\n, 13, pp. 771\u2013788, \n2006\n.\n\n\nJ. Bramble, Tz. Kolev, and J. Pasciak, \nA least-squares approximation method for the time-harmonic Maxwell equations\n, \nJournal of Numerical Mathematics\n, 13(4), pp. 237-263, \n2005\n.\n\n\nP. Vassilevski, \nSparse matrix element topology with application to AMG(e) and preconditioning\n, \nNumerical Linear Algebra with Applications\n, 9, pp. 429--444, \n2002\n.\n\n\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Publications"
        }, 
        {
            "location": "/publications/#publications", 
            "text": "", 
            "title": "Publications"
        }, 
        {
            "location": "/publications/#google-scholar-citations", 
            "text": "Recent  All time", 
            "title": "Google Scholar Citations"
        }, 
        {
            "location": "/publications/#selected-publications", 
            "text": "R. Anderson, J. Andrej, A. Barker, J. Bramwell, J.-S. Camier, J. Cerverny, J. Dahm, V. Dobrev, Y. Dudouit, A. Fisher, Tz. Kolev, D. Medina, W. Pazner, M. Stowell, V. Tomov, and S. Zampini,  MFEM: A Modular Finite Element Library , in preparation,  2019 .  P. Fischer, M. Min, T. Rathanayake, S. Dutta, Tz. Kolev, V. Dobrev, J.S. Camier, M. Kronbichler, T. Warburton, K. Swirydowicz, and J. Brown,  Running Faster in HPC Applications ,  submitted,  2019 .  H. Hajduk, D. Kuzmin, Tz. Kolev, and R. Abgrall,  Matrix-free subcell residual distribution for Bernstein finite elements: Low-order schemes and FCT ,  Comp. Meth. Appl. Mech. Eng. , in press,  2019 .  D. White, Y. Choit, and J. Kudo,  A dual mesh method with adaptivity for stress constrained topology optimization ,  Structural and Multidisciplinary Optimization , in press,  2019 .  S. Watts, W. Arrighi, J. Kudo, D. A. Tortorelli, and D. A. White,  Simple, accurate surrogate models of the elastic response of three-dimensional open truss micro-architectures with applications to multiscale topology design ,  Structural and Multidisciplinary Optimization , in press,  2019 .  V. Dobrev, P. Knupp, Tz. Kolev, and V. Tomov,  Towards Simulation-Driven Optimization of High-Order Meshes by the Target-Matrix Optimization Paradigm ,  27th International Meshing Roundtable, Oct 1-8, 2018, Albuquerque , Lecture Notes in Computational Science and Engineering, vol 127., pp. 285-302,  2019 .  J. Cerverny, V. Dobrev, and Tz. Kolev,  Non-Conforming Mesh Refinement For High-Order Finite Elements ,  SIAM Journal on Scientific Computing , 41(4):C367\u2013C392,  2019 .  D. White, W. Arrighi, J. Kudo, and S. Watts,  Multiscale topology optimization using neural network surrogate models ,  Comp. Meth. Appl. Mech. Eng. ,  346, pp.1118-1135,  2019 .  V. A. Dobrev, T. V. Kolev, C. S. Lee, V. Z. Tomov, and P. S. Vassilevski,  Algebraic Hybridization and Static Condensation with Application to Scalable H(div) Preconditioning ,  SIAM Journal on Scientific Computing , 41(3):B425\u2013B447,  2019 .  D. White, and A. Voronin,  A computational study of symmetry and well-posedness of structural topology optimization ,  Structural and Multidisciplinary Optimization , 59(3), pp. 759-766,  2019 .  T. Haut, P. Maginot, V. Tomov, B. Southworth, T. Brunner and T. Bailey,  An Efficient Sweep-Based Solver for the SN Equations on High-Order Meshes ,  Nuclear Science and Engineering ,  2019 .  V. Dobrev, P. Knupp, Tz. Kolev, K. Mittal, and V. Tomov,  The Target-Matrix Optimization Paradigm For High-Order Meshes ,  SIAM Journal on Scientific Computing , 41(1):B50-B68,  2019 .  T. L. Horvath and S. Rhebergen,  A locally conservative and energy-stable finite element method for the Navier-Stokes problem on time-dependent domains ,  International Journal for Numerical Methods in Fluids , pp. 1-14,  2019 .  K. L. A. Kirk, T. L. Horvath, A. Cesmelioglu and S. Rhebergen,  Analysis of a space-time hybridizable discontinuous Galerkin method for the advection-diffusion problem on time-dependent domains ,  arXiv:1812.00216 ,  2018 .  S. Rhebergen and G. N. Wells,  An embedded-hybridized discontinuous Galerkin finite element method for the Stokes equations ,  arXiv:1811.09194 ,  2018 .  H. Auten,  The High Value of Open Source Software ,  Science   Technology Review , January/February 2018, pp. 5-11,  2018 .  R. W. Anderson, V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov,  High-Order Multi-Material ALE Hydrodynamics ,  SIAM Journal on Scientific Computing , 40(1), pp. B32-B58,  2018 .  A. T. Barker, V. Dobrev, J. Gopalakrishnan, and Tz. Kolev,  A scalable preconditioner for a primal discontinuous Petrov-Galerkin method ,  SIAM Journal on Scientific Computing , 40(2), pp. A1187\u2013A1203,  2018 .  V. Dobrev, T. Kolev, D. Kuzmin, R. Rieben, and V. Tomov,  Sequential limiting in continuous and discontinuous Galerkin methods for the Euler equations ,  Journal of Computational Physics , 356, pp. 372 - 390,  2018 .  M. Reberol and B. L vy,  Computing the Distance between Two Finite Element Solutions Defined on Different 3D Meshes on a GPU ,  SIAM Journal on Scientific Computing , 40(1), pp. C131-C155,  2018 .  A. Mazuyer, P. Cupillard, R. Giot, M. Conin, Y. Leroy, and P. Thore,  Stress estimation in reservoirs using an integrated inverse method ,  Computers   Geosciences , 114, pp. 30 - 40,  2018 .  D. A. White, M. Stowell, and D. A. Tortorelli,  Topological optimization of structures using Fourier representations ,  Structural and Multidisciplinary Optimization , pp. 1-16,  Apr. 2018 .  R. Li, Y. Xi, L. Erlandson, and Y. Saad,  The Eigenvalues Slicing Library (EVSL): Algorithms, Implementation, and Software ,  arXiv:1802.05215 ,  Feb. 2018 .  S. Rhebergen and G. N. Wells,  Preconditioning of a hybridized discontinuous Galerkin finite element method for the Stokes equations ,  Journal of Scientific Computing , 77(3), pp. 1936-1501,  2018 .  T. S. Haut, P. G. Maginot, V. Z. Tomov, T. A. Brunner, and T. S. Bailey,  An Efficient Sweep-based Solver for the $S_N$ Equations on High-Order Meshes ,  American Nuclear Society 2018 Annual Meeting, June 14-21, Philadelphia, PA ,  2018 .  A. S nchez-Villar and M. Merino,  Advances in Wave-Plasma Modelling in ECR Thrusters ,  2018 Space Propulsion Conference, May 14-18, Seville, Spain ,  2018 .  S. Osborn, P. S. Vassilevski, and U. Villa,  A Multilevel, Hierarchical Sampling Technique for Spatially Correlated Random Fields ,  SIAM Journal on Scientific Computing , 39(5), pp. S543-S562,  Oct. 2017 .  R. D. Falgout, T. A. Manteuffel, B. O'Neill, and J. B. Schroder,  Multigrid Reduction In Time For Nonlinear Parabolic Problems: A Case Study ,  SIAM Journal on Scientific Computing , 39(5), pp. S298-S322,  Oct. 2017 .  T. A. Manteuffel, L. N. Olson, J. B. Schroder, and B. S. Southworth,  A Root-Node Based Algebraic Multigrid Method ,  SIAM Journal on Scientific Computing , 39(5), pp. S723-S756,  Oct. 2017 .  A. T. Barker, C. S. Lee, and P. S. Vassilevski,  Spectral Upscaling for Graph Laplacian Problems with Application to Reservoir Simulation ,  SIAM Journal on Scientific Computing , 39(5), pp. S323-S346,  Oct. 2017 .  V. A. Dobrev, Tz. Kolev, N. A. Peterson, and J. B. Schroder,  Two-level Convergence Theory For Multigrid Reduction In Time (MGRIT) ,  SIAM Journal on Scientific Computing , 39(5), pp. S501-S527,  Oct. 2017 .  R. E. Bank, P. S. Vassilevski, and L. T. Zikatanov,  Arbitrary Dimension Convection-Diffusion Schemes For Space-Time Discretizations ,  Journal of Computational and Applied Mathematics , 310, pp. 19-31,  2017 .  S. Osborn, P. Zulian, T. Benson, U. Villa, R. Krause, and P. S. Vassilevski,  Scalable hierarchical PDE sampler for generating spatially correlated random fields using non-matching meshes ,  Numerical Linear Algebra with Applications , 25, pp. e2146,  Dec. 2017 .  J. H. Adler, I. Lashuk, and S. P. MacLachlan,  Composite-grid multigrid for diffusion on the sphere ,  Numerical Linear Algebra with Applications , 25(1), pp. e2115,  2017 .  J. Gopalakrishnan, M. Neum\u00fcller, and P. Vassilevski,  The auxiliary space preconditioner for the de Rham complex ,  arXiv:1710.07840 ,  Oct. 2017 .  S. Zampini, P. S. Vassilevski, V. Dobrev, and T. Kolev,  Balancing Domain Decomposition by Constraints Algorithms for Curl-conforming Spaces of Arbitrary Order ,  Domain Decomposition Methods in Science and Engineering XXIV ,  2017 .  M. Larsen, J. Ahrens, U. Ayachit, E. Brugger, H. Childs, B. Geveci, and C. Harrison,  The ALPINE In Situ Infrastructure: Ascending from the Ashes of Strawman ,  ISAV 2017: In Situ Infrastructures for Enabling Extreme-scale Analysis and Visualization ,  Nov. 2017 .  J. Wright and S. Shiraiwa,  Antenna to Core: A New Approach to RF Modelling ,  22 Topical Conference on Radio-Frequency Power in Plasmas ,  2017 .  S. Shiraiwa,  J. C. Wright,  P. T. Bonoli,  Tz. Kolev, and  M. Stowell,  RF wave simulation for cold edge plasmas using the MFEM library ,  22 Topical Conference on Radio-Frequency Power in Plasmas ,  2017 .  C. Hofer, U. Langer, M. Neum ller, and I. Toulopoulos,  Time-Multipatch Discontinuous Galerkin Space-Time Isogeometric Analysis of Parabolic Evolution Problems ,  RICAM-Report 2017-26 ,  2017 .  J. Billings, A. McCaskey, G. Vallee, and G. Watson,  Will humans even write code in 2040 and what would that mean for extreme heterogeneity in computing? ,  arXiv:1712.00676 ,  Dec. 2017 .  M. L. C. Christensen, U. Villa, A. Engsig-Karup, and P. S. Vassilevski,  Numerical Multilevel Upscaling For Incompressible Flow in Reservoir Simulation: An Element-Based Algebraic Multigrid (AMGe) Approach ,  SIAM Journal on Scientific Computing , 39(1), pp. B102-B137,  Feb. 2017 .  R. Anderson, V. Dobrev, Tz. Kolev, D. Kuzmin, M. Q. de Luna, R. Rieben, and V. Tomov,  High-order local maximum principle preserving (MPP) discontinuous Galerkin finite element method for the transport equation ,  Journal of Computational Physics , 334, pp. 102-124,  Apr. 2017 .  R. Li and Y. Saad,  Low-Rank Correction Methods for Algebraic Domain Decomposition Preconditioners ,  SIAM Journal on Matrix Analysis and Applications , 38(3), pp. 807-828,  Aug. 2017 .  D. Z. Kalchev, C. S. Lee, U. Villa, Y. Efendiev, and P. S. Vassilevski,  Upscaling of Mixed Finite Element Discretization Problems by the Spectral AMGe Method ,  SIAM Journal on Scientific Computing , 38(5), pp. A2912\u2013A2933,  Sep. 2016 .  V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov,  Multi-material closure model for high-order finite element Lagrangian hydrodynamics ,  International Journal for Numerical Methods in Fluids , 82(10), pp. 689-706,  2016 .  J. Guermond, B. Popov, and V. Tomov,  Entropy-viscosity method for the single material Euler equations in Lagrangian frame ,  Computer Methods in Applied Mechanics and Engineering , 300, pp. 402 - 426,  Mar. 2016 .  M. Holec, J. Limpouch, R. Liska, and S. Weber,  High-order discontinuous Galerkin nonlocal transport and energy equations scheme for radiation hydrodynamics ,  International Journal for Numerical Methods in Fluids , 83(10), pp. 779-797,  2016 .  Tz. V. Kolev, J. Xu, and Y. Zhu,  Multilevel Preconditioners for Reaction-Diffusion Problems with Discontinuous Coefficients ,  Journal of Scientific Computing , 67(1), pp. 324--350,  Apr. 2016 .  M. Reberol and B. L vy,  Low-order continuous finite element spaces on hybrid non-conforming hexahedral-tetrahedral meshes ,  CoRR , abs/1605.02626,  2016 .  O. Marques, A. Druinsky, X. S. Li, A. T. Barker, P. Vassilevski, and D. Kalchev,  Tuning the Coarse Space Construction in a Spectral AMG Solver ,  Procedia Computer Science , 80, pp. 212 - 221, International Conference on Computational Science 2016, ICCS 2016, 6-8 June 2016, San Diego, California, USA,  2016 .  J. S. Yeom, J. J. Thiagarajan, A. Bhatele, G. Bronevetsky, and T. Kolev,  Data-Driven Performance Modeling of Linear Solvers for Sparse Matrices ,  2016 7th International Workshop on Performance Modeling, Benchmarking and Simulation of High Performance Computer Systems (PMBS) ,  Nov. 2016 .  D. Osei-Kuffuor, R. Li, and Y. Saad,  Matrix Reordering Using Multilevel Graph Coarsening for ILU Preconditioning ,  SIAM Journal on Scientific Computing , 37(1), pp. A391-A419,  Feb. 2015 .  R. Anderson, V. Dobrev, Tz. Kolev, and R. Rieben,  Monotonicity in high-order curvilinear finite element ALE remap ,  Int. J. Numer. Meth. Fluids , 77(5), pp. 249\u2013273,  2014 .  V. Dobrev, Tz. Kolev, and R. Rieben,  High-order curvilinear finite element methods for elastic-plastic Lagrangian dynamics ,  J. Comp. Phys. , (257B), pp. 1062\u20131080,  2014 .  P. Vassilevski and U. Villa,  A mixed formulation for the Brinkman problem ,  SIAM Journal on Numerical Analysis , 52-1, pp. 258-281,  2014 .  J. H. Adler and P. S. Vassilevski,  Error Analysis for Constrained First-Order System Least-Squares Finite-Element Methods ,  SIAM Journal on Scientific Computing , 36(3), pp. A1071-A1088,  2014 .  A. Aposporidis, P. S. Vassilevski, and A. Veneziani,  Multigrid preconditioning of the non-regularized augmented Bingham fluid problem ,  ETNA. Electronic Transactions on Numerical Analysis , 41,  Jan. 2014 .  P. S. Vassilevski and U. M. Yang,  Reducing communication in algebraic multigrid using additive variants ,  Numerical Linear Algebra with Applications , 21(2), pp. 275-296,  2014 .  T. Dong, V. Dobrev, T. Kolev, R. Rieben, S. Tomov, and J. Dongarra,  A Step towards Energy Efficient Computing: Redesigning a Hydrodynamic Application on CPU-GPU ,  2014 IEEE 28th International Parallel and Distributed Processing Symposium ,  May 2014 .  P. Vassilevski and U. Villa,  A block-diagonal algebraic multigrid preconditioner for the Brinkman problem ,  SIAM Journal on Scientific Computing , 35-5, pp. S3-S17,  2013 .  V. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben,  High-order curvilinear finite elements for axisymmetric Lagrangian hydrodynamics ,  Computers and Fluids , pp. 58-69,  2013 .  D. Kalchev, C. Ketelsen, and P. S. Vassilevski,  Two-level adaptive algebraic multigrid for sequence of problems with slowly varying random coefficients ,  SIAM Journal on Scientific Computing , 35(6), pp. B1215-B1234,  Nov. 2013 .  P. D'Ambra and P. S. Vassilevski,  Adaptive AMG with coarsening based on compatible weighted matching ,  Computing and Visualization in Science , 16(2), pp. 59--76,  Apr. 2013 .  T. A. Brunner, T. V. Kolev, T. S. Bailey, and A. T. Till,  Preserving Spherical Symmetry in Axisymmetric Coordinates for Diffusion ,  International Conference on Mathematics and Computational Methods Applied to Nuclear Science   Engineering ,  2013 .  Tz. Kolev and P. Vassilevski,  Parallel auxiliary space AMG solver for H(div) problems ,   SIAM Journal on Scientific Computing , 34, pp. A3079\u2013A3098,  2012 .  V. Dobrev, Tz. Kolev, and R. Rieben,  High-order curvilinear finite element methods for Lagrangian hydrodynamics ,  SIAM Journal on Scientific Computing , 34, pp. B606\u2013B641,  2012 .  I. Lashuk and  P.Vassilevski,  Element agglomeration coarse Raviart-Thomas spaces with improved approximation properties ,  Numerical Linear Algebra with Applications , 19, pp. 414-426,  2012 .  D. Kalchev,  Adaptive algebraic multigrid for \ufb01nite element elliptic equations with random coe\ufb03cients ,  LLNL Tech. Report , LLNL-TR-553254,  2012 .  A. Aposporidis, P. Vassilevski, and A. Veneziani,  A geometric nonlinear AMLI preconditioner for the Bingham fluid flow in mixed variables ,  LLNL Tech. Report , LLNL-JRNL-600372,  2012 .  P. Knupp,  Introducing the target-matrix paradigm for mesh optimization by node movement ,  Engineering with Computers , 28(4), pp. 419--429,  2012 .  T. A. Brunner,  Mulard: A Multigroup Thermal Radiation Diffusion Mini-Application ,  DOE Exascale Research Conference, Portland, Oregon ,  2012 .  A. Baker, R. Falgout, T. Kolev, and U. Yang,  Multigrid smoothers for ultra-parallel computing ,  SIAM Journal on Scientific Computing , 33(5), pp. 2864-2887,  Oct. 2011 .  V. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben,  Curvilinear finite elements for Lagrangian hydrodynamics ,  Int. J. Numer. Meth. Fluids , 65, pp. 1295\u20131310,  2011 .  V. Dobrev, J.-L. Guermond, and B. Popov,  Surface reconstruction and image enhancement via L1-minimization ,  SIAM Journal on Scientific Computing , 32 (3), pp. 1591-1616,  2010 .  J. Brannick and R. Falgout,  Compatible relaxation and coarsening in algebraic multigrid ,  SIAM Journal on Scientific Computing , 32, pp. 1393-1416,  2010 .  A. Baker, Tz. Kolev, and U. M. Yang,  Improving algebraic multigrid interpolation operators for linear elasticity problems ,  Numerical Linear Algebra with Applications , 17, pp. 495-517,  2010 .  U. M. Yang,  On long-range interpolation operators for aggressive coarsening ,  Numerical Linear Algebra with Applications , 17, pp. 453\u2013472,  2010 .  Tz. Kolev and P. Vassilevski,  Parallel auxiliary space AMG for H(curl) problems ,  Journal of Computational Mathematics , 27, pp. 604-623,  2009 .  Tz. V. Kolev and R. N. Rieben,  A tensor artificial viscosity using a finite element approach ,  Journal of Computational Physics , 228(22), pp. 8336 - 8366,  2009 .  A. Baker, E. Jessup, and Tz. Kolev,  A simple strategy for varying the restart parameter in GMRES(m) ,  J. Comp. Appl. Math. , 230, pp. 751-761,  2009 .  Tz. Kolev, J. Pasciak, and P. Vassilevski,  H(curl) auxiliary mesh preconditioning ,  Numerical Linear Algebra with Applications , 15, pp. 455\u2013471,  2008 .  H. De Sterck, R. Falgout, J. Nolting, and U. M. Yang,  Distance-two interpolation for parallel algebraic multigrid ,  Numerical Linear Algebra with Applications , 15, pp. 115\u2013139,  Apr. 2008 .  V. Dobrev, R. Lazarov, and L. Zikatanov,  Preconditioning of symmetric interior penalty discontinuous Galerkin FEM for second order elliptic problems , in Domain Decomposition Methods in Science and Engineering XVII, Lecture Notes in Computational Science and Engineering, vol. 60, U. Langer et al. eds, Springer-Verlag, Berlin, Heidelberg, pp. 33-44,  2008 .  D. Alber and L. Olson,  Parallel coarse grid selection ,  Numerical Linear Algebra with Applications , 14, pp. 611-643,  2007 .  V. Dobrev, R. Lazarov, P. Vassilevski, and L. Zikatanov,  Two-level preconditioning of discontinuous Galerkin approximations of second-order elliptic equations ,  Numerical Linear Algebra with Applications , 13 (9), pp. 753-770,  2006 .  Tz. Kolev and P. Vassilevski,  AMG by element agglomeration and constrained energy minimization interpolation ,  Numerical Linear Algebra with Applications , 13, pp. 771\u2013788,  2006 .  J. Bramble, Tz. Kolev, and J. Pasciak,  A least-squares approximation method for the time-harmonic Maxwell equations ,  Journal of Numerical Mathematics , 13(4), pp. 237-263,  2005 .  P. Vassilevski,  Sparse matrix element topology with application to AMG(e) and preconditioning ,  Numerical Linear Algebra with Applications , 9, pp. 429--444,  2002 .   MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Selected Publications"
        }, 
        {
            "location": "/about/", 
            "text": "About MFEM\n\n\nMFEM originates from previous research effort in the (unreleased) \nAggieFEM/aFEM\n project.\n\n\nPlease cite with:\n\n\n@misc{mfem-library,\n  title = {{MFEM}: Modular Finite Element Methods Library},\n  howpublished = {\\url{mfem.org}},\n  doi = {10.11578/dc.20171025.1248}\n}\n\n\n\n\nContributors\n\n\n\n\nIdo Akkerman\n\n\nRobert Anderson\n\n\nThomas Anderson\n\n\nJulian Andrej\n\n\nMikhail Artemyev\n\n\nAndrew Barker\n\n\nThomas Benson\n\n\nAaron Black\n\n\nJamie Bramwell\n\n\nThomas Brunner\n\n\nJean-Sylvain Camier\n\n\nJakub \u010cerven\u00fd\n\n\nJohann Dahm\n\n\nVeselin Dobrev\n\n\nTruman Ellis\n\n\nAaron Fisher\n\n\nPieter Ghysels\n\n\nHennes Hajduk\n\n\nCyrus Harrison\n\n\nKazem Kamran\n\n\nPatrick Knupp\n\n\nTzanio Kolev\n \n Project Leader\n\n\nIlya Lashuk\n\n\nScott MacLachlan\n\n\nPeter Maginot\n\n\nMark Miller\n\n\nKetan Mittal\n\n\nJan Nikl\n\n\nGeoffrey Oxberry\n\n\nWill Pazner\n\n\nRobert Rieben\n\n\nJoachim Sch\u00f6berl\n\n\nJean Sexton\n\n\nSyun'ichi Shiraiwa\n\n\nCameron Smith\n\n\nThomas Stitt\n\n\nMark Stowell\n\n\nStanimire Tomov\n\n\nVladimir Tomov\n\n\nArturo Vargas\n\n\nUmberto Villa\n\n\nKenneth Weiss\n\n\nDaniel White\n\n\nStefano Zampini\n\n\n\n\nLicense\n\n\n\n\nGNU Lesser GPL v2.1\n\n\n\n\n\n\nThis work performed under the auspices of the U.S. Department of Energy\nby Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344.\n\n\nSoftware release number: LLNL-CODE-443211.\n\n\nDOI: \n10.11578/dc.20171025.1248\n.\n\n\n\n\nWebsite built with \nMkDocs\n, \nBootstrap\n\nand \nBootswatch\n. Hosted on \nGitHub\n.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-mfem", 
            "text": "MFEM originates from previous research effort in the (unreleased)  AggieFEM/aFEM  project.  Please cite with:  @misc{mfem-library,\n  title = {{MFEM}: Modular Finite Element Methods Library},\n  howpublished = {\\url{mfem.org}},\n  doi = {10.11578/dc.20171025.1248}\n}", 
            "title": "About MFEM"
        }, 
        {
            "location": "/about/#contributors", 
            "text": "Ido Akkerman  Robert Anderson  Thomas Anderson  Julian Andrej  Mikhail Artemyev  Andrew Barker  Thomas Benson  Aaron Black  Jamie Bramwell  Thomas Brunner  Jean-Sylvain Camier  Jakub \u010cerven\u00fd  Johann Dahm  Veselin Dobrev  Truman Ellis  Aaron Fisher  Pieter Ghysels  Hennes Hajduk  Cyrus Harrison  Kazem Kamran  Patrick Knupp  Tzanio Kolev    Project Leader  Ilya Lashuk  Scott MacLachlan  Peter Maginot  Mark Miller  Ketan Mittal  Jan Nikl  Geoffrey Oxberry  Will Pazner  Robert Rieben  Joachim Sch\u00f6berl  Jean Sexton  Syun'ichi Shiraiwa  Cameron Smith  Thomas Stitt  Mark Stowell  Stanimire Tomov  Vladimir Tomov  Arturo Vargas  Umberto Villa  Kenneth Weiss  Daniel White  Stefano Zampini", 
            "title": "Contributors"
        }, 
        {
            "location": "/about/#license", 
            "text": "GNU Lesser GPL v2.1    This work performed under the auspices of the U.S. Department of Energy\nby Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344.  Software release number: LLNL-CODE-443211.  DOI:  10.11578/dc.20171025.1248 .   Website built with  MkDocs ,  Bootstrap \nand  Bootswatch . Hosted on  GitHub .", 
            "title": "License"
        }, 
        {
            "location": "/gallery/", 
            "text": "Gallery\n\n\nThis page collects screenshots from various simulations based on MFEM. Additional images can be found in the \nGLVis gallery\n.\n\n\n\n\n\n\n\n\n\n\nA version of the MFEM logo demonstrating curvilinear elements, \nadaptive mesh refinement\n and (idealized) parallel partitioning. Visualization with \nGLVis\n.\n\n\n\n\n\n\nFibers generated by LDRB approach based on 4 Laplacian solves in the \nCardioid\n project.\n\n\n\n\n\n\nSolution of a Maxwell problem on a Klein bottle. Mesh generated with the \nklein-bottle\n miniapp. Solution with \nExample 3\n.\n\n\n\n\n\n\nComparisons of equipotential surfaces and force lines from Maxwell's \nTreatise on Electricity and Magnetism\n with results from MFEM's \nVolta miniapp\n.\n\n\n\n\n\n\nLevel surfaces in the interior of the solution from \nExample 1\n on \nescher.mesh\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\n3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Volume visualization with \nVisIt\n.\n\n\n\n\n\n\nModeling elastic-plastic flow in the 3D Taylor high-velocity impact problem using 4th order mixed elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nVisIt\n.\n\n\n\n\n\n\nTriple point shock interaction\n on 4 elements of order 12.  Note the element curvature and the high variation of the field inside the lower right element.\n\n\n\n\n\n\n\n\nStreamlines of the magnetic field from a \nparallel computation\n of the magnetostatic interaction of two magnetic orbs. Visualization with \nVTK\n.\n\n\n\n\n\n\nTest of the propagation of a spherical shock wave through a random non-conforming mesh in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nGLVis\n.\n\n\n\n\n\n\nAn electromagnetic eigenmode of a star-shaped domain computed with 3rd order finite elements computed with \nExample 13\n.\n\n\n\n\n\n\nCut image of the solution from \nExample 1\n on a sharply twisted, high order toroidal mesh.  The mesh was generated with the \ntoroid\n miniapp.\n\n\n\n\n\n\nHigh-order multi-material inertial confinement fusion (ICF)-like implosion in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nVisIt\n.\n\n\n\n\n\n\nTwo-region AMR mesh generated by the \nShaper\n miniapp from successive adaptation to the outlines of Australia.\n\n\n\n\n\n\nPoisson problem on a \"Breather\" surface. Mesh generated with the \nMesh Explorer\n miniapp. Solution with \nExample 1\n.\n\n\n\n\n\n\nRadiating Kevin-Helmholtz modeled with the MFEM-based \nBLAST\n shock hydrodynamics code. Volume visualization with \nVisIt\n.\n\n\n\n\n\n\nThe \nShaper\n miniapp applied to a multi-material input functions described by the iterates of the Mandelbrot set. Visualization with \nGLVis\n.\n\n\n\n\n\n\nTopology optimization of a drone body using LLNL's \nLiDO project\n, based on MFEM.\n\n\n\n\n\n\n\n\nPurely Lagrangian Rayleigh-Taylor instability simulation using 8th order mixed elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nGLVis\n.\n\n\n\n\n\n\nMulti-mode Rayleigh-Taylor instability simulation using 4th order mixed elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nVisIt\n.\n\n\n\n\n\n\nAnisotropic refinement in a 2D shock-like AMR test problem. Visualization with \nGLVis\n.\n\n\n\n\n\n\nParallel version of \nExample 1\n on 100 processors with a relatively coarse version of \nsquare-disc.mesh\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\nAnisotropic refinement in a 3D version of the AMR test. Portion of the spherical domain is cut away in \nGLVis\n.\n\n\n\n\n\n\nStructural topology optimization with MFEM in LLNL's \nCenter for Design and Optimization\n.\n\n\n\n\n\n\nTest of the anisotropic refinement feature on a random mesh. A slightly modified version of \nExample 1\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\nLevel lines in a cutting plane of the solution from the parallel version of \nExample 1\n on 64 processors with \nfichera.mesh\n. Visualization with \nGLVis\n.", 
            "title": "Gallery"
        }, 
        {
            "location": "/gallery/#gallery", 
            "text": "This page collects screenshots from various simulations based on MFEM. Additional images can be found in the  GLVis gallery .      A version of the MFEM logo demonstrating curvilinear elements,  adaptive mesh refinement  and (idealized) parallel partitioning. Visualization with  GLVis .    Fibers generated by LDRB approach based on 4 Laplacian solves in the  Cardioid  project.    Solution of a Maxwell problem on a Klein bottle. Mesh generated with the  klein-bottle  miniapp. Solution with  Example 3 .    Comparisons of equipotential surfaces and force lines from Maxwell's  Treatise on Electricity and Magnetism  with results from MFEM's  Volta miniapp .    Level surfaces in the interior of the solution from  Example 1  on  escher.mesh . Visualization with  GLVis .    3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based  BLAST  shock hydrodynamics code. Volume visualization with  VisIt .    Modeling elastic-plastic flow in the 3D Taylor high-velocity impact problem using 4th order mixed elements in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  VisIt .    Triple point shock interaction  on 4 elements of order 12.  Note the element curvature and the high variation of the field inside the lower right element.     Streamlines of the magnetic field from a  parallel computation  of the magnetostatic interaction of two magnetic orbs. Visualization with  VTK .    Test of the propagation of a spherical shock wave through a random non-conforming mesh in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  GLVis .    An electromagnetic eigenmode of a star-shaped domain computed with 3rd order finite elements computed with  Example 13 .    Cut image of the solution from  Example 1  on a sharply twisted, high order toroidal mesh.  The mesh was generated with the  toroid  miniapp.    High-order multi-material inertial confinement fusion (ICF)-like implosion in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  VisIt .    Two-region AMR mesh generated by the  Shaper  miniapp from successive adaptation to the outlines of Australia.    Poisson problem on a \"Breather\" surface. Mesh generated with the  Mesh Explorer  miniapp. Solution with  Example 1 .    Radiating Kevin-Helmholtz modeled with the MFEM-based  BLAST  shock hydrodynamics code. Volume visualization with  VisIt .    The  Shaper  miniapp applied to a multi-material input functions described by the iterates of the Mandelbrot set. Visualization with  GLVis .    Topology optimization of a drone body using LLNL's  LiDO project , based on MFEM.     Purely Lagrangian Rayleigh-Taylor instability simulation using 8th order mixed elements in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  GLVis .    Multi-mode Rayleigh-Taylor instability simulation using 4th order mixed elements in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  VisIt .    Anisotropic refinement in a 2D shock-like AMR test problem. Visualization with  GLVis .    Parallel version of  Example 1  on 100 processors with a relatively coarse version of  square-disc.mesh . Visualization with  GLVis .    Anisotropic refinement in a 3D version of the AMR test. Portion of the spherical domain is cut away in  GLVis .    Structural topology optimization with MFEM in LLNL's  Center for Design and Optimization .    Test of the anisotropic refinement feature on a random mesh. A slightly modified version of  Example 1 . Visualization with  GLVis .    Level lines in a cutting plane of the solution from the parallel version of  Example 1  on 64 processors with  fichera.mesh . Visualization with  GLVis .", 
            "title": "Gallery"
        }, 
        {
            "location": "/download/", 
            "text": "Latest Release\n\n\nNew features\n\n\u250a \nExample codes\n\n\u250a \nCode documentation\n\n\u250a \nSources\n\n\n\n\nDownload mfem-4.0tgz\n\n\n\n\nPlease use the GitHub \nissue tracker\n\nto report \nbugs\n\nor post \nquestions\n or \ncomments\n.\n\n\nAll Releases\n\n\n\n\n\n\n\n\nFilename\n\n\nVersion\n\n\nRelease Date\n\n\nSize\n\n\nSLOC\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n\n\nmfem-4.0.tgz\n\n\nv4.0\n\n\nMay 2019\n\n\n5.2M\n\n\n167K\n\n\nGPU support\n\n\n\n\n\n\n\n\nmfem-3.4.tgz\n\n\nv3.4\n\n\nMay 2018\n\n\n4.4M\n\n\n134K\n\n\n\n\n\n\n\n\n\n\nmfem-3.3.2.tgz\n\n\nv3.3.2\n\n\nNov 2017\n\n\n4.2M\n\n\n123K\n\n\nmesh optimization\n\n\n\n\n\n\n\n\nmfem-3.3.tgz\n\n\nv3.3\n\n\nJan 2017\n\n\n4.0M\n\n\n112K\n\n\n\n\n\n\n\n\n\n\nmfem-3.2.tgz\n\n\nv3.2\n\n\nJun 2016\n\n\n3.3M\n\n\n92K\n\n\ndynamic AMR, HPC miniapps\n\n\n\n\n\n\n\n\nmfem-3.1.tgz\n\n\nv3.1\n\n\nFeb 2016\n\n\n2.9M\n\n\n80K\n\n\nfem \u2194\n linear system interface\n\n\n\n\n\n\n\n\nmfem-3.0.1.tgz\n\n\nv3.0.1\n\n\nJan 2015\n\n\n1.1M\n\n\n61K\n\n\n\n\n\n\n\n\n\n\nmfem-3.0.tgz\n\n\nv3.0\n\n\nJan 2015\n\n\n1.1M\n\n\n61K\n\n\nnon-conforming AMR\n\n\n\n\n\n\n\n\nmfem-2.0.tgz\n\n\nv2.0\n\n\nNov 2011\n\n\n308K\n\n\n40K\n\n\narbitrary order spaces, NURBS\n\n\n\n\n\n\n\n\nmfem-v1.2.2.tgz\n\n\nv1.2.2\n\n\nApr 2011\n\n\n240K\n\n\n28K\n\n\n\n\n\n\n\n\n\n\nmfem-v1.2.1.tgz\n\n\nv1.2.1\n\n\nApr 2011\n\n\n240K\n\n\n28K\n\n\n\n\n\n\n\n\n\n\nmfem-v1.2.tgz\n\n\nv1.2\n\n\nApr 2011\n\n\n240K\n\n\n28K\n\n\nMPI parallelism based on hypre\n\n\n\n\n\n\n\n\nmfem-v1.1.tgz\n\n\nv1.1\n\n\nSep 2010\n\n\n166K\n\n\n23K\n\n\n\n\n\n\n\n\n\n\nmfem-v1.0.tgz\n\n\nv1.0\n\n\nJul 2010\n\n\n160K\n\n\n22K\n\n\ninitial release", 
            "title": "Download"
        }, 
        {
            "location": "/download/#latest-release", 
            "text": "New features \n\u250a  Example codes \n\u250a  Code documentation \n\u250a  Sources   Download mfem-4.0tgz   Please use the GitHub  issue tracker \nto report  bugs \nor post  questions  or  comments .", 
            "title": "Latest Release"
        }, 
        {
            "location": "/download/#all-releases", 
            "text": "Filename  Version  Release Date  Size  SLOC  Notes       mfem-4.0.tgz  v4.0  May 2019  5.2M  167K  GPU support     mfem-3.4.tgz  v3.4  May 2018  4.4M  134K      mfem-3.3.2.tgz  v3.3.2  Nov 2017  4.2M  123K  mesh optimization     mfem-3.3.tgz  v3.3  Jan 2017  4.0M  112K      mfem-3.2.tgz  v3.2  Jun 2016  3.3M  92K  dynamic AMR, HPC miniapps     mfem-3.1.tgz  v3.1  Feb 2016  2.9M  80K  fem \u2194  linear system interface     mfem-3.0.1.tgz  v3.0.1  Jan 2015  1.1M  61K      mfem-3.0.tgz  v3.0  Jan 2015  1.1M  61K  non-conforming AMR     mfem-2.0.tgz  v2.0  Nov 2011  308K  40K  arbitrary order spaces, NURBS     mfem-v1.2.2.tgz  v1.2.2  Apr 2011  240K  28K      mfem-v1.2.1.tgz  v1.2.1  Apr 2011  240K  28K      mfem-v1.2.tgz  v1.2  Apr 2011  240K  28K  MPI parallelism based on hypre     mfem-v1.1.tgz  v1.1  Sep 2010  166K  23K      mfem-v1.0.tgz  v1.0  Jul 2010  160K  22K  initial release", 
            "title": "All Releases"
        }
    ]
}